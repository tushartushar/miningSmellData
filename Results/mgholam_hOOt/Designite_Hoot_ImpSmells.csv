Implementation smell,Namespace,Class,File,Method,Description
Long Method,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,ParseDictionary,The method has 117 lines of code.
Long Method,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,ParseDictionary,The method has 122 lines of code.
Long Method,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The method has 217 lines of code.
Long Method,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The method has 263 lines of code.
Complex Method,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,ToObject,Cyclomatic complexity of the method is 11
Complex Method,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,ParseDictionary,Cyclomatic complexity of the method is 20
Complex Method,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteObject,Cyclomatic complexity of the method is 8
Complex Method,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,ParseDictionary,Cyclomatic complexity of the method is 20
Complex Method,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,ReadDataTable,Cyclomatic complexity of the method is 10
Complex Method,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseString,Cyclomatic complexity of the method is 10
Complex Method,fastJSON,JSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonSerializer.cs,WriteObject,Cyclomatic complexity of the method is 9
Complex Method,fastJSON,JSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonSerializer.cs,WriteString,Cyclomatic complexity of the method is 8
Complex Method,fastJSON,Reflection,C:\repos\mgholam_hOOt\Hoot\fastJSON\Reflection.cs,GetGetters,Cyclomatic complexity of the method is 17
Complex Method,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Flush,Cyclomatic complexity of the method is 8
Complex Method,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,Cyclomatic complexity of the method is 12
Complex Method,RaptorDB,Hoot,C:\repos\mgholam_hOOt\Hoot\Hoot.cs,ExecutionPlan,Cyclomatic complexity of the method is 12
Complex Method,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,RebuildDataFiles,Cyclomatic complexity of the method is 14
Complex Method,RaptorDB,tokenizer,C:\repos\mgholam_hOOt\Hoot\tokenizer.cs,ParseString,Cyclomatic complexity of the method is 9
Complex Method,RaptorDB,tokenizer,C:\repos\mgholam_hOOt\Hoot\tokenizer.cs,AddDictionary,Cyclomatic complexity of the method is 14
Long Parameter List,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreatePageListData,The method has 5 parameters. Parameters: _pages' offset' index' counter' page
Long Parameter List,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The method has 8 parameters. Parameters: src' srcstart' srcLength' dst' dststart' dstlen' workmem' workmemstart
Long Parameter List,RaptorDB,FileLogger,C:\repos\mgholam_hOOt\Hoot\mylogger.cs,FormatLog,The method has 5 parameters. Parameters: log' type' meth' msg' objs
Long Parameter List,RaptorDB,FileLogger,C:\repos\mgholam_hOOt\Hoot\mylogger.cs,Log,The method has 5 parameters. Parameters: logtype' type' meth' msg' objs
Long Statement,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,ParseDictionary,The length of the statement  "            Dictionary<string' myPropInfo> props = Reflection.Instance.Getproperties(type' typename);//' Reflection.Instance.IsTypeRegistered(type)); " is 137.
Long Statement,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,CreateDataset,The length of the statement  "                DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null); " is 128.
Long Statement,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,CreateDataTable,The length of the statement  "                var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null); " is 123.
Long Statement,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,ParseDictionary,The length of the statement  "            Dictionary<string' myPropInfo> props = Reflection.Instance.Getproperties(type' typename);//' Reflection.Instance.IsTypeRegistered(type)); " is 137.
Long Statement,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,ParseDictionary,The length of the statement  "                            case myPropInfoType.StringKeyDictionary: oset = CreateStringKeyDictionary((Dictionary<string' object>)v' pi.pt' pi.GenericTypes' globaltypes); break; " is 149.
Long Statement,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDataset,The length of the statement  "                DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null); " is 128.
Long Statement,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDataTable,The length of the statement  "                var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null); " is 123.
Long Statement,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Optimize,The length of the statement  "                        Stream _newrec = new FileStream(_Path + _FileName + "$" + _recExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite); " is 133.
Long Statement,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Optimize,The length of the statement  "                        Stream _newbmp = new FileStream(_Path + _FileName + "$" + _bmpExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite); " is 133.
Long Statement,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Initialize,The length of the statement  "            _recordFileRead = new FileStream(_Path + _FileName + _recExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite); " is 128.
Long Statement,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Initialize,The length of the statement  "            _recordFileWriteOrg = new FileStream(_Path + _FileName + _recExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite); " is 132.
Long Statement,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Initialize,The length of the statement  "            _bitmapFileRead = new FileStream(_Path + _FileName + _bmpExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite); " is 128.
Long Statement,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Initialize,The length of the statement  "            _bitmapFileWriteOrg = new FileStream(_Path + _FileName + _bmpExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite); " is 132.
Long Statement,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The length of the statement  "            uint compressedSize = Compress(sourceBuffer' sourceOffset' sourceLength' destinationBuffer' 0' destinationLength' workspaceBuffer' workspaceOffset); " is 148.
Long Statement,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The length of the statement  "            byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))]; " is 132.
Long Statement,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,CreateNewStorageFile,The length of the statement  "            FileStream file = new FileStream(_filename + i.ToString(_splitfileExtension)' FileMode.Open' FileAccess.Read' FileShare.ReadWrite); " is 131.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseNumber,The conditional expression  "(c >= '0' && c <= '9') || c == '.' || c == '-' || c == '+' || c == 'e' || c == 'E'"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The conditional expression  "c != ' ' && c != '\t' && c != '\n' && c != '\r'"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The conditional expression  "json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e'"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The conditional expression  "json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e'"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The conditional expression  "json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l'"  is complex.
Complex Conditional,fastJSON,JSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonSerializer.cs,WriteValue,The conditional expression  "obj is int || obj is long ||                  obj is decimal ||                  obj is byte || obj is short ||                  obj is sbyte || obj is ushort ||                  obj is uint || obj is ulong"  is complex.
Complex Conditional,fastJSON,JSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonSerializer.cs,WriteValue,The conditional expression  "_params.KVStyleStringDictionary == false && obj is IDictionary &&                  obj.GetType().IsGenericType && obj.GetType().GetGenericArguments()[0] == typeof(string)"  is complex.
Complex Conditional,fastJSON,JSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonSerializer.cs,WriteString,The conditional expression  "c >= ' ' && c < 128 && c != '\"' && c != '\\'"  is complex.
Complex Conditional,fastJSON,JSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonSerializer.cs,WriteString,The conditional expression  "c != '\t' && c != '\n' && c != '\r' && c != '\"' && c != '\\'"  is complex.
Complex Conditional,fastJSON,Reflection,C:\repos\mgholam_hOOt\Hoot\fastJSON\Reflection.cs,CreateMyProp,The conditional expression  "t.IsValueType && !t.IsPrimitive && !t.IsEnum && t != typeof(decimal)"  is complex.
Complex Conditional,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageListData,The conditional expression  "b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3]"  is complex.
Complex Conditional,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageFromPageNumber,The conditional expression  "b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3]"  is complex.
Complex Conditional,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The conditional expression  "pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++"  is complex.
Complex Conditional,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The conditional expression  "!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match"  is complex.
Empty Catch Block,RaptorDB,MGIndex<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\MGIndex.cs,FreeMemory,The method has an empty catch block.
Magic Number,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,CreateDataset,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  ds.ReadXmlSchema(tr);              }              else              {                  DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  ds.DataSetName = ms.Name;                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      if (ds.Tables.Contains(ms.Info[i]) == false)                          ds.Tables.Add(ms.Info[i]);                      ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,CreateDataset,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  ds.ReadXmlSchema(tr);              }              else              {                  DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  ds.DataSetName = ms.Name;                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      if (ds.Tables.Contains(ms.Info[i]) == false)                          ds.Tables.Add(ms.Info[i]);                      ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,CreateDataTable,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  dt.ReadXmlSchema(tr);              }              else              {                  var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  dt.TableName = ms.Info[0];                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      dt.Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastBinaryJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJSON.cs,CreateDataTable,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  dt.ReadXmlSchema(tr);              }              else              {                  var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  dt.TableName = ms.Info[0];                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      dt.Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseChar,The following statement contains a magic number: index += 2;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseGuid,The following statement contains a magic number: byte[] b = new byte[16];
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseGuid,The following statement contains a magic number: Buffer.BlockCopy(json' index' b' 0' 16);
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseGuid,The following statement contains a magic number: index += 16;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseFloat,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseUShort,The following statement contains a magic number: index += 2;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseULong,The following statement contains a magic number: index += 8;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseUint,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseShort,The following statement contains a magic number: index += 2;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseLong,The following statement contains a magic number: index += 8;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseInt,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDouble,The following statement contains a magic number: index += 8;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseUnicodeString,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseString,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: int[] i = new int[4];
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: i[2] = Helper.ToInt32(json' index);
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: i[3] = Helper.ToInt32(json' index);
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseDateTime,The following statement contains a magic number: index += 8;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseByteArray,The following statement contains a magic number: index += 4;
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteUShort,The following statement contains a magic number: _output.Write(Helper.GetBytes(p' false)' 0' 2);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteShort,The following statement contains a magic number: _output.Write(Helper.GetBytes(p' false)' 0' 2);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteDecimal,The following statement contains a magic number: foreach (var c in b)                  _output.Write(Helper.GetBytes(c' false)' 0' 4);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteULong,The following statement contains a magic number: _output.Write(Helper.GetBytes((long)p' false)' 0' 8);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteUInt,The following statement contains a magic number: _output.Write(Helper.GetBytes(p' false)' 0' 4);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteLong,The following statement contains a magic number: _output.Write(Helper.GetBytes(p' false)' 0' 8);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteChar,The following statement contains a magic number: _output.Write(Helper.GetBytes((short)p' false)' 0' 2);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteBytes,The following statement contains a magic number: _output.Write(Helper.GetBytes(p.Length' false)' 0' 4);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteInt,The following statement contains a magic number: _output.Write(Helper.GetBytes(i' false)' 0' 4);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteGuid,The following statement contains a magic number: _output.Write(g.ToByteArray()' 0' 16);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteName,The following statement contains a magic number: _output.Write(b' 0' b.Length % 256);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonSerializer.cs,WriteString,The following statement contains a magic number: _output.Write(Helper.GetBytes(b.Length' false)' 0' 4);
Magic Number,fastJSON,JSON,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateLong,The following statement contains a magic number: for (int x = 0; x < count; x++' index++)              {                  char cc = s[index];                    if (cc == '-')                      neg = true;                  else if (cc == '+')                      neg = false;                  else                  {                      num *= 10;                      num += (int)(cc - '0');                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: year = CreateInteger(value' 0' 4);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: month = CreateInteger(value' 5' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: month = CreateInteger(value' 5' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: day = CreateInteger(value' 8' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: day = CreateInteger(value' 8' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: hour = CreateInteger(value' 11' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: hour = CreateInteger(value' 11' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: min = CreateInteger(value' 14' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: min = CreateInteger(value' 14' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: sec = CreateInteger(value' 17' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: sec = CreateInteger(value' 17' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: int p = 20;
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (ms > 0)                  p = 24;
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: th = CreateInteger(value' p + 1' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: tm = CreateInteger(value' p + 1 + 2 + 1' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: tm = CreateInteger(value' p + 1 + 2 + 1' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateInteger,The following statement contains a magic number: for (int x = 0; x < count; x++' index++)              {                  char cc = s[index];                    if (cc == '-')                      neg = true;                  else if (cc == '+')                      neg = false;                  else                  {                      num *= 10;                      num += (int)(cc - '0');                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateGuid,The following statement contains a magic number: if (s.Length > 30)                  return new Guid(s);              else                  return new Guid(Convert.FromBase64String(s));
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: year = CreateInteger(value' 0' 4);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: month = CreateInteger(value' 5' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: month = CreateInteger(value' 5' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: day = CreateInteger(value' 8' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: day = CreateInteger(value' 8' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: hour = CreateInteger(value' 11' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: hour = CreateInteger(value' 11' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: min = CreateInteger(value' 14' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: min = CreateInteger(value' 14' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: sec = CreateInteger(value' 17' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: sec = CreateInteger(value' 17' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDataset,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  ds.ReadXmlSchema(tr);              }              else              {                  DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  ds.DataSetName = ms.Name;                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      if (ds.Tables.Contains(ms.Info[i]) == false)                          ds.Tables.Add(ms.Info[i]);                      ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDataset,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  ds.ReadXmlSchema(tr);              }              else              {                  DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  ds.DataSetName = ms.Name;                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      if (ds.Tables.Contains(ms.Info[i]) == false)                          ds.Tables.Add(ms.Info[i]);                      ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,ReadDataTable,The following statement contains a magic number: foreach (List<object> row in rows)              {                  object[] v = new object[row.Count];                  row.CopyTo(v' 0);                  foreach (int i in guidcols)                  {                      string s = (string)v[i];                      if (s != null && s.Length < 36)                          v[i] = new Guid(Convert.FromBase64String(s));                  }                  if (_params.UseUTCDateTime)                  {                      foreach (int i in datecol)                      {                          string s = (string)v[i];                          if (s != null)                              v[i] = CreateDateTime(s);                      }                  }                  dt.Rows.Add(v);              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDataTable,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  dt.ReadXmlSchema(tr);              }              else              {                  var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  dt.TableName = ms.Info[0];                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      dt.Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JSON.cs,CreateDataTable,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  dt.ReadXmlSchema(tr);              }              else              {                  var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  dt.TableName = ms.Info[0];                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      dt.Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseString,The following statement contains a magic number: {                  while (index < l)                  {                      var c = p[index++];                        if (c == '"')                      {                          if (runIndex != -1)                          {                              if (s.Length == 0)                                  return json.Substring(runIndex' index - runIndex - 1);                                s.Append(json' runIndex' index - runIndex - 1);                          }                          return s.ToString();                      }                        if (c != '\\')                      {                          if (runIndex == -1)                              runIndex = index - 1;                            continue;                      }                        if (index == l) break;                        if (runIndex != -1)                      {                          s.Append(json' runIndex' index - runIndex - 1);                          runIndex = -1;                      }                        switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseString,The following statement contains a magic number: {                  while (index < l)                  {                      var c = p[index++];                        if (c == '"')                      {                          if (runIndex != -1)                          {                              if (s.Length == 0)                                  return json.Substring(runIndex' index - runIndex - 1);                                s.Append(json' runIndex' index - runIndex - 1);                          }                          return s.ToString();                      }                        if (c != '\\')                      {                          if (runIndex == -1)                              runIndex = index - 1;                            continue;                      }                        if (index == l) break;                        if (runIndex != -1)                      {                          s.Append(json' runIndex' index - runIndex - 1);                          runIndex = -1;                      }                        switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseString,The following statement contains a magic number: {                  while (index < l)                  {                      var c = p[index++];                        if (c == '"')                      {                          if (runIndex != -1)                          {                              if (s.Length == 0)                                  return json.Substring(runIndex' index - runIndex - 1);                                s.Append(json' runIndex' index - runIndex - 1);                          }                          return s.ToString();                      }                        if (c != '\\')                      {                          if (runIndex == -1)                              runIndex = index - 1;                            continue;                      }                        if (index == l) break;                        if (runIndex != -1)                      {                          s.Append(json' runIndex' index - runIndex - 1);                          runIndex = -1;                      }                        switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseString,The following statement contains a magic number: {                  while (index < l)                  {                      var c = p[index++];                        if (c == '"')                      {                          if (runIndex != -1)                          {                              if (s.Length == 0)                                  return json.Substring(runIndex' index - runIndex - 1);                                s.Append(json' runIndex' index - runIndex - 1);                          }                          return s.ToString();                      }                        if (c != '\\')                      {                          if (runIndex == -1)                              runIndex = index - 1;                            continue;                      }                        if (index == l) break;                        if (runIndex != -1)                      {                          s.Append(json' runIndex' index - runIndex - 1);                          runIndex = -1;                      }                        switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseSingleChar,The following statement contains a magic number: if (c1 >= '0' && c1 <= '9')                  p1 = (uint)(c1 - '0') * multipliyer;              else if (c1 >= 'A' && c1 <= 'F')                  p1 = (uint)((c1 - 'A') + 10) * multipliyer;              else if (c1 >= 'a' && c1 <= 'f')                  p1 = (uint)((c1 - 'a') + 10) * multipliyer;
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseSingleChar,The following statement contains a magic number: if (c1 >= '0' && c1 <= '9')                  p1 = (uint)(c1 - '0') * multipliyer;              else if (c1 >= 'A' && c1 <= 'F')                  p1 = (uint)((c1 - 'A') + 10) * multipliyer;              else if (c1 >= 'a' && c1 <= 'f')                  p1 = (uint)((c1 - 'a') + 10) * multipliyer;
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,CreateLong,The following statement contains a magic number: foreach (char cc in s)              {                  if (cc == '-')                      neg = true;                  else if (cc == '+')                      neg = false;                  else                  {                      num *= 10;                      num += (int)(cc - '0');                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JSONSerializer,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonSerializer.cs,WriteString,The following statement contains a magic number: for (var index = 0; index < l; ++index)              {                  var c = s[index];                    if (_useEscapedUnicode)                  {                      if (c >= ' ' && c < 128 && c != '\"' && c != '\\')                      {                          if (runIndex == -1)                              runIndex = index;                            continue;                      }                  }                  else                  {                      if (c != '\t' && c != '\n' && c != '\r' && c != '\"' && c != '\\')// && c != ':' && c!=''')                      {                          if (runIndex == -1)                              runIndex = index;                            continue;                      }                  }                    if (runIndex != -1)                  {                      _output.Append(s' runIndex' index - runIndex);                      runIndex = -1;                  }                    switch (c)                  {                      case '\t': _output.Append("\\t"); break;                      case '\r': _output.Append("\\r"); break;                      case '\n': _output.Append("\\n"); break;                      case '"':                      case '\\': _output.Append('\\'); _output.Append(c); break;                      default:                          if (_useEscapedUnicode)                          {                              _output.Append("\\u");                              _output.Append(((int)c).ToString("X4"' NumberFormatInfo.InvariantInfo));                          }                          else                              _output.Append(c);                            break;                  }              }
Magic Number,fastJSON,Reflection,C:\repos\mgholam_hOOt\Hoot\fastJSON\Reflection.cs,CreateSetField,The following statement contains a magic number: Type[] arguments = new Type[2];
Magic Number,fastJSON,Reflection,C:\repos\mgholam_hOOt\Hoot\fastJSON\Reflection.cs,CreateSetMethod,The following statement contains a magic number: Type[] arguments = new Type[2];
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Optimize,The following statement contains a magic number: lock (_oplock)                  lock (_readlock)                      lock (_writelock)                      {                          _stopOperations = true;                          while (_workingCount > 0) Thread.SpinWait(1);                          Flush();                            if (File.Exists(_Path + _FileName + "$" + _bmpExt))                              File.Delete(_Path + _FileName + "$" + _bmpExt);                            if (File.Exists(_Path + _FileName + "$" + _recExt))                              File.Delete(_Path + _FileName + "$" + _recExt);                            Stream _newrec = new FileStream(_Path + _FileName + "$" + _recExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                          Stream _newbmp = new FileStream(_Path + _FileName + "$" + _bmpExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                            long newoffset = 0;                          int c = (int)(_recordFileRead.Length / 8);                          for (int i = 0; i < c; i++)                          {                              long offset = ReadRecordOffset(i);                                byte[] b = ReadBMPData(offset);                              if (b == null)                              {                                  _stopOperations = false;                                  throw new Exception("bitmap index file is corrupted");                              }                                _newrec.Write(Helper.GetBytes(newoffset' false)' 0' 8);                              newoffset += b.Length;                              _newbmp.Write(b' 0' b.Length);                            }                          _newbmp.Flush();                          _newbmp.Close();                          _newrec.Flush();                          _newrec.Close();                            InternalShutdown();                            File.Delete(_Path + _FileName + _bmpExt);                          File.Delete(_Path + _FileName + _recExt);                          File.Move(_Path + _FileName + "$" + _bmpExt' _Path + _FileName + _bmpExt);                          File.Move(_Path + _FileName + "$" + _recExt' _Path + _FileName + _recExt);                            Initialize();                          _stopOperations = false;                      }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Optimize,The following statement contains a magic number: lock (_oplock)                  lock (_readlock)                      lock (_writelock)                      {                          _stopOperations = true;                          while (_workingCount > 0) Thread.SpinWait(1);                          Flush();                            if (File.Exists(_Path + _FileName + "$" + _bmpExt))                              File.Delete(_Path + _FileName + "$" + _bmpExt);                            if (File.Exists(_Path + _FileName + "$" + _recExt))                              File.Delete(_Path + _FileName + "$" + _recExt);                            Stream _newrec = new FileStream(_Path + _FileName + "$" + _recExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                          Stream _newbmp = new FileStream(_Path + _FileName + "$" + _bmpExt' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                            long newoffset = 0;                          int c = (int)(_recordFileRead.Length / 8);                          for (int i = 0; i < c; i++)                          {                              long offset = ReadRecordOffset(i);                                byte[] b = ReadBMPData(offset);                              if (b == null)                              {                                  _stopOperations = false;                                  throw new Exception("bitmap index file is corrupted");                              }                                _newrec.Write(Helper.GetBytes(newoffset' false)' 0' 8);                              newoffset += b.Length;                              _newbmp.Write(b' 0' b.Length);                            }                          _newbmp.Flush();                          _newbmp.Close();                          _newrec.Flush();                          _newrec.Close();                            InternalShutdown();                            File.Delete(_Path + _FileName + _bmpExt);                          File.Delete(_Path + _FileName + _recExt);                          File.Move(_Path + _FileName + "$" + _bmpExt' _Path + _FileName + _bmpExt);                          File.Move(_Path + _FileName + "$" + _recExt' _Path + _FileName + _recExt);                            Initialize();                          _stopOperations = false;                      }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadBMPData,The following statement contains a magic number: byte[] b = new byte[8];
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadBMPData,The following statement contains a magic number: _bitmapFileRead.Read(b' 0' 8);
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadBMPData,The following statement contains a magic number: if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)              {                  int c = Helper.ToInt32(b' 2) * 4 + 8;                  byte[] data = new byte[c];                  _bitmapFileRead.Seek(offset' SeekOrigin.Begin);                  _bitmapFileRead.Read(data' 0' c);                  return data;              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadBMPData,The following statement contains a magic number: if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)              {                  int c = Helper.ToInt32(b' 2) * 4 + 8;                  byte[] data = new byte[c];                  _bitmapFileRead.Seek(offset' SeekOrigin.Begin);                  _bitmapFileRead.Read(data' 0' c);                  return data;              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadBMPData,The following statement contains a magic number: if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)              {                  int c = Helper.ToInt32(b' 2) * 4 + 8;                  byte[] data = new byte[c];                  _bitmapFileRead.Seek(offset' SeekOrigin.Begin);                  _bitmapFileRead.Read(data' 0' c);                  return data;              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadBMPData,The following statement contains a magic number: if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)              {                  int c = Helper.ToInt32(b' 2) * 4 + 8;                  byte[] data = new byte[c];                  _bitmapFileRead.Seek(offset' SeekOrigin.Begin);                  _bitmapFileRead.Read(data' 0' c);                  return data;              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadRecordOffset,The following statement contains a magic number: byte[] b = new byte[8];
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadRecordOffset,The following statement contains a magic number: long off = ((long)recnum) * 8;
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,ReadRecordOffset,The following statement contains a magic number: _recordFileRead.Read(b' 0' 8);
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,Initialize,The following statement contains a magic number: _lastRecordNumber = (int)(_recordFileRead.Length / 8);
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmap,The following statement contains a magic number: lock (_writelock)              {                  long offset = SaveBitmapToFile(bmp);                  //long v;                  //if (_offsetCache.TryGetValue(recno' out v))                  //    _offsetCache[recno] = offset;                  //else                  //    _offsetCache.Add(recno' offset);                    long pointer = ((long)recno) * 8;                  _recordFileWrite.Seek(pointer' SeekOrigin.Begin);                  byte[] b = new byte[8];                  b = Helper.GetBytes(offset' false);                  _recordFileWrite.Write(b' 0' 8);              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmap,The following statement contains a magic number: lock (_writelock)              {                  long offset = SaveBitmapToFile(bmp);                  //long v;                  //if (_offsetCache.TryGetValue(recno' out v))                  //    _offsetCache[recno] = offset;                  //else                  //    _offsetCache.Add(recno' offset);                    long pointer = ((long)recno) * 8;                  _recordFileWrite.Seek(pointer' SeekOrigin.Begin);                  byte[] b = new byte[8];                  b = Helper.GetBytes(offset' false);                  _recordFileWrite.Write(b' 0' 8);              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmap,The following statement contains a magic number: lock (_writelock)              {                  long offset = SaveBitmapToFile(bmp);                  //long v;                  //if (_offsetCache.TryGetValue(recno' out v))                  //    _offsetCache[recno] = offset;                  //else                  //    _offsetCache.Add(recno' offset);                    long pointer = ((long)recno) * 8;                  _recordFileWrite.Seek(pointer' SeekOrigin.Begin);                  byte[] b = new byte[8];                  b = Helper.GetBytes(offset' false);                  _recordFileWrite.Write(b' 0' 8);              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: byte[] b = new byte[bits.Length * 4 + 8];
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: byte[] b = new byte[bits.Length * 4 + 8];
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: Buffer.BlockCopy(Helper.GetBytes(bits.Length' false)' 0' b' 2' 4);
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: Buffer.BlockCopy(Helper.GetBytes(bits.Length' false)' 0' b' 2' 4);
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: b[6] = (byte)t;
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: b[7] = (byte)(0);
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: for (int i = 0; i < bits.Length; i++)              {                  byte[] u = Helper.GetBytes((int)bits[i]' false);                  Buffer.BlockCopy(u' 0' b' i * 4 + 8' 4);              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: for (int i = 0; i < bits.Length; i++)              {                  byte[] u = Helper.GetBytes((int)bits[i]' false);                  Buffer.BlockCopy(u' 0' b' i * 4 + 8' 4);              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,SaveBitmapToFile,The following statement contains a magic number: for (int i = 0; i < bits.Length; i++)              {                  byte[] u = Helper.GetBytes((int)bits[i]' false);                  Buffer.BlockCopy(u' 0' b' i * 4 + 8' 4);              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,LoadBitmap,The following statement contains a magic number: {                  bmp.Seek(offset' SeekOrigin.Begin);                    byte[] b = new byte[8];                    bmp.Read(b' 0' 8);                  if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)                  {                      type = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[6]);                      int c = Helper.ToInt32(b' 2);                      byte[] buf = new byte[c * 4];                      bmp.Read(buf' 0' c * 4);                      for (int i = 0; i < c; i++)                      {                          ar.Add((uint)Helper.ToInt32(buf' i * 4));                      }                  }              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,LoadBitmap,The following statement contains a magic number: {                  bmp.Seek(offset' SeekOrigin.Begin);                    byte[] b = new byte[8];                    bmp.Read(b' 0' 8);                  if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)                  {                      type = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[6]);                      int c = Helper.ToInt32(b' 2);                      byte[] buf = new byte[c * 4];                      bmp.Read(buf' 0' c * 4);                      for (int i = 0; i < c; i++)                      {                          ar.Add((uint)Helper.ToInt32(buf' i * 4));                      }                  }              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,LoadBitmap,The following statement contains a magic number: {                  bmp.Seek(offset' SeekOrigin.Begin);                    byte[] b = new byte[8];                    bmp.Read(b' 0' 8);                  if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)                  {                      type = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[6]);                      int c = Helper.ToInt32(b' 2);                      byte[] buf = new byte[c * 4];                      bmp.Read(buf' 0' c * 4);                      for (int i = 0; i < c; i++)                      {                          ar.Add((uint)Helper.ToInt32(buf' i * 4));                      }                  }              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,LoadBitmap,The following statement contains a magic number: {                  bmp.Seek(offset' SeekOrigin.Begin);                    byte[] b = new byte[8];                    bmp.Read(b' 0' 8);                  if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)                  {                      type = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[6]);                      int c = Helper.ToInt32(b' 2);                      byte[] buf = new byte[c * 4];                      bmp.Read(buf' 0' c * 4);                      for (int i = 0; i < c; i++)                      {                          ar.Add((uint)Helper.ToInt32(buf' i * 4));                      }                  }              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,LoadBitmap,The following statement contains a magic number: {                  bmp.Seek(offset' SeekOrigin.Begin);                    byte[] b = new byte[8];                    bmp.Read(b' 0' 8);                  if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)                  {                      type = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[6]);                      int c = Helper.ToInt32(b' 2);                      byte[] buf = new byte[c * 4];                      bmp.Read(buf' 0' c * 4);                      for (int i = 0; i < c; i++)                      {                          ar.Add((uint)Helper.ToInt32(buf' i * 4));                      }                  }              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,LoadBitmap,The following statement contains a magic number: {                  bmp.Seek(offset' SeekOrigin.Begin);                    byte[] b = new byte[8];                    bmp.Read(b' 0' 8);                  if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)                  {                      type = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[6]);                      int c = Helper.ToInt32(b' 2);                      byte[] buf = new byte[c * 4];                      bmp.Read(buf' 0' c * 4);                      for (int i = 0; i < c; i++)                      {                          ar.Add((uint)Helper.ToInt32(buf' i * 4));                      }                  }              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,LoadBitmap,The following statement contains a magic number: {                  bmp.Seek(offset' SeekOrigin.Begin);                    byte[] b = new byte[8];                    bmp.Read(b' 0' 8);                  if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)                  {                      type = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[6]);                      int c = Helper.ToInt32(b' 2);                      byte[] buf = new byte[c * 4];                      bmp.Read(buf' 0' c * 4);                      for (int i = 0; i < c; i++)                      {                          ar.Add((uint)Helper.ToInt32(buf' i * 4));                      }                  }              }
Magic Number,RaptorDB,BitmapIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\BitmapIndex.cs,LoadBitmap,The following statement contains a magic number: {                  bmp.Seek(offset' SeekOrigin.Begin);                    byte[] b = new byte[8];                    bmp.Read(b' 0' 8);                  if (b[0] == (byte)'B' && b[1] == (byte)'M' && b[7] == 0)                  {                      type = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[6]);                      int c = Helper.ToInt32(b' 2);                      byte[] buf = new byte[c * 4];                      bmp.Read(buf' 0' c * 4);                      for (int i = 0; i < c; i++)                      {                          ar.Add((uint)Helper.ToInt32(buf' i * 4));                      }                  }              }
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: byte size = 4;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(int)) size = 4;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(uint)) size = 4;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(long)) size = 8;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(Guid)) size = 16;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(DateTime)) size = 8;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(decimal)) size = 16;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(float)) size = 4;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(short)) size = 2;
Magic Number,RaptorDB,RDBDataType<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetByteSize,The following statement contains a magic number: if (t == typeof(double)) size = 8;
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetBytes,The following statement contains a magic number: byte[] b = new byte[16];
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetBytes,The following statement contains a magic number: foreach (var d in bb)              {                  byte[] db = Helper.GetBytes(d' false);                  Buffer.BlockCopy(db' 0' b' index' 4);                  index += 4;              }
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetBytes,The following statement contains a magic number: foreach (var d in bb)              {                  byte[] db = Helper.GetBytes(d' false);                  Buffer.BlockCopy(db' 0' b' index' 4);                  index += 4;              }
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: int[] i = new int[4];
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: offset += 4;
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: offset += 4;
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: i[2] = Helper.ToInt32(buffer' offset);
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: offset += 4;
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: i[3] = Helper.ToInt32(buffer' offset);
Magic Number,RaptorDB,decimal_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: offset += 4;
Magic Number,RaptorDB,guid_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: byte[] b = new byte[16];
Magic Number,RaptorDB,guid_handler<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\DataTypes.cs,GetObject,The following statement contains a magic number: Buffer.BlockCopy(buffer' offset' b' 0' 16);
Magic Number,RaptorDB,BoolIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\Indexes.cs,ReadFile,The following statement contains a magic number: if (b.Length % 4 > 0) // new format with the data type byte              {                  byte tb = br.ReadByte();                  t = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' tb);              }
Magic Number,RaptorDB,BoolIndex,C:\repos\mgholam_hOOt\Hoot\MGIndex\Indexes.cs,ReadFile,The following statement contains a magic number: for (int i = 0; i < b.Length / 4; i++)              {                  ints.Add((uint)br.ReadInt32());              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,IndexFile,The following statement contains a magic number: if (typeof(T) == typeof(string) )//&& Global.EnableOptimizedStringIndex)              {                  _externalStrings = true;                  _maxKeySize = 4;// blocknum:int              }               else                  _maxKeySize = maxKeySize;
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,IndexFile,The following statement contains a magic number: _rowSize = (_maxKeySize + 1 + 4 + 4);
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,IndexFile,The following statement contains a magic number: _rowSize = (_maxKeySize + 1 + 4 + 4);
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,IndexFile,The following statement contains a magic number: if (File.Exists(filename))              {                  // if file exists open and read header                  _file = File.Open(filename' FileMode.Open' FileAccess.ReadWrite' FileShare.ReadWrite);                  ReadFileHeader();                  if (_externalStrings == false)// if the file says different                  {                      _rowSize = (_maxKeySize + 1 + 4 + 4);                  }                  // compute last page number from file length                   _PageLength = (_BlockHeader.Length + _rowSize * (_PageNodeCount));                  _LastPageNumber = (int)((_file.Length - _FileHeader.Length) / _PageLength);              }              else              {                  // else create new file                  _file = File.Open(filename' FileMode.Create' FileAccess.ReadWrite' FileShare.ReadWrite);                    _PageLength = (_BlockHeader.Length + _rowSize * (_PageNodeCount));                    CreateFileHeader(0);                    _LastPageNumber = (int)((_file.Length - _FileHeader.Length) / _PageLength);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,IndexFile,The following statement contains a magic number: if (File.Exists(filename))              {                  // if file exists open and read header                  _file = File.Open(filename' FileMode.Open' FileAccess.ReadWrite' FileShare.ReadWrite);                  ReadFileHeader();                  if (_externalStrings == false)// if the file says different                  {                      _rowSize = (_maxKeySize + 1 + 4 + 4);                  }                  // compute last page number from file length                   _PageLength = (_BlockHeader.Length + _rowSize * (_PageNodeCount));                  _LastPageNumber = (int)((_file.Length - _FileHeader.Length) / _PageLength);              }              else              {                  // else create new file                  _file = File.Open(filename' FileMode.Create' FileAccess.ReadWrite' FileShare.ReadWrite);                    _PageLength = (_BlockHeader.Length + _rowSize * (_PageNodeCount));                    CreateFileHeader(0);                    _LastPageNumber = (int)((_file.Length - _FileHeader.Length) / _PageLength);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateBlockHeader,The following statement contains a magic number: block[4] = type;
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateBlockHeader,The following statement contains a magic number: Buffer.BlockCopy(b' 0' block' 5' 2);
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateBlockHeader,The following statement contains a magic number: Buffer.BlockCopy(b' 0' block' 5' 2);
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateBlockHeader,The following statement contains a magic number: Buffer.BlockCopy(b' 0' block' 11' 4);
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateBlockHeader,The following statement contains a magic number: Buffer.BlockCopy(b' 0' block' 11' 4);
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateFileHeader,The following statement contains a magic number: lock (_fileLock)              {                  // max key size                  byte[] b = Helper.GetBytes(_maxKeySize' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 3' 1);                  // page node count                  b = Helper.GetBytes(_PageNodeCount' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 4' 2);                  b = Helper.GetBytes(rowsindexed' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 11' 4);                    if (_externalStrings)                      _FileHeader[10] = 1;                    _file.Seek(0L' SeekOrigin.Begin);                  _file.Write(_FileHeader' 0' _FileHeader.Length);                  if (rowsindexed == 0)                  {                      byte[] pagezero = new byte[_PageLength];                      byte[] block = CreateBlockHeader(1' 0' -1);                      Buffer.BlockCopy(block' 0' pagezero' 0' block.Length);                      _file.Write(pagezero' 0' _PageLength);                  }                  _file.Flush();              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateFileHeader,The following statement contains a magic number: lock (_fileLock)              {                  // max key size                  byte[] b = Helper.GetBytes(_maxKeySize' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 3' 1);                  // page node count                  b = Helper.GetBytes(_PageNodeCount' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 4' 2);                  b = Helper.GetBytes(rowsindexed' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 11' 4);                    if (_externalStrings)                      _FileHeader[10] = 1;                    _file.Seek(0L' SeekOrigin.Begin);                  _file.Write(_FileHeader' 0' _FileHeader.Length);                  if (rowsindexed == 0)                  {                      byte[] pagezero = new byte[_PageLength];                      byte[] block = CreateBlockHeader(1' 0' -1);                      Buffer.BlockCopy(block' 0' pagezero' 0' block.Length);                      _file.Write(pagezero' 0' _PageLength);                  }                  _file.Flush();              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateFileHeader,The following statement contains a magic number: lock (_fileLock)              {                  // max key size                  byte[] b = Helper.GetBytes(_maxKeySize' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 3' 1);                  // page node count                  b = Helper.GetBytes(_PageNodeCount' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 4' 2);                  b = Helper.GetBytes(rowsindexed' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 11' 4);                    if (_externalStrings)                      _FileHeader[10] = 1;                    _file.Seek(0L' SeekOrigin.Begin);                  _file.Write(_FileHeader' 0' _FileHeader.Length);                  if (rowsindexed == 0)                  {                      byte[] pagezero = new byte[_PageLength];                      byte[] block = CreateBlockHeader(1' 0' -1);                      Buffer.BlockCopy(block' 0' pagezero' 0' block.Length);                      _file.Write(pagezero' 0' _PageLength);                  }                  _file.Flush();              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateFileHeader,The following statement contains a magic number: lock (_fileLock)              {                  // max key size                  byte[] b = Helper.GetBytes(_maxKeySize' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 3' 1);                  // page node count                  b = Helper.GetBytes(_PageNodeCount' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 4' 2);                  b = Helper.GetBytes(rowsindexed' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 11' 4);                    if (_externalStrings)                      _FileHeader[10] = 1;                    _file.Seek(0L' SeekOrigin.Begin);                  _file.Write(_FileHeader' 0' _FileHeader.Length);                  if (rowsindexed == 0)                  {                      byte[] pagezero = new byte[_PageLength];                      byte[] block = CreateBlockHeader(1' 0' -1);                      Buffer.BlockCopy(block' 0' pagezero' 0' block.Length);                      _file.Write(pagezero' 0' _PageLength);                  }                  _file.Flush();              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateFileHeader,The following statement contains a magic number: lock (_fileLock)              {                  // max key size                  byte[] b = Helper.GetBytes(_maxKeySize' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 3' 1);                  // page node count                  b = Helper.GetBytes(_PageNodeCount' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 4' 2);                  b = Helper.GetBytes(rowsindexed' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 11' 4);                    if (_externalStrings)                      _FileHeader[10] = 1;                    _file.Seek(0L' SeekOrigin.Begin);                  _file.Write(_FileHeader' 0' _FileHeader.Length);                  if (rowsindexed == 0)                  {                      byte[] pagezero = new byte[_PageLength];                      byte[] block = CreateBlockHeader(1' 0' -1);                      Buffer.BlockCopy(block' 0' pagezero' 0' block.Length);                      _file.Write(pagezero' 0' _PageLength);                  }                  _file.Flush();              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreateFileHeader,The following statement contains a magic number: lock (_fileLock)              {                  // max key size                  byte[] b = Helper.GetBytes(_maxKeySize' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 3' 1);                  // page node count                  b = Helper.GetBytes(_PageNodeCount' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 4' 2);                  b = Helper.GetBytes(rowsindexed' false);                  Buffer.BlockCopy(b' 0' _FileHeader' 11' 4);                    if (_externalStrings)                      _FileHeader[10] = 1;                    _file.Seek(0L' SeekOrigin.Begin);                  _file.Write(_FileHeader' 0' _FileHeader.Length);                  if (rowsindexed == 0)                  {                      byte[] pagezero = new byte[_PageLength];                      byte[] block = CreateBlockHeader(1' 0' -1);                      Buffer.BlockCopy(block' 0' pagezero' 0' block.Length);                      _file.Write(pagezero' 0' _PageLength);                  }                  _file.Flush();              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,ReadFileHeader,The following statement contains a magic number: if (b[0] == _FileHeader[0] && b[1] == _FileHeader[1] && b[2] == _FileHeader[2]) // header              {                  byte maxks = b[3];                  ushort nodes = (ushort)Helper.ToInt16(b' 4);                  int root = Helper.ToInt32(b' 6);                  _maxKeySize = maxks;                  _PageNodeCount = nodes;                  _FileHeader = b;                  if (b[10] == 0)                      _externalStrings = false;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,ReadFileHeader,The following statement contains a magic number: if (b[0] == _FileHeader[0] && b[1] == _FileHeader[1] && b[2] == _FileHeader[2]) // header              {                  byte maxks = b[3];                  ushort nodes = (ushort)Helper.ToInt16(b' 4);                  int root = Helper.ToInt32(b' 6);                  _maxKeySize = maxks;                  _PageNodeCount = nodes;                  _FileHeader = b;                  if (b[10] == 0)                      _externalStrings = false;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,ReadFileHeader,The following statement contains a magic number: if (b[0] == _FileHeader[0] && b[1] == _FileHeader[1] && b[2] == _FileHeader[2]) // header              {                  byte maxks = b[3];                  ushort nodes = (ushort)Helper.ToInt16(b' 4);                  int root = Helper.ToInt32(b' 6);                  _maxKeySize = maxks;                  _PageNodeCount = nodes;                  _FileHeader = b;                  if (b[10] == 0)                      _externalStrings = false;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,ReadFileHeader,The following statement contains a magic number: if (b[0] == _FileHeader[0] && b[1] == _FileHeader[1] && b[2] == _FileHeader[2]) // header              {                  byte maxks = b[3];                  ushort nodes = (ushort)Helper.ToInt16(b' 4);                  int root = Helper.ToInt32(b' 6);                  _maxKeySize = maxks;                  _PageNodeCount = nodes;                  _FileHeader = b;                  if (b[10] == 0)                      _externalStrings = false;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,ReadFileHeader,The following statement contains a magic number: if (b[0] == _FileHeader[0] && b[1] == _FileHeader[1] && b[2] == _FileHeader[2]) // header              {                  byte maxks = b[3];                  ushort nodes = (ushort)Helper.ToInt16(b' 4);                  int root = Helper.ToInt32(b' 6);                  _maxKeySize = maxks;                  _PageNodeCount = nodes;                  _FileHeader = b;                  if (b[10] == 0)                      _externalStrings = false;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,ReadFileHeader,The following statement contains a magic number: if (b[0] == _FileHeader[0] && b[1] == _FileHeader[1] && b[2] == _FileHeader[2]) // header              {                  byte maxks = b[3];                  ushort nodes = (ushort)Helper.ToInt16(b' 4);                  int root = Helper.ToInt32(b' 6);                  _maxKeySize = maxks;                  _PageNodeCount = nodes;                  _FileHeader = b;                  if (b[10] == 0)                      _externalStrings = false;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,GetPageList,The following statement contains a magic number: lastIndexedRow = Helper.ToInt32(_FileHeader' 11);
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageListData,The following statement contains a magic number: lock (_fileLock)              {                  // load page list data                  int nextpage = -1;                  SeekPage(page);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      nextpage = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key = _T.GetObject(b' idx + 1' ks);                          int pagenum = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          // add counts                          int unique = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          // FEATURE : add dup count                          PageList.Add(key' new PageInfo(pagenum' unique' 0));                      }                  }                  else                      throw new Exception("Page List header is invalid");                    return nextpage;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageListData,The following statement contains a magic number: lock (_fileLock)              {                  // load page list data                  int nextpage = -1;                  SeekPage(page);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      nextpage = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key = _T.GetObject(b' idx + 1' ks);                          int pagenum = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          // add counts                          int unique = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          // FEATURE : add dup count                          PageList.Add(key' new PageInfo(pagenum' unique' 0));                      }                  }                  else                      throw new Exception("Page List header is invalid");                    return nextpage;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageListData,The following statement contains a magic number: lock (_fileLock)              {                  // load page list data                  int nextpage = -1;                  SeekPage(page);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      nextpage = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key = _T.GetObject(b' idx + 1' ks);                          int pagenum = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          // add counts                          int unique = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          // FEATURE : add dup count                          PageList.Add(key' new PageInfo(pagenum' unique' 0));                      }                  }                  else                      throw new Exception("Page List header is invalid");                    return nextpage;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageListData,The following statement contains a magic number: lock (_fileLock)              {                  // load page list data                  int nextpage = -1;                  SeekPage(page);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      nextpage = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key = _T.GetObject(b' idx + 1' ks);                          int pagenum = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          // add counts                          int unique = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          // FEATURE : add dup count                          PageList.Add(key' new PageInfo(pagenum' unique' 0));                      }                  }                  else                      throw new Exception("Page List header is invalid");                    return nextpage;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageListData,The following statement contains a magic number: lock (_fileLock)              {                  // load page list data                  int nextpage = -1;                  SeekPage(page);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      nextpage = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key = _T.GetObject(b' idx + 1' ks);                          int pagenum = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          // add counts                          int unique = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          // FEATURE : add dup count                          PageList.Add(key' new PageInfo(pagenum' unique' 0));                      }                  }                  else                      throw new Exception("Page List header is invalid");                    return nextpage;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageListData,The following statement contains a magic number: lock (_fileLock)              {                  // load page list data                  int nextpage = -1;                  SeekPage(page);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      nextpage = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key = _T.GetObject(b' idx + 1' ks);                          int pagenum = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          // add counts                          int unique = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          // FEATURE : add dup count                          PageList.Add(key' new PageInfo(pagenum' unique' 0));                      }                  }                  else                      throw new Exception("Page List header is invalid");                    return nextpage;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageListData,The following statement contains a magic number: lock (_fileLock)              {                  // load page list data                  int nextpage = -1;                  SeekPage(page);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      nextpage = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key = _T.GetObject(b' idx + 1' ks);                          int pagenum = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          // add counts                          int unique = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          // FEATURE : add dup count                          PageList.Add(key' new PageInfo(pagenum' unique' 0));                      }                  }                  else                      throw new Exception("Page List header is invalid");                    return nextpage;              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,SavePage,The following statement contains a magic number: lock (_fileLock)              {                  int pnum = node.DiskPageNumber;                  if (pnum > _LastPageNumber)                      throw new Exception("should not be here: page out of bounds");                    SeekPage(pnum);                  byte[] page = new byte[_PageLength];                  byte[] blockheader = CreateBlockHeader(0' (ushort)node.tree.Count' node.RightPageNumber);                  Buffer.BlockCopy(blockheader' 0' page' 0' blockheader.Length);                    int index = blockheader.Length;                  int i = 0;                  byte[] b = null;                  T[] keys = node.tree.Keys();                  Array.Sort(keys); // sort keys on save for read performance                  int blocknum = 0;                  if (_externalStrings)                  {                      // free old blocks                      if (node.allocblocks != null)                          _strings.FreeBlocks(node.allocblocks);                      blocknum = _strings.SaveData(node.DiskPageNumber.ToString()' fastBinaryJSON.BJSON.ToBJSON(keys));                  }                  // node children                  foreach (var kp in keys)                  {                      var val = node.tree[kp];                      int idx = index + _rowSize * i;                      // key bytes                      byte[] kk;                      byte size;                      if (_externalStrings == false)                      {                          kk = _T.GetBytes(kp);                          size = (byte)kk.Length;                          if (size > _maxKeySize)                              size = _maxKeySize;                      }                      else                      {                          kk = new byte[4];                          Buffer.BlockCopy(Helper.GetBytes(blocknum' false)' 0' kk' 0' 4);                          size = 4;                      }                      // key size = 1 byte                      page[idx] = size;                      Buffer.BlockCopy(kk' 0' page' idx + 1' page[idx]);                      // offset = 4 bytes                      b = Helper.GetBytes(val.RecordNumber' false);                      Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize' b.Length);                      // duplicatepage = 4 bytes                      b = Helper.GetBytes(val.DuplicateBitmapNumber' false);                      Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize + 4' b.Length);                      i++;                  }                  _file.Write(page' 0' page.Length);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,SavePage,The following statement contains a magic number: lock (_fileLock)              {                  int pnum = node.DiskPageNumber;                  if (pnum > _LastPageNumber)                      throw new Exception("should not be here: page out of bounds");                    SeekPage(pnum);                  byte[] page = new byte[_PageLength];                  byte[] blockheader = CreateBlockHeader(0' (ushort)node.tree.Count' node.RightPageNumber);                  Buffer.BlockCopy(blockheader' 0' page' 0' blockheader.Length);                    int index = blockheader.Length;                  int i = 0;                  byte[] b = null;                  T[] keys = node.tree.Keys();                  Array.Sort(keys); // sort keys on save for read performance                  int blocknum = 0;                  if (_externalStrings)                  {                      // free old blocks                      if (node.allocblocks != null)                          _strings.FreeBlocks(node.allocblocks);                      blocknum = _strings.SaveData(node.DiskPageNumber.ToString()' fastBinaryJSON.BJSON.ToBJSON(keys));                  }                  // node children                  foreach (var kp in keys)                  {                      var val = node.tree[kp];                      int idx = index + _rowSize * i;                      // key bytes                      byte[] kk;                      byte size;                      if (_externalStrings == false)                      {                          kk = _T.GetBytes(kp);                          size = (byte)kk.Length;                          if (size > _maxKeySize)                              size = _maxKeySize;                      }                      else                      {                          kk = new byte[4];                          Buffer.BlockCopy(Helper.GetBytes(blocknum' false)' 0' kk' 0' 4);                          size = 4;                      }                      // key size = 1 byte                      page[idx] = size;                      Buffer.BlockCopy(kk' 0' page' idx + 1' page[idx]);                      // offset = 4 bytes                      b = Helper.GetBytes(val.RecordNumber' false);                      Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize' b.Length);                      // duplicatepage = 4 bytes                      b = Helper.GetBytes(val.DuplicateBitmapNumber' false);                      Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize + 4' b.Length);                      i++;                  }                  _file.Write(page' 0' page.Length);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,SavePage,The following statement contains a magic number: lock (_fileLock)              {                  int pnum = node.DiskPageNumber;                  if (pnum > _LastPageNumber)                      throw new Exception("should not be here: page out of bounds");                    SeekPage(pnum);                  byte[] page = new byte[_PageLength];                  byte[] blockheader = CreateBlockHeader(0' (ushort)node.tree.Count' node.RightPageNumber);                  Buffer.BlockCopy(blockheader' 0' page' 0' blockheader.Length);                    int index = blockheader.Length;                  int i = 0;                  byte[] b = null;                  T[] keys = node.tree.Keys();                  Array.Sort(keys); // sort keys on save for read performance                  int blocknum = 0;                  if (_externalStrings)                  {                      // free old blocks                      if (node.allocblocks != null)                          _strings.FreeBlocks(node.allocblocks);                      blocknum = _strings.SaveData(node.DiskPageNumber.ToString()' fastBinaryJSON.BJSON.ToBJSON(keys));                  }                  // node children                  foreach (var kp in keys)                  {                      var val = node.tree[kp];                      int idx = index + _rowSize * i;                      // key bytes                      byte[] kk;                      byte size;                      if (_externalStrings == false)                      {                          kk = _T.GetBytes(kp);                          size = (byte)kk.Length;                          if (size > _maxKeySize)                              size = _maxKeySize;                      }                      else                      {                          kk = new byte[4];                          Buffer.BlockCopy(Helper.GetBytes(blocknum' false)' 0' kk' 0' 4);                          size = 4;                      }                      // key size = 1 byte                      page[idx] = size;                      Buffer.BlockCopy(kk' 0' page' idx + 1' page[idx]);                      // offset = 4 bytes                      b = Helper.GetBytes(val.RecordNumber' false);                      Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize' b.Length);                      // duplicatepage = 4 bytes                      b = Helper.GetBytes(val.DuplicateBitmapNumber' false);                      Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize + 4' b.Length);                      i++;                  }                  _file.Write(page' 0' page.Length);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,SavePage,The following statement contains a magic number: lock (_fileLock)              {                  int pnum = node.DiskPageNumber;                  if (pnum > _LastPageNumber)                      throw new Exception("should not be here: page out of bounds");                    SeekPage(pnum);                  byte[] page = new byte[_PageLength];                  byte[] blockheader = CreateBlockHeader(0' (ushort)node.tree.Count' node.RightPageNumber);                  Buffer.BlockCopy(blockheader' 0' page' 0' blockheader.Length);                    int index = blockheader.Length;                  int i = 0;                  byte[] b = null;                  T[] keys = node.tree.Keys();                  Array.Sort(keys); // sort keys on save for read performance                  int blocknum = 0;                  if (_externalStrings)                  {                      // free old blocks                      if (node.allocblocks != null)                          _strings.FreeBlocks(node.allocblocks);                      blocknum = _strings.SaveData(node.DiskPageNumber.ToString()' fastBinaryJSON.BJSON.ToBJSON(keys));                  }                  // node children                  foreach (var kp in keys)                  {                      var val = node.tree[kp];                      int idx = index + _rowSize * i;                      // key bytes                      byte[] kk;                      byte size;                      if (_externalStrings == false)                      {                          kk = _T.GetBytes(kp);                          size = (byte)kk.Length;                          if (size > _maxKeySize)                              size = _maxKeySize;                      }                      else                      {                          kk = new byte[4];                          Buffer.BlockCopy(Helper.GetBytes(blocknum' false)' 0' kk' 0' 4);                          size = 4;                      }                      // key size = 1 byte                      page[idx] = size;                      Buffer.BlockCopy(kk' 0' page' idx + 1' page[idx]);                      // offset = 4 bytes                      b = Helper.GetBytes(val.RecordNumber' false);                      Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize' b.Length);                      // duplicatepage = 4 bytes                      b = Helper.GetBytes(val.DuplicateBitmapNumber' false);                      Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize + 4' b.Length);                      i++;                  }                  _file.Write(page' 0' page.Length);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageFromPageNumber,The following statement contains a magic number: lock (_fileLock)              {                  SeekPage(number);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      // create node here                      Page<T> page = new Page<T>();                        short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      page.DiskPageNumber = number;                      page.RightPageNumber = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                      object[] keys = null;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key;                          if (_externalStrings == false)                              key = _T.GetObject(b' idx + 1' ks);                          else                          {                              if (keys == null)                              {                                  int blknum = Helper.ToInt32(b' idx + 1' false);                                  byte[] bb = _strings.GetData(blknum' page.allocblocks);                                  keys = (object[])fastBinaryJSON.BJSON.ToObject(bb);                              }                              key = (T)keys[i];                          }                          int offset = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          int duppage = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          page.tree.Add(key' new KeyInfo(offset' duppage));                      }                      return page;                  }                  else                      throw new Exception("Page read error header invalid' number = " + number);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageFromPageNumber,The following statement contains a magic number: lock (_fileLock)              {                  SeekPage(number);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      // create node here                      Page<T> page = new Page<T>();                        short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      page.DiskPageNumber = number;                      page.RightPageNumber = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                      object[] keys = null;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key;                          if (_externalStrings == false)                              key = _T.GetObject(b' idx + 1' ks);                          else                          {                              if (keys == null)                              {                                  int blknum = Helper.ToInt32(b' idx + 1' false);                                  byte[] bb = _strings.GetData(blknum' page.allocblocks);                                  keys = (object[])fastBinaryJSON.BJSON.ToObject(bb);                              }                              key = (T)keys[i];                          }                          int offset = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          int duppage = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          page.tree.Add(key' new KeyInfo(offset' duppage));                      }                      return page;                  }                  else                      throw new Exception("Page read error header invalid' number = " + number);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageFromPageNumber,The following statement contains a magic number: lock (_fileLock)              {                  SeekPage(number);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      // create node here                      Page<T> page = new Page<T>();                        short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      page.DiskPageNumber = number;                      page.RightPageNumber = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                      object[] keys = null;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key;                          if (_externalStrings == false)                              key = _T.GetObject(b' idx + 1' ks);                          else                          {                              if (keys == null)                              {                                  int blknum = Helper.ToInt32(b' idx + 1' false);                                  byte[] bb = _strings.GetData(blknum' page.allocblocks);                                  keys = (object[])fastBinaryJSON.BJSON.ToObject(bb);                              }                              key = (T)keys[i];                          }                          int offset = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          int duppage = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          page.tree.Add(key' new KeyInfo(offset' duppage));                      }                      return page;                  }                  else                      throw new Exception("Page read error header invalid' number = " + number);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageFromPageNumber,The following statement contains a magic number: lock (_fileLock)              {                  SeekPage(number);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      // create node here                      Page<T> page = new Page<T>();                        short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      page.DiskPageNumber = number;                      page.RightPageNumber = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                      object[] keys = null;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key;                          if (_externalStrings == false)                              key = _T.GetObject(b' idx + 1' ks);                          else                          {                              if (keys == null)                              {                                  int blknum = Helper.ToInt32(b' idx + 1' false);                                  byte[] bb = _strings.GetData(blknum' page.allocblocks);                                  keys = (object[])fastBinaryJSON.BJSON.ToObject(bb);                              }                              key = (T)keys[i];                          }                          int offset = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          int duppage = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          page.tree.Add(key' new KeyInfo(offset' duppage));                      }                      return page;                  }                  else                      throw new Exception("Page read error header invalid' number = " + number);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageFromPageNumber,The following statement contains a magic number: lock (_fileLock)              {                  SeekPage(number);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      // create node here                      Page<T> page = new Page<T>();                        short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      page.DiskPageNumber = number;                      page.RightPageNumber = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                      object[] keys = null;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key;                          if (_externalStrings == false)                              key = _T.GetObject(b' idx + 1' ks);                          else                          {                              if (keys == null)                              {                                  int blknum = Helper.ToInt32(b' idx + 1' false);                                  byte[] bb = _strings.GetData(blknum' page.allocblocks);                                  keys = (object[])fastBinaryJSON.BJSON.ToObject(bb);                              }                              key = (T)keys[i];                          }                          int offset = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          int duppage = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          page.tree.Add(key' new KeyInfo(offset' duppage));                      }                      return page;                  }                  else                      throw new Exception("Page read error header invalid' number = " + number);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageFromPageNumber,The following statement contains a magic number: lock (_fileLock)              {                  SeekPage(number);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      // create node here                      Page<T> page = new Page<T>();                        short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      page.DiskPageNumber = number;                      page.RightPageNumber = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                      object[] keys = null;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key;                          if (_externalStrings == false)                              key = _T.GetObject(b' idx + 1' ks);                          else                          {                              if (keys == null)                              {                                  int blknum = Helper.ToInt32(b' idx + 1' false);                                  byte[] bb = _strings.GetData(blknum' page.allocblocks);                                  keys = (object[])fastBinaryJSON.BJSON.ToObject(bb);                              }                              key = (T)keys[i];                          }                          int offset = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          int duppage = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          page.tree.Add(key' new KeyInfo(offset' duppage));                      }                      return page;                  }                  else                      throw new Exception("Page read error header invalid' number = " + number);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,LoadPageFromPageNumber,The following statement contains a magic number: lock (_fileLock)              {                  SeekPage(number);                  byte[] b = new byte[_PageLength];                  _file.Read(b' 0' _PageLength);                    if (b[0] == _BlockHeader[0] && b[1] == _BlockHeader[1] && b[2] == _BlockHeader[2] && b[3] == _BlockHeader[3])                  {                      // create node here                      Page<T> page = new Page<T>();                        short count = Helper.ToInt16(b' 5);                      if (count > _PageNodeCount)                          throw new Exception("Count > node size");                      page.DiskPageNumber = number;                      page.RightPageNumber = Helper.ToInt32(b' 11);                      int index = _BlockHeader.Length;                      object[] keys = null;                        for (int i = 0; i < count; i++)                      {                          int idx = index + _rowSize * i;                          byte ks = b[idx];                          T key;                          if (_externalStrings == false)                              key = _T.GetObject(b' idx + 1' ks);                          else                          {                              if (keys == null)                              {                                  int blknum = Helper.ToInt32(b' idx + 1' false);                                  byte[] bb = _strings.GetData(blknum' page.allocblocks);                                  keys = (object[])fastBinaryJSON.BJSON.ToObject(bb);                              }                              key = (T)keys[i];                          }                          int offset = Helper.ToInt32(b' idx + 1 + _maxKeySize);                          int duppage = Helper.ToInt32(b' idx + 1 + _maxKeySize + 4);                          page.tree.Add(key' new KeyInfo(offset' duppage));                      }                      return page;                  }                  else                      throw new Exception("Page read error header invalid' number = " + number);              }
Magic Number,RaptorDB,IndexFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\IndexFile.cs,CreatePageListData,The following statement contains a magic number: Buffer.BlockCopy(b' 0' page' idx + 1 + _maxKeySize + 4' b.Length);
Magic Number,RaptorDB,KeyStoreString,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStore.cs,Set,The following statement contains a magic number: ms.Write(Helper.GetBytes(bkey.Length' false)' 0' 4);
Magic Number,RaptorDB,KeyStoreString,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStore.cs,UnpackData,The following statement contains a magic number: Buffer.BlockCopy(buffer' 4' key' 0' len);
Magic Number,RaptorDB,KeyStoreString,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStore.cs,UnpackData,The following statement contains a magic number: val = new byte[buffer.Length - 4 - len];
Magic Number,RaptorDB,KeyStoreString,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStore.cs,UnpackData,The following statement contains a magic number: Buffer.BlockCopy(buffer' 4 + len' val' 0' buffer.Length - 4 - len);
Magic Number,RaptorDB,KeyStoreString,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStore.cs,UnpackData,The following statement contains a magic number: Buffer.BlockCopy(buffer' 4 + len' val' 0' buffer.Length - 4 - len);
Magic Number,RaptorDB,KeyStore<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStore.cs,Count,The following statement contains a magic number: return c - _deleted.GetBits().CountOnes() * 2;
Magic Number,RaptorDB,KeyStore<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStore.cs,Initialize,The following statement contains a magic number: _savetimer.Interval = Global.SaveIndexToDiskTimerSeconds * 1000;
Magic Number,RaptorDB,KeyStore<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStore.cs,CheckIndexState,The following statement contains a magic number: if (last < count)              {                  log.Debug("Rebuilding index...");                  log.Debug("   last index count = " + last);                  log.Debug("   data items count = " + count);                  // check last index record and archive record                  //       rebuild index if needed                  for (int i = last; i < count; i++)                  {                      bool deleted = false;                      T key = _archive.GetKey(i' out deleted);                      if (deleted == false)                          _index.Set(key' i);                      else                          _index.RemoveKey(key);                        if (i % 100000 == 0)                          log.Debug("100'000 items re-indexed");                  }                  log.Debug("Rebuild index done.");              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,KeyStoreHF,The following statement contains a magic number: _keys = new MGIndex<string>(_Path' "keys.idx"' 255' /*Global.PageItemCount'*/ false);
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,SetObjectHF,The following statement contains a magic number: if (k.Length > 255)              {                  _log.Error("Key length > 255 : " + key);                  throw new Exception("Key must be less than 255 characters");                  //return false;              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CompactStorageHF,The following statement contains a magic number: lock (_lock)              {                  try                  {                      _log.Debug("Compacting storage file ...");                      if (Directory.Exists(_Path + "temp"))                          Directory.Delete(_Path + "temp"' true);                        KeyStoreHF newfile = new KeyStoreHF(_Path + "temp");                      string[] keys = _keys.GetKeys().Cast<string>().ToArray();                      _log.Debug("Number of keys : " + keys.Length);                      foreach (var k in keys)                      {                          newfile.SetObjectHF(k' GetObjectHF(k));                      }                      newfile.Shutdown();                      _log.Debug("Compact done.");                      // shutdown and move files and restart here                      if (Directory.Exists(_Path + "old"))                          Directory.Delete(_Path + "old"' true);                      Directory.CreateDirectory(_Path + "old");                      _datastore.Shutdown();                      _keys.Shutdown();                      _log.Debug("Moving files...");                      foreach (var f in Directory.GetFiles(_Path' "*.*"))                          File.Move(f' _Path + "old" + _S + Path.GetFileName(f));                        foreach (var f in Directory.GetFiles(_Path + "temp"' "*.*"))                          File.Move(f' _Path + Path.GetFileName(f));                        Directory.Delete(_Path + "temp"' true);                      //Directory.Delete(_Path + "old"' true); // FEATURE : delete or keep?                      _log.Debug("Re-opening storage file");                      _datastore = new StorageFileHF(_Path + "data.mghf"' Global.HighFrequencyKVDiskBlockSize);                      _keys = new MGIndex<string>(_Path' "keys.idx"' 255' /*Global.PageItemCount'*/ false);                        _BlockSize = _datastore.GetBlockSize();                  }                  catch (Exception ex)                  {                      _log.Error(ex);                  }              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,internalSave,The following statement contains a magic number: while (datablockcount > 0)              {                  datablockcount--;                  int next = 0;                  if (datablockcount > 0)                      next = _datastore.GetFreeBlockNumber();                    Buffer.BlockCopy(Helper.GetBytes(counter' false)' 0' header' 0' 4);    // set block number                  Buffer.BlockCopy(Helper.GetBytes(next' false)' 0' header' 4' 4); // set next pointer                    _datastore.SeekBlock(blocknum);                  _datastore.WriteBlockBytes(header' 0' header.Length);                  int c = len;                  if (c > dblocksize)                      c = dblocksize;                  _datastore.WriteBlockBytes(data' offset' c);                    if (next > 0)                      blocknum = next;                  offset += c;                  len -= c;                  counter++;              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,internalSave,The following statement contains a magic number: while (datablockcount > 0)              {                  datablockcount--;                  int next = 0;                  if (datablockcount > 0)                      next = _datastore.GetFreeBlockNumber();                    Buffer.BlockCopy(Helper.GetBytes(counter' false)' 0' header' 0' 4);    // set block number                  Buffer.BlockCopy(Helper.GetBytes(next' false)' 0' header' 4' 4); // set next pointer                    _datastore.SeekBlock(blocknum);                  _datastore.WriteBlockBytes(header' 0' header.Length);                  int c = len;                  if (c > dblocksize)                      c = dblocksize;                  _datastore.WriteBlockBytes(data' offset' c);                    if (next > 0)                      blocknum = next;                  offset += c;                  len -= c;                  counter++;              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,internalSave,The following statement contains a magic number: while (datablockcount > 0)              {                  datablockcount--;                  int next = 0;                  if (datablockcount > 0)                      next = _datastore.GetFreeBlockNumber();                    Buffer.BlockCopy(Helper.GetBytes(counter' false)' 0' header' 0' 4);    // set block number                  Buffer.BlockCopy(Helper.GetBytes(next' false)' 0' header' 4' 4); // set next pointer                    _datastore.SeekBlock(blocknum);                  _datastore.WriteBlockBytes(header' 0' header.Length);                  int c = len;                  if (c > dblocksize)                      c = dblocksize;                  _datastore.WriteBlockBytes(data' offset' c);                    if (next > 0)                      blocknum = next;                  offset += c;                  len -= c;                  counter++;              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: if (ab.isCompressed)                  alloc[8] = 1;
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: if (ab.isBinaryJSON)                  alloc[8] += 2;
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: if (ab.isBinaryJSON)                  alloc[8] += 2;
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: if (ab.deleteKey)                  alloc[8] += 4;
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: if (ab.deleteKey)                  alloc[8] += 4;
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: Buffer.BlockCopy(Helper.GetBytes(ab.datalength' false)' 0' alloc' 9' 4);
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: Buffer.BlockCopy(Helper.GetBytes(ab.datalength' false)' 0' alloc' 9' 4);
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: alloc[13] = ab.keylen;
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,CreateAllocHeader,The following statement contains a magic number: alloc[14] = 1;
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,FillAllocationBlock,The following statement contains a magic number: byte[] b = _datastore.ReadBlockBytes(blocknumber' _blockheader.Length + 255);
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,ParseBlockHeader,The following statement contains a magic number: if (b[14] != 1)              {                  _log.Error("Expecting string keys only' got : " + b[14]);                  //throw new Exception("Expecting string keys only' got : " + b[11]);                  return -1;              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,ParseBlockHeader,The following statement contains a magic number: if (b[14] != 1)              {                  _log.Error("Expecting string keys only' got : " + b[14]);                  //throw new Exception("Expecting string keys only' got : " + b[11]);                  return -1;              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,ParseBlockHeader,The following statement contains a magic number: int next = Helper.ToInt32(b' 4);
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,ParseBlockHeader,The following statement contains a magic number: if (ab.keylen == 0)              {                  byte flags = b[8];                    if ((flags & 0x01) > 0)                      ab.isCompressed = true;                  if ((flags & 0x02) > 0)                      ab.isBinaryJSON = true;                  if ((flags & 0x04) > 0)                      ab.deleteKey = true;                    ab.datalength = Helper.ToInt32(b' 9);                  byte keylen = b[13];                  ab.keylen = keylen;                  ab.key = Helper.GetString(b' _blockheader.Length' keylen);              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,ParseBlockHeader,The following statement contains a magic number: if (ab.keylen == 0)              {                  byte flags = b[8];                    if ((flags & 0x01) > 0)                      ab.isCompressed = true;                  if ((flags & 0x02) > 0)                      ab.isBinaryJSON = true;                  if ((flags & 0x04) > 0)                      ab.deleteKey = true;                    ab.datalength = Helper.ToInt32(b' 9);                  byte keylen = b[13];                  ab.keylen = keylen;                  ab.key = Helper.GetString(b' _blockheader.Length' keylen);              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,ParseBlockHeader,The following statement contains a magic number: if (ab.keylen == 0)              {                  byte flags = b[8];                    if ((flags & 0x01) > 0)                      ab.isCompressed = true;                  if ((flags & 0x02) > 0)                      ab.isBinaryJSON = true;                  if ((flags & 0x04) > 0)                      ab.deleteKey = true;                    ab.datalength = Helper.ToInt32(b' 9);                  byte keylen = b[13];                  ab.keylen = keylen;                  ab.key = Helper.GetString(b' _blockheader.Length' keylen);              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,RebuildDataFiles,The following statement contains a magic number: try              {                  // remove old free list                  if (File.Exists(_Path + "data.bmp"))                      File.Delete(_Path + "data.bmp");                    _datastore = new StorageFileHF(_Path + "data.mghf"' Global.HighFrequencyKVDiskBlockSize);                  _BlockSize = _datastore.GetBlockSize();                  if (File.Exists(_Path + "keys.idx"))                  {                      _log.Debug("removing old keys index");                      foreach (var f in Directory.GetFiles(_Path' "keys.*"))                          File.Delete(f);                  }                    keys = new MGIndex<string>(_Path' "keys.idx"' 255' /*Global.PageItemCount'*/ false);                    WAHBitArray visited = new WAHBitArray();                    int c = _datastore.NumberofBlocks();                    for (int i = 0; i < c; i++) // go through blocks                  {                      if (visited.Get(i))                          continue;                      byte[] b = _datastore.ReadBlockBytes(i' _blockheader.Length + 255);                      int bnum = Helper.ToInt32(b' 0);                      if (bnum > 0) // check if a start block                      {                          visited.Set(i' true);                          _datastore.FreeBlock(i); // mark as free                          continue;                      }                        AllocationBlock ab = new AllocationBlock();                      // start block found                      int blocknumexpected = 0;                        int next = ParseBlockHeader(ab' b' blocknumexpected);                      int last = 0;                      bool freelast = false;                      AllocationBlock old = null;                        if (keys.Get(ab.key' out last))                      {                          old = this.FillAllocationBlock(last);                          freelast = true;                      }                      blocknumexpected++;                      bool failed = false;                      if (ab.deleteKey == false)                      {                          while (next > 0) // read the blocks                          {                              ab.Blocks.Add(next);                              b = _datastore.ReadBlockBytes(next' _blockheader.Length + ab.keylen);                              next = ParseBlockHeader(ab' b' blocknumexpected);                              if (next == -1) // non matching block                              {                                  failed = true;                                  break;                              }                              blocknumexpected++;                          }                      }                      else                      {                          failed = true;                          keys.RemoveKey(ab.key);                      }                      // new data ok                      if (failed == false)                      {                          keys.Set(ab.key' ab.blocknumber);// valid block found                          if (freelast)// free the old blocks                              _datastore.FreeBlocks(old.Blocks);                      }                        visited.Set(i' true);                  }                    // all ok delete temp.$ file                  if (File.Exists(_Path + _dirtyFilename))                      File.Delete(_Path + _dirtyFilename);              }              catch (Exception ex)              {                  _log.Error(ex);              }              finally              {                  _log.Debug("Shutting down files and index");                  _datastore.Shutdown();                  keys.SaveIndex();                  keys.Shutdown();              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,RebuildDataFiles,The following statement contains a magic number: try              {                  // remove old free list                  if (File.Exists(_Path + "data.bmp"))                      File.Delete(_Path + "data.bmp");                    _datastore = new StorageFileHF(_Path + "data.mghf"' Global.HighFrequencyKVDiskBlockSize);                  _BlockSize = _datastore.GetBlockSize();                  if (File.Exists(_Path + "keys.idx"))                  {                      _log.Debug("removing old keys index");                      foreach (var f in Directory.GetFiles(_Path' "keys.*"))                          File.Delete(f);                  }                    keys = new MGIndex<string>(_Path' "keys.idx"' 255' /*Global.PageItemCount'*/ false);                    WAHBitArray visited = new WAHBitArray();                    int c = _datastore.NumberofBlocks();                    for (int i = 0; i < c; i++) // go through blocks                  {                      if (visited.Get(i))                          continue;                      byte[] b = _datastore.ReadBlockBytes(i' _blockheader.Length + 255);                      int bnum = Helper.ToInt32(b' 0);                      if (bnum > 0) // check if a start block                      {                          visited.Set(i' true);                          _datastore.FreeBlock(i); // mark as free                          continue;                      }                        AllocationBlock ab = new AllocationBlock();                      // start block found                      int blocknumexpected = 0;                        int next = ParseBlockHeader(ab' b' blocknumexpected);                      int last = 0;                      bool freelast = false;                      AllocationBlock old = null;                        if (keys.Get(ab.key' out last))                      {                          old = this.FillAllocationBlock(last);                          freelast = true;                      }                      blocknumexpected++;                      bool failed = false;                      if (ab.deleteKey == false)                      {                          while (next > 0) // read the blocks                          {                              ab.Blocks.Add(next);                              b = _datastore.ReadBlockBytes(next' _blockheader.Length + ab.keylen);                              next = ParseBlockHeader(ab' b' blocknumexpected);                              if (next == -1) // non matching block                              {                                  failed = true;                                  break;                              }                              blocknumexpected++;                          }                      }                      else                      {                          failed = true;                          keys.RemoveKey(ab.key);                      }                      // new data ok                      if (failed == false)                      {                          keys.Set(ab.key' ab.blocknumber);// valid block found                          if (freelast)// free the old blocks                              _datastore.FreeBlocks(old.Blocks);                      }                        visited.Set(i' true);                  }                    // all ok delete temp.$ file                  if (File.Exists(_Path + _dirtyFilename))                      File.Delete(_Path + _dirtyFilename);              }              catch (Exception ex)              {                  _log.Error(ex);              }              finally              {                  _log.Debug("Shutting down files and index");                  _datastore.Shutdown();                  keys.SaveIndex();                  keys.Shutdown();              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,Increment,The following statement contains a magic number: if (k.Length > 255)              {                  _log.Error("Key length > 255 : " + key);                  throw new Exception("Key must be less than 255 characters");                  //return false;              }
Magic Number,RaptorDB,KeyStoreHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\KeyStoreHF.cs,Increment,The following statement contains a magic number: if (k.Length > 255)              {                  _log.Error("Key length > 255 : " + key);                  throw new Exception("Key must be less than 255 characters");                  //return false;              }
Magic Number,RaptorDB,MGIndex<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\MGIndex.cs,SplitPage,The following statement contains a magic number: for (int i = keys.Length / 2; i < keys.Length; i++)              {                  newpage.tree.Add(keys[i]' page.tree[keys[i]]);                  // remove from old page                  page.tree.Remove(keys[i]);              }
Magic Number,RaptorDB,MGIndex<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\MGIndex.cs,SplitPage,The following statement contains a magic number: newpage.FirstKey = keys[keys.Length / 2];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,MiniLZO,The following statement contains a magic number: if (IntPtr.Size == 8)                  DICT_SIZE = (65536 + 3) * 2;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,MiniLZO,The following statement contains a magic number: if (IntPtr.Size == 8)                  DICT_SIZE = (65536 + 3) * 2;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,MiniLZO,The following statement contains a magic number: if (IntPtr.Size == 8)                  DICT_SIZE = (65536 + 3) * 2;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,MiniLZO,The following statement contains a magic number: if (IntPtr.Size == 8)                  DICT_SIZE = (65536 + 3) * 2;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: uint dstlen = (uint)(srcLength + (srcLength / 16) + 64 + 3 + 4);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: uint dstlen = (uint)(srcLength + (srcLength / 16) + 64 + 3 + 4);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: uint dstlen = (uint)(srcLength + (srcLength / 16) + 64 + 3 + 4);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: uint dstlen = (uint)(srcLength + (srcLength / 16) + 64 + 3 + 4);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: destinationLength = sourceLength + (sourceLength / 16) + 64 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: destinationLength = sourceLength + (sourceLength / 16) + 64 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: destinationLength = sourceLength + (sourceLength / 16) + 64 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: destinationLength = sourceLength + (sourceLength / 16) + 64 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: uint inplaceOverhead = Math.Min(sourceLength' M4_MAX_OFFSET) + sourceLength / 64 + 16 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: uint inplaceOverhead = Math.Min(sourceLength' M4_MAX_OFFSET) + sourceLength / 64 + 16 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: uint inplaceOverhead = Math.Min(sourceLength' M4_MAX_OFFSET) + sourceLength / 64 + 16 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: uint inplaceOverhead = Math.Min(sourceLength' M4_MAX_OFFSET) + sourceLength / 64 + 16 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: dst[dstlen++] = (byte)(srcLength >> 8);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: dst[dstlen++] = (byte)(srcLength >> 16);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Compress,The following statement contains a magic number: dst[dstlen++] = (byte)(srcLength >> 24);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,D_INDEX1,The following statement contains a magic number: return D_MS(D_MUL(0x21' D_X3(input' 5' 5' 6)) >> 5' 0);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,D_INDEX1,The following statement contains a magic number: return D_MS(D_MUL(0x21' D_X3(input' 5' 5' 6)) >> 5' 0);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,D_INDEX1,The following statement contains a magic number: return D_MS(D_MUL(0x21' D_X3(input' 5' 5' 6)) >> 5' 0);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,D_INDEX1,The following statement contains a magic number: return D_MS(D_MUL(0x21' D_X3(input' 5' 5' 6)) >> 5' 0);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_hOOt\Hoot\MGIndex\MiniLZO.cs,D_X2,The following statement contains a magic number: return (uint)((((input[2] << s2) ^ input[1]) << s1) ^ input[0]);
Magic Number,RaptorDB,MurmurHash2Unsafe,C:\repos\mgholam_hOOt\Hoot\MGIndex\MurMurHash2.cs,Hash,The following statement contains a magic number: Int32 remainingBytes = length & 3;
Magic Number,RaptorDB,MurmurHash2Unsafe,C:\repos\mgholam_hOOt\Hoot\MGIndex\MurMurHash2.cs,Hash,The following statement contains a magic number: Int32 numberOfLoops = length >> 2;
Magic Number,RaptorDB,MurmurHash2Unsafe,C:\repos\mgholam_hOOt\Hoot\MGIndex\MurMurHash2.cs,Hash,The following statement contains a magic number: fixed (byte* firstByte = &(data[0]))              {                  UInt32* realData = (UInt32*)firstByte;                  while (numberOfLoops != 0)                  {                      UInt32 k = *realData;                      k *= m;                      k ^= k >> r;                      k *= m;                        h *= m;                      h ^= k;                      numberOfLoops--;                      realData++;                  }                  switch (remainingBytes)                  {                      case 3:                          h ^= (UInt16)(*realData);                          h ^= ((UInt32)(*(((Byte*)(realData)) + 2))) << 16;                          h *= m;                          break;                      case 2:                          h ^= (UInt16)(*realData);                          h *= m;                          break;                      case 1:                          h ^= *((Byte*)realData);                          h *= m;                          break;                      default:                          break;                  }              }
Magic Number,RaptorDB,MurmurHash2Unsafe,C:\repos\mgholam_hOOt\Hoot\MGIndex\MurMurHash2.cs,Hash,The following statement contains a magic number: fixed (byte* firstByte = &(data[0]))              {                  UInt32* realData = (UInt32*)firstByte;                  while (numberOfLoops != 0)                  {                      UInt32 k = *realData;                      k *= m;                      k ^= k >> r;                      k *= m;                        h *= m;                      h ^= k;                      numberOfLoops--;                      realData++;                  }                  switch (remainingBytes)                  {                      case 3:                          h ^= (UInt16)(*realData);                          h ^= ((UInt32)(*(((Byte*)(realData)) + 2))) << 16;                          h *= m;                          break;                      case 2:                          h ^= (UInt16)(*realData);                          h *= m;                          break;                      case 1:                          h ^= *((Byte*)realData);                          h *= m;                          break;                      default:                          break;                  }              }
Magic Number,RaptorDB,MurmurHash2Unsafe,C:\repos\mgholam_hOOt\Hoot\MGIndex\MurMurHash2.cs,Hash,The following statement contains a magic number: fixed (byte* firstByte = &(data[0]))              {                  UInt32* realData = (UInt32*)firstByte;                  while (numberOfLoops != 0)                  {                      UInt32 k = *realData;                      k *= m;                      k ^= k >> r;                      k *= m;                        h *= m;                      h ^= k;                      numberOfLoops--;                      realData++;                  }                  switch (remainingBytes)                  {                      case 3:                          h ^= (UInt16)(*realData);                          h ^= ((UInt32)(*(((Byte*)(realData)) + 2))) << 16;                          h *= m;                          break;                      case 2:                          h ^= (UInt16)(*realData);                          h *= m;                          break;                      case 1:                          h ^= *((Byte*)realData);                          h *= m;                          break;                      default:                          break;                  }              }
Magic Number,RaptorDB,MurmurHash2Unsafe,C:\repos\mgholam_hOOt\Hoot\MGIndex\MurMurHash2.cs,Hash,The following statement contains a magic number: fixed (byte* firstByte = &(data[0]))              {                  UInt32* realData = (UInt32*)firstByte;                  while (numberOfLoops != 0)                  {                      UInt32 k = *realData;                      k *= m;                      k ^= k >> r;                      k *= m;                        h *= m;                      h ^= k;                      numberOfLoops--;                      realData++;                  }                  switch (remainingBytes)                  {                      case 3:                          h ^= (UInt16)(*realData);                          h ^= ((UInt32)(*(((Byte*)(realData)) + 2))) << 16;                          h *= m;                          break;                      case 2:                          h ^= (UInt16)(*realData);                          h *= m;                          break;                      case 1:                          h ^= *((Byte*)realData);                          h *= m;                          break;                      default:                          break;                  }              }
Magic Number,RaptorDB,MurmurHash2Unsafe,C:\repos\mgholam_hOOt\Hoot\MGIndex\MurMurHash2.cs,Hash,The following statement contains a magic number: h ^= h >> 13;
Magic Number,RaptorDB,MurmurHash2Unsafe,C:\repos\mgholam_hOOt\Hoot\MGIndex\MurMurHash2.cs,Hash,The following statement contains a magic number: h ^= h >> 15;
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,ReadFreeListBMPFile,The following statement contains a magic number: if (b.Length % 4 > 0) // new format with the data type byte              {                  t = (WAHBitArray.TYPE)Enum.ToObject(typeof(WAHBitArray.TYPE)' b[0]);                  j = 1;              }
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,ReadFreeListBMPFile,The following statement contains a magic number: for (int i = 0; i < b.Length / 4; i++)              {                  ints.Add((uint)Helper.ToInt32(b' (i * 4) + j));              }
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,ReadFreeListBMPFile,The following statement contains a magic number: for (int i = 0; i < b.Length / 4; i++)              {                  ints.Add((uint)Helper.ToInt32(b' (i * 4) + j));              }
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,ReadFileHeader,The following statement contains a magic number: _BLOCKSIZE = (ushort)((int)hdr[5] + ((int)hdr[6]) << 8);
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,ReadFileHeader,The following statement contains a magic number: _BLOCKSIZE = (ushort)((int)hdr[5] + ((int)hdr[6]) << 8);
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,ReadFileHeader,The following statement contains a magic number: _BLOCKSIZE = (ushort)((int)hdr[5] + ((int)hdr[6]) << 8);
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,CreateFileHeader,The following statement contains a magic number: _fileheader[4] = (byte)_CurrentVersion;
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,CreateFileHeader,The following statement contains a magic number: _fileheader[5] = (byte)(blocksize & 0xff);
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,CreateFileHeader,The following statement contains a magic number: _fileheader[6] = (byte)(blocksize >> 8);
Magic Number,RaptorDB,StorageFileHF,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFileHF.cs,CreateFileHeader,The following statement contains a magic number: _fileheader[6] = (byte)(blocksize >> 8);
Magic Number,RaptorDB,FileLogger,C:\repos\mgholam_hOOt\Hoot\mylogger.cs,Init,The following statement contains a magic number: _saveTimer = new System.Timers.Timer(500);
Magic Number,RaptorDB,FileLogger,C:\repos\mgholam_hOOt\Hoot\mylogger.cs,WriteData,The following statement contains a magic number: lock (_que)              {                  while (_que.Count > 0)                  {                      object o = _que.Dequeue();                      if (_output != null && o != null)                      {                          if (_sizeLimit > 0)                          {                              // implement size limited logs                              // implement rolling logs                              #region [  rolling size limit ]                              _lastSize += ("" + o).Length;                              if (_lastSize > _sizeLimit * 1000)                              {                                  _output.Flush();                                  _output.Close();                                  int count = 1;                                  while (File.Exists(_FilePath + Path.GetFileNameWithoutExtension(_filename) + "." + count.ToString("0000")))                                      count++;                                    File.Move(_filename'                                      _FilePath +                                      Path.GetFileNameWithoutExtension(_filename) +                                      "." + count.ToString("0000"));                                  _output = new StreamWriter(_filename' true);                                  _lastSize = 0;                              }                              #endregion                          }                          if (DateTime.Now.Subtract(_lastFileDate).Days > 0)                          {                              // implement date logs                              #region [  rolling dates  ]                              _output.Flush();                              _output.Close();                              int count = 1;                              while (File.Exists(_FilePath + Path.GetFileNameWithoutExtension(_filename) + "." + count.ToString("0000")))                              {                                  File.Move(_FilePath + Path.GetFileNameWithoutExtension(_filename) + "." + count.ToString("0000")'                                     _FilePath +                                     Path.GetFileNameWithoutExtension(_filename) +                                     "." + count.ToString("0000") +                                     "." + _lastFileDate.ToString("yyyy-MM-dd"));                                  count++;                              }                              File.Move(_filename'                                 _FilePath +                                 Path.GetFileNameWithoutExtension(_filename) +                                 "." + count.ToString("0000") +                                 "." + _lastFileDate.ToString("yyyy-MM-dd"));                                _output = new StreamWriter(_filename' true);                              _lastFileDate = DateTime.Now;                              _lastSize = 0;                              #endregion                          }                          _output.Write(o);                      }                  }                  if (_output != null)                      _output.Flush();              }
Magic Number,RaptorDB,logger,C:\repos\mgholam_hOOt\Hoot\mylogger.cs,log,The following statement contains a magic number: if (FileLogger.Instance.ShowMethodNames)              {                  System.Diagnostics.StackTrace st = new System.Diagnostics.StackTrace(2);                  System.Diagnostics.StackFrame sf = st.GetFrame(0);                  meth = sf.GetMethod().Name;              }
Magic Number,RaptorDB,logger,C:\repos\mgholam_hOOt\Hoot\mylogger.cs,Error,The following statement contains a magic number: if (FileLogger.Instance._logabove <= 4)                  log("ERROR"' "" + msg' objs);
Magic Number,RaptorDB,logger,C:\repos\mgholam_hOOt\Hoot\mylogger.cs,Warn,The following statement contains a magic number: if (FileLogger.Instance._logabove <= 3)                  log("WARN"' "" + msg' objs);
Magic Number,RaptorDB,logger,C:\repos\mgholam_hOOt\Hoot\mylogger.cs,Debug,The following statement contains a magic number: if (FileLogger.Instance._logabove <= 2)                  log("DEBUG"' "" + msg' objs);
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,StorageFile,The following statement contains a magic number: _fileheader[5] = (byte)_CurrentVersion;
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,StorageFile,The following statement contains a magic number: _fileheader[5] = (byte)_CurrentVersion;
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,Initialize,The following statement contains a magic number: if (StorageOnlyMode == false)              {                  // load rec pointers                  _recfilename = filename.Substring(0' filename.LastIndexOf('.')) + ".mgrec";                  if (File.Exists(_recfilename) == false)                      _recfilewrite = new FileStream(_recfilename' FileMode.CreateNew' FileAccess.Write' FileShare.ReadWrite);                  else                      _recfilewrite = new FileStream(_recfilename' FileMode.Open' FileAccess.Write' FileShare.ReadWrite);                    _recfileread = new FileStream(_recfilename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                    _lastRecordNum = (int)(_recfilewrite.Length / 8);                  _recfilewrite.Seek(0L' SeekOrigin.End);              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,GetStorageFileHeaderVersion,The following statement contains a magic number: if (File.Exists(fn))              {                  var fs = new FileStream(fn' FileMode.Open' FileAccess.ReadWrite' FileShare.ReadWrite);                  fs.Seek(0L' SeekOrigin.Begin);                  byte[] b = new byte[_fileheader.Length];                  fs.Read(b' 0' _fileheader.Length);                  fs.Close();                  return b[5];              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ReadObject,The following statement contains a magic number: if (b[0] < 32)                  return fastBinaryJSON.BJSON.ToObject(b);              else                  return fastJSON.JSON.ToObject(Encoding.ASCII.GetString(b));
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ViewReadRawBytes,The following statement contains a magic number: lock (_readlock)              {                  long offset = ComputeOffset(recnum);                  _dataread.Seek(offset' System.IO.SeekOrigin.Begin);                  byte[] hdr = new byte[5];                  // read header                  _dataread.Read(hdr' 0' 5); // meta length                  int len = Helper.ToInt32(hdr' 1);                    int type = hdr[0];                  if (type == 0)                  {                      byte[] data = new byte[len];                      _dataread.Read(data' 0' len);                      return data;                  }                  return null;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ViewReadRawBytes,The following statement contains a magic number: lock (_readlock)              {                  long offset = ComputeOffset(recnum);                  _dataread.Seek(offset' System.IO.SeekOrigin.Begin);                  byte[] hdr = new byte[5];                  // read header                  _dataread.Read(hdr' 0' 5); // meta length                  int len = Helper.ToInt32(hdr' 1);                    int type = hdr[0];                  if (type == 0)                  {                      byte[] data = new byte[len];                      _dataread.Read(data' 0' len);                      return data;                  }                  return null;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,internalWriteData,The following statement contains a magic number: lock (_readlock)              {                  _dirty = true;                  // seek end of file                  long offset = _lastWriteOffset;                  if (_viewmode == false && Global.SplitStorageFilesMegaBytes > 0)                  {                      // current file size > _splitMegaBytes --> new file                      if (offset > (long)Global.SplitStorageFilesMegaBytes * 1024 * 1024)                          CreateNewStorageFile();                  }                    if (raw == false)                  {                      if (data != null)                          meta.dataLength = data.Length;                      byte[] metabytes = fastBinaryJSON.BJSON.ToBJSON(meta' new fastBinaryJSON.BJSONParameters { UseExtensions = false });                        // write header info                      _datawrite.Write(new byte[] { 1 }' 0' 1); // FEATURE : add json here' write bson for now                      _datawrite.Write(Helper.GetBytes(metabytes.Length' false)' 0' 4);                      _datawrite.Write(metabytes' 0' metabytes.Length);                      // update pointer                      _lastWriteOffset += metabytes.Length + 5;                  }                  else                  {                      // write header info                      _datawrite.Write(new byte[] { 0 }' 0' 1); // write raw                      _datawrite.Write(Helper.GetBytes(data.Length' false)' 0' 4);                      // update pointer                      _lastWriteOffset += 5;                  }                    if (data != null)                  {                      // write data block                      _datawrite.Write(data' 0' data.Length);                      _lastWriteOffset += data.Length;                  }                  // return starting offset -> recno                  long recno = _lastRecordNum++;                  if (_recfilewrite != null)                      _recfilewrite.Write(Helper.GetBytes(offset' false)' 0' 8);                  if (Global.FlushStorageFileImmediately)                  {                      _datawrite.Flush();                      if (_recfilewrite != null)                          _recfilewrite.Flush();                  }                  return recno;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,internalWriteData,The following statement contains a magic number: lock (_readlock)              {                  _dirty = true;                  // seek end of file                  long offset = _lastWriteOffset;                  if (_viewmode == false && Global.SplitStorageFilesMegaBytes > 0)                  {                      // current file size > _splitMegaBytes --> new file                      if (offset > (long)Global.SplitStorageFilesMegaBytes * 1024 * 1024)                          CreateNewStorageFile();                  }                    if (raw == false)                  {                      if (data != null)                          meta.dataLength = data.Length;                      byte[] metabytes = fastBinaryJSON.BJSON.ToBJSON(meta' new fastBinaryJSON.BJSONParameters { UseExtensions = false });                        // write header info                      _datawrite.Write(new byte[] { 1 }' 0' 1); // FEATURE : add json here' write bson for now                      _datawrite.Write(Helper.GetBytes(metabytes.Length' false)' 0' 4);                      _datawrite.Write(metabytes' 0' metabytes.Length);                      // update pointer                      _lastWriteOffset += metabytes.Length + 5;                  }                  else                  {                      // write header info                      _datawrite.Write(new byte[] { 0 }' 0' 1); // write raw                      _datawrite.Write(Helper.GetBytes(data.Length' false)' 0' 4);                      // update pointer                      _lastWriteOffset += 5;                  }                    if (data != null)                  {                      // write data block                      _datawrite.Write(data' 0' data.Length);                      _lastWriteOffset += data.Length;                  }                  // return starting offset -> recno                  long recno = _lastRecordNum++;                  if (_recfilewrite != null)                      _recfilewrite.Write(Helper.GetBytes(offset' false)' 0' 8);                  if (Global.FlushStorageFileImmediately)                  {                      _datawrite.Flush();                      if (_recfilewrite != null)                          _recfilewrite.Flush();                  }                  return recno;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,internalWriteData,The following statement contains a magic number: lock (_readlock)              {                  _dirty = true;                  // seek end of file                  long offset = _lastWriteOffset;                  if (_viewmode == false && Global.SplitStorageFilesMegaBytes > 0)                  {                      // current file size > _splitMegaBytes --> new file                      if (offset > (long)Global.SplitStorageFilesMegaBytes * 1024 * 1024)                          CreateNewStorageFile();                  }                    if (raw == false)                  {                      if (data != null)                          meta.dataLength = data.Length;                      byte[] metabytes = fastBinaryJSON.BJSON.ToBJSON(meta' new fastBinaryJSON.BJSONParameters { UseExtensions = false });                        // write header info                      _datawrite.Write(new byte[] { 1 }' 0' 1); // FEATURE : add json here' write bson for now                      _datawrite.Write(Helper.GetBytes(metabytes.Length' false)' 0' 4);                      _datawrite.Write(metabytes' 0' metabytes.Length);                      // update pointer                      _lastWriteOffset += metabytes.Length + 5;                  }                  else                  {                      // write header info                      _datawrite.Write(new byte[] { 0 }' 0' 1); // write raw                      _datawrite.Write(Helper.GetBytes(data.Length' false)' 0' 4);                      // update pointer                      _lastWriteOffset += 5;                  }                    if (data != null)                  {                      // write data block                      _datawrite.Write(data' 0' data.Length);                      _lastWriteOffset += data.Length;                  }                  // return starting offset -> recno                  long recno = _lastRecordNum++;                  if (_recfilewrite != null)                      _recfilewrite.Write(Helper.GetBytes(offset' false)' 0' 8);                  if (Global.FlushStorageFileImmediately)                  {                      _datawrite.Flush();                      if (_recfilewrite != null)                          _recfilewrite.Flush();                  }                  return recno;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,internalWriteData,The following statement contains a magic number: lock (_readlock)              {                  _dirty = true;                  // seek end of file                  long offset = _lastWriteOffset;                  if (_viewmode == false && Global.SplitStorageFilesMegaBytes > 0)                  {                      // current file size > _splitMegaBytes --> new file                      if (offset > (long)Global.SplitStorageFilesMegaBytes * 1024 * 1024)                          CreateNewStorageFile();                  }                    if (raw == false)                  {                      if (data != null)                          meta.dataLength = data.Length;                      byte[] metabytes = fastBinaryJSON.BJSON.ToBJSON(meta' new fastBinaryJSON.BJSONParameters { UseExtensions = false });                        // write header info                      _datawrite.Write(new byte[] { 1 }' 0' 1); // FEATURE : add json here' write bson for now                      _datawrite.Write(Helper.GetBytes(metabytes.Length' false)' 0' 4);                      _datawrite.Write(metabytes' 0' metabytes.Length);                      // update pointer                      _lastWriteOffset += metabytes.Length + 5;                  }                  else                  {                      // write header info                      _datawrite.Write(new byte[] { 0 }' 0' 1); // write raw                      _datawrite.Write(Helper.GetBytes(data.Length' false)' 0' 4);                      // update pointer                      _lastWriteOffset += 5;                  }                    if (data != null)                  {                      // write data block                      _datawrite.Write(data' 0' data.Length);                      _lastWriteOffset += data.Length;                  }                  // return starting offset -> recno                  long recno = _lastRecordNum++;                  if (_recfilewrite != null)                      _recfilewrite.Write(Helper.GetBytes(offset' false)' 0' 8);                  if (Global.FlushStorageFileImmediately)                  {                      _datawrite.Flush();                      if (_recfilewrite != null)                          _recfilewrite.Flush();                  }                  return recno;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,internalWriteData,The following statement contains a magic number: lock (_readlock)              {                  _dirty = true;                  // seek end of file                  long offset = _lastWriteOffset;                  if (_viewmode == false && Global.SplitStorageFilesMegaBytes > 0)                  {                      // current file size > _splitMegaBytes --> new file                      if (offset > (long)Global.SplitStorageFilesMegaBytes * 1024 * 1024)                          CreateNewStorageFile();                  }                    if (raw == false)                  {                      if (data != null)                          meta.dataLength = data.Length;                      byte[] metabytes = fastBinaryJSON.BJSON.ToBJSON(meta' new fastBinaryJSON.BJSONParameters { UseExtensions = false });                        // write header info                      _datawrite.Write(new byte[] { 1 }' 0' 1); // FEATURE : add json here' write bson for now                      _datawrite.Write(Helper.GetBytes(metabytes.Length' false)' 0' 4);                      _datawrite.Write(metabytes' 0' metabytes.Length);                      // update pointer                      _lastWriteOffset += metabytes.Length + 5;                  }                  else                  {                      // write header info                      _datawrite.Write(new byte[] { 0 }' 0' 1); // write raw                      _datawrite.Write(Helper.GetBytes(data.Length' false)' 0' 4);                      // update pointer                      _lastWriteOffset += 5;                  }                    if (data != null)                  {                      // write data block                      _datawrite.Write(data' 0' data.Length);                      _lastWriteOffset += data.Length;                  }                  // return starting offset -> recno                  long recno = _lastRecordNum++;                  if (_recfilewrite != null)                      _recfilewrite.Write(Helper.GetBytes(offset' false)' 0' 8);                  if (Global.FlushStorageFileImmediately)                  {                      _datawrite.Flush();                      if (_recfilewrite != null)                          _recfilewrite.Flush();                  }                  return recno;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,internalWriteData,The following statement contains a magic number: lock (_readlock)              {                  _dirty = true;                  // seek end of file                  long offset = _lastWriteOffset;                  if (_viewmode == false && Global.SplitStorageFilesMegaBytes > 0)                  {                      // current file size > _splitMegaBytes --> new file                      if (offset > (long)Global.SplitStorageFilesMegaBytes * 1024 * 1024)                          CreateNewStorageFile();                  }                    if (raw == false)                  {                      if (data != null)                          meta.dataLength = data.Length;                      byte[] metabytes = fastBinaryJSON.BJSON.ToBJSON(meta' new fastBinaryJSON.BJSONParameters { UseExtensions = false });                        // write header info                      _datawrite.Write(new byte[] { 1 }' 0' 1); // FEATURE : add json here' write bson for now                      _datawrite.Write(Helper.GetBytes(metabytes.Length' false)' 0' 4);                      _datawrite.Write(metabytes' 0' metabytes.Length);                      // update pointer                      _lastWriteOffset += metabytes.Length + 5;                  }                  else                  {                      // write header info                      _datawrite.Write(new byte[] { 0 }' 0' 1); // write raw                      _datawrite.Write(Helper.GetBytes(data.Length' false)' 0' 4);                      // update pointer                      _lastWriteOffset += 5;                  }                    if (data != null)                  {                      // write data block                      _datawrite.Write(data' 0' data.Length);                      _lastWriteOffset += data.Length;                  }                  // return starting offset -> recno                  long recno = _lastRecordNum++;                  if (_recfilewrite != null)                      _recfilewrite.Write(Helper.GetBytes(offset' false)' 0' 8);                  if (Global.FlushStorageFileImmediately)                  {                      _datawrite.Flush();                      if (_recfilewrite != null)                          _recfilewrite.Flush();                  }                  return recno;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,internalWriteData,The following statement contains a magic number: lock (_readlock)              {                  _dirty = true;                  // seek end of file                  long offset = _lastWriteOffset;                  if (_viewmode == false && Global.SplitStorageFilesMegaBytes > 0)                  {                      // current file size > _splitMegaBytes --> new file                      if (offset > (long)Global.SplitStorageFilesMegaBytes * 1024 * 1024)                          CreateNewStorageFile();                  }                    if (raw == false)                  {                      if (data != null)                          meta.dataLength = data.Length;                      byte[] metabytes = fastBinaryJSON.BJSON.ToBJSON(meta' new fastBinaryJSON.BJSONParameters { UseExtensions = false });                        // write header info                      _datawrite.Write(new byte[] { 1 }' 0' 1); // FEATURE : add json here' write bson for now                      _datawrite.Write(Helper.GetBytes(metabytes.Length' false)' 0' 4);                      _datawrite.Write(metabytes' 0' metabytes.Length);                      // update pointer                      _lastWriteOffset += metabytes.Length + 5;                  }                  else                  {                      // write header info                      _datawrite.Write(new byte[] { 0 }' 0' 1); // write raw                      _datawrite.Write(Helper.GetBytes(data.Length' false)' 0' 4);                      // update pointer                      _lastWriteOffset += 5;                  }                    if (data != null)                  {                      // write data block                      _datawrite.Write(data' 0' data.Length);                      _lastWriteOffset += data.Length;                  }                  // return starting offset -> recno                  long recno = _lastRecordNum++;                  if (_recfilewrite != null)                      _recfilewrite.Write(Helper.GetBytes(offset' false)' 0' 8);                  if (Global.FlushStorageFileImmediately)                  {                      _datawrite.Flush();                      if (_recfilewrite != null)                          _recfilewrite.Flush();                  }                  return recno;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ComputeOffset,The following statement contains a magic number: long off = recnum << 3;
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ComputeOffset,The following statement contains a magic number: byte[] b = new byte[8];
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ComputeOffset,The following statement contains a magic number: _recfileread.Read(b' 0' 8);
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ComputeOffset,The following statement contains a magic number: if (off == 0)// kludge                  off = 6;
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ReadMetaData,The following statement contains a magic number: byte[] hdr = new byte[5];
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ReadMetaData,The following statement contains a magic number: fs.Read(hdr' 0' 5);
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,ReadMetaData,The following statement contains a magic number: if (type > 0)              {                  metasize = len + 5;                  hdr = new byte[len];                  fs.Read(hdr' 0' len);                  StorageItem<T> meta;                  if (type == 1)                      meta = fastBinaryJSON.BJSON.ToObject<StorageItem<T>>(hdr);                  else                  {                      string str = Helper.GetString(hdr' 0' (short)hdr.Length);                      meta = fastJSON.JSON.ToObject<StorageItem<T>>(str);                  }                  return meta;              }              else              {                  metasize = len;                  return null;              }
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,Pump,The following statement contains a magic number: byte[] bytes = new byte[4096 * 2];
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,Pump,The following statement contains a magic number: byte[] bytes = new byte[4096 * 2];
Magic Number,RaptorDB,StorageFile<T>,C:\repos\mgholam_hOOt\Hoot\MGIndex\StorageFile.cs,binarysearch,The following statement contains a magic number: while (low <= high)              {                  midpoint = low + (high - low) / 2;                  long k = _uptoindexes[midpoint];                  // check to see if value is equal to item in array                  if (offset == k)                      return midpoint + 1;                  else if (offset < k)                  {                      high = midpoint - 1;                      lastlower = midpoint;                  }                  else                      low = midpoint + 1;              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Not,The following statement contains a magic number: lock (_lock)              {                  this.CheckBitArray();                    uint[] left = this.GetBitArray();                  int c = left.Length;                  int ms = size >> 5;                  if (size - (ms << 5) > 0)                      ms++; // include remainder                  if (ms > c)                  {                      var a = new uint[ms];                      Array.Copy(left' 0' a' 0' c);                      left = a;                      c = ms;                  }                    for (int i = 0; i < c; i++)                      left[i] = ~left[i];                    return new WAHBitArray(TYPE.Bitarray' left);              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Not,The following statement contains a magic number: lock (_lock)              {                  this.CheckBitArray();                    uint[] left = this.GetBitArray();                  int c = left.Length;                  int ms = size >> 5;                  if (size - (ms << 5) > 0)                      ms++; // include remainder                  if (ms > c)                  {                      var a = new uint[ms];                      Array.Copy(left' 0' a' 0' c);                      left = a;                      c = ms;                  }                    for (int i = 0; i < c; i++)                      left[i] = ~left[i];                    return new WAHBitArray(TYPE.Bitarray' left);              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,BitCount,The following statement contains a magic number: n = (((n >> 2) & 0x33333333) + (n & 0x33333333));
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,BitCount,The following statement contains a magic number: n = (((n >> 4) + n) & 0x0f0f0f0f);
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,BitCount,The following statement contains a magic number: return (int)((n * 0x01010101) >> 24);
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,CountZeros,The following statement contains a magic number: int count = _uncompressed.Length << 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,GetBitIndexes,The following statement contains a magic number: if (_state == TYPE.Indexes)              {                  foreach (int i in GetOffsets())                      yield return i;              }              else              {                  CheckBitArray();                  int count = _uncompressed.Length;                    for (int i = 0; i < count; i++)                  {                      if (_uncompressed[i] > 0)                      {                          for (int j = 0; j < 32; j++)                          {                              bool b = internalGet((i << 5) + j);                              if (b == true)// ones)                                  yield return (i << 5) + j;                          }                      }                  }              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,GetBitIndexes,The following statement contains a magic number: if (_state == TYPE.Indexes)              {                  foreach (int i in GetOffsets())                      yield return i;              }              else              {                  CheckBitArray();                  int count = _uncompressed.Length;                    for (int i = 0; i < count; i++)                  {                      if (_uncompressed[i] > 0)                      {                          for (int j = 0; j < 32; j++)                          {                              bool b = internalGet((i << 5) + j);                              if (b == true)// ones)                                  yield return (i << 5) + j;                          }                      }                  }              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,GetBitIndexes,The following statement contains a magic number: if (_state == TYPE.Indexes)              {                  foreach (int i in GetOffsets())                      yield return i;              }              else              {                  CheckBitArray();                  int count = _uncompressed.Length;                    for (int i = 0; i < count; i++)                  {                      if (_uncompressed[i] > 0)                      {                          for (int j = 0; j < 32; j++)                          {                              bool b = internalGet((i << 5) + j);                              if (b == true)// ones)                                  yield return (i << 5) + j;                          }                      }                  }              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,UnpackOffsets,The following statement contains a magic number: uint[] ints = new uint[(max >> 5) + 1];
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,UnpackOffsets,The following statement contains a magic number: foreach (int index in k)              {                  int pointer = ((int)index) >> 5;                  uint mask = (uint)1 << (31 - // high order bit set                      ((int)index % 32));                    ints[pointer] |= mask;              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,UnpackOffsets,The following statement contains a magic number: foreach (int index in k)              {                  int pointer = ((int)index) >> 5;                  uint mask = (uint)1 << (31 - // high order bit set                      ((int)index % 32));                    ints[pointer] |= mask;              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,UnpackOffsets,The following statement contains a magic number: foreach (int index in k)              {                  int pointer = ((int)index) >> 5;                  uint mask = (uint)1 << (31 - // high order bit set                      ((int)index % 32));                    ints[pointer] |= mask;              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,ChangeTypeIfNeeded,The following statement contains a magic number: uint T = (_curMax >> 5) + 1;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Resize,The following statement contains a magic number: int c = index >> 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,ResizeAsNeeded,The following statement contains a magic number: int count = index >> 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,internalSet,The following statement contains a magic number: int pointer = index >> 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,internalSet,The following statement contains a magic number: uint mask = (uint)1 << (31 - // high order bit set                  (index % 32));
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,internalSet,The following statement contains a magic number: uint mask = (uint)1 << (31 - // high order bit set                  (index % 32));
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,internalGet,The following statement contains a magic number: int pointer = index >> 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,internalGet,The following statement contains a magic number: uint mask = (uint)1 << (31 - // high order bit get                  (index % 32));
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,internalGet,The following statement contains a magic number: uint mask = (uint)1 << (31 - // high order bit get                  (index % 32));
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Take31Bits,The following statement contains a magic number: int off = (index % 32);
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Take31Bits,The following statement contains a magic number: int pointer = index >> 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Take31Bits,The following statement contains a magic number: l = (l1 << 32) + l2;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Take31Bits,The following statement contains a magic number: ret = (l >> (33 - off)) & 0x7fffffff;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Compress,The following statement contains a magic number: int count = data.Length << 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Compress,The following statement contains a magic number: while (i < count)//for (int i = 0; i < count;)              {                  uint num = Take31Bits(data' i);                  i += 31;                  if (num == 0) // all zero                  {                      zeros += 31;                      FlushOnes(compressed' ref ones);                  }                  else if (num == 0x7fffffff) // all ones                  {                      ones += 31;                      FlushZeros(compressed' ref zeros);                  }                  else // literal                  {                      FlushOnes(compressed' ref ones);                      FlushZeros(compressed' ref zeros);                      compressed.Add(num);                  }              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Compress,The following statement contains a magic number: while (i < count)//for (int i = 0; i < count;)              {                  uint num = Take31Bits(data' i);                  i += 31;                  if (num == 0) // all zero                  {                      zeros += 31;                      FlushOnes(compressed' ref ones);                  }                  else if (num == 0x7fffffff) // all ones                  {                      ones += 31;                      FlushZeros(compressed' ref zeros);                  }                  else // literal                  {                      FlushOnes(compressed' ref ones);                      FlushZeros(compressed' ref zeros);                      compressed.Add(num);                  }              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Compress,The following statement contains a magic number: while (i < count)//for (int i = 0; i < count;)              {                  uint num = Take31Bits(data' i);                  i += 31;                  if (num == 0) // all zero                  {                      zeros += 31;                      FlushOnes(compressed' ref ones);                  }                  else if (num == 0x7fffffff) // all ones                  {                      ones += 31;                      FlushZeros(compressed' ref zeros);                  }                  else // literal                  {                      FlushOnes(compressed' ref ones);                      FlushZeros(compressed' ref zeros);                      compressed.Add(num);                  }              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Write31Bits,The following statement contains a magic number: ResizeAsNeeded(list' index + 32);
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Write31Bits,The following statement contains a magic number: int off = (index % 32);
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Write31Bits,The following statement contains a magic number: int pointer = index >> 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Write31Bits,The following statement contains a magic number: ulong l = ((ulong)list[pointer] << 32) + list[pointer + 1];
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Write31Bits,The following statement contains a magic number: l |= (ulong)val << (33 - off);
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Write31Bits,The following statement contains a magic number: list[pointer] = (uint)(l >> 32);
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: int off = index % 32;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: int pointer = index >> 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: int x = 32 - off;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: if (ccount > x )//|| x == 32) //current pointer              {                  list[pointer] |= (uint)((0xffffffff >> off));                  ccount -= x;                  indx += x;              }              else              {                  list[pointer] |= (uint)((0xffffffff << (32 - ccount)) >> off);                  ccount = 0;              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: while (ccount >= 32)//full ints              {                  if (checklast && list[list.Count - 1] == 0)                  {                      list.RemoveAt(list.Count - 1);                      checklast = false;                  }                    list.Add(0xffffffff);                  ccount -= 32;                  indx += 32;              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: while (ccount >= 32)//full ints              {                  if (checklast && list[list.Count - 1] == 0)                  {                      list.RemoveAt(list.Count - 1);                      checklast = false;                  }                    list.Add(0xffffffff);                  ccount -= 32;                  indx += 32;              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: while (ccount >= 32)//full ints              {                  if (checklast && list[list.Count - 1] == 0)                  {                      list.RemoveAt(list.Count - 1);                      checklast = false;                  }                    list.Add(0xffffffff);                  ccount -= 32;                  indx += 32;              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: int p = indx >> 5;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: off = indx % 32;
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WriteOnes,The following statement contains a magic number: if (ccount > 0)              {                  uint i = 0xffffffff << (32 - ccount);                  if (p > (list.Count - 1)) //remaining                      list.Add(i);                  else                      list[p] |= (uint)(i >> off);              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Uncompress,The following statement contains a magic number: foreach (uint ci in _compressed)              {                  if ((ci & 0x80000000) == 0) // literal                  {                      Write31Bits(list' index' ci);                      index += 31;                  }                  else                  {                      uint count = ci & 0x3fffffff;                      if ((ci & 0x40000000) != 0) // ones count                          WriteOnes(list' index' count);                        index += (int)count;                  }              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Fill,The following statement contains a magic number: if (count > 0)              {                  int c = count >> 5;                  int r = count % 32;                  if (r > 0)                      c++;                  uint[] ints = new uint[c];                  for (int i = 0; i < c - 1; i++)                      ints[i] = 0xffffffff;                  ints[c - 1] = 0xffffffff << (31 - r);                  return new WAHBitArray(TYPE.Bitarray' ints);              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Fill,The following statement contains a magic number: if (count > 0)              {                  int c = count >> 5;                  int r = count % 32;                  if (r > 0)                      c++;                  uint[] ints = new uint[c];                  for (int i = 0; i < c - 1; i++)                      ints[i] = 0xffffffff;                  ints[c - 1] = 0xffffffff << (31 - r);                  return new WAHBitArray(TYPE.Bitarray' ints);              }
Magic Number,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,Fill,The following statement contains a magic number: if (count > 0)              {                  int c = count >> 5;                  int r = count % 32;                  if (r > 0)                      c++;                  uint[] ints = new uint[c];                  for (int i = 0; i < c - 1; i++)                      ints[i] = 0xffffffff;                  ints[c - 1] = 0xffffffff << (31 - r);                  return new WAHBitArray(TYPE.Bitarray' ints);              }
Magic Number,RaptorDB,tokenizer,C:\repos\mgholam_hOOt\Hoot\tokenizer.cs,GenerateWordFreq,The following statement contains a magic number: Dictionary<string' int> dic = new Dictionary<string' int>(500);
Magic Number,RaptorDB,tokenizer,C:\repos\mgholam_hOOt\Hoot\tokenizer.cs,AddDictionary,The following statement contains a magic number: if (l < 2)                  return;
Magic Number,RaptorDB,tokenizer,C:\repos\mgholam_hOOt\Hoot\tokenizer.cs,AddDictionary,The following statement contains a magic number: if (l < 2)                  return;
Magic Number,RaptorDB,tokenizer,C:\repos\mgholam_hOOt\Hoot\tokenizer.cs,AddDictionary,The following statement contains a magic number: if (word.Contains(".") && char.IsDigit(word[0]) == false)              {                  foreach (var s in word.Split('.'))                  {                      if (s.Length > 2)                          addword(dic' s);                  }              }              else                  addword(dic' word);
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,ToInt32,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[4];                  Buffer.BlockCopy(value' startIndex' b' 0' 4);                  Array.Reverse(b);                  return ToInt32(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,ToInt32,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[4];                  Buffer.BlockCopy(value' startIndex' b' 0' 4);                  Array.Reverse(b);                  return ToInt32(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,ToInt64,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[8];                  Buffer.BlockCopy(value' startIndex' b' 0' 8);                  Array.Reverse(b);                  return ToInt64(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,ToInt64,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[8];                  Buffer.BlockCopy(value' startIndex' b' 0' 8);                  Array.Reverse(b);                  return ToInt64(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,ToInt16,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[2];                  Buffer.BlockCopy(value' startIndex' b' 0' 2);                  Array.Reverse(b);                  return ToInt16(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,ToInt16,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[2];                  Buffer.BlockCopy(value' startIndex' b' 0' 2);                  Array.Reverse(b);                  return ToInt16(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,GetBytes,The following statement contains a magic number: byte[] buffer = new byte[8];
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,GetBytes,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_hOOt\Hoot\SafeDictionary.cs,GetBytes,The following statement contains a magic number: byte[] buffer = new byte[2];
Missing Default,fastBinaryJSON,BJsonParser,C:\repos\mgholam_hOOt\Hoot\fastBinaryJSON\BJsonParser.cs,ParseValue,The following switch statement is missing a default case: switch (t)              {                  case TOKENS.BYTE:                      return ParseByte();                  case TOKENS.BYTEARRAY:                      return ParseByteArray();                  case TOKENS.CHAR:                      return ParseChar();                  case TOKENS.DATETIME:                      return ParseDateTime();                  case TOKENS.DECIMAL:                      return ParseDecimal();                  case TOKENS.DOUBLE:                      return ParseDouble();                  case TOKENS.FLOAT:                      return ParseFloat();                  case TOKENS.GUID:                      return ParseGuid();                  case TOKENS.INT:                      return ParseInt();                  case TOKENS.LONG:                      return ParseLong();                  case TOKENS.SHORT:                      return ParseShort();                  //case TOKENS.SINGLE:                  //    return ParseSingle();                  case TOKENS.UINT:                      return ParseUint();                  case TOKENS.ULONG:                      return ParseULong();                  case TOKENS.USHORT:                      return ParseUShort();                  case TOKENS.UNICODE_STRING:                      return ParseUnicodeString();                  case TOKENS.STRING:                      return ParseString();                  case TOKENS.DOC_START:                      return ParseObject();                  case TOKENS.ARRAY_START:                      return ParseArray();                  case TOKENS.TRUE:                      return true;                  case TOKENS.FALSE:                      return false;                  case TOKENS.NULL:                      return null;                  case TOKENS.ARRAY_END:                      breakparse = true;                      return TOKENS.ARRAY_END;                  case TOKENS.DOC_END:                      breakparse = true;                      return TOKENS.DOC_END;                  case TOKENS.COMMA:                      breakparse = true;                      return TOKENS.COMMA;              }
Missing Default,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead())              {                  case Token.Number:                      return ParseNumber();                    case Token.String:                      return ParseString();                    case Token.Curly_Open:                      return ParseObject();                    case Token.Squared_Open:                      return ParseArray();                    case Token.True:                      ConsumeToken();                      return true;                    case Token.False:                      ConsumeToken();                      return false;                    case Token.Null:                      ConsumeToken();                      return null;              }
Missing Default,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,ParseString,The following switch statement is missing a default case: switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }
Missing Default,fastJSON,JsonParser,C:\repos\mgholam_hOOt\Hoot\fastJSON\JsonParser.cs,NextTokenCore,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Missing Default,RaptorDB,Hoot,C:\repos\mgholam_hOOt\Hoot\Hoot.cs,DoBitOperation,The following switch statement is missing a default case: switch (op)                  {                      case OPERATION.AND:                          bits = bits.And(c);                          break;                      case OPERATION.OR:                          bits = bits.Or(c);                          break;                      case OPERATION.ANDNOT:                          bits = bits.And(c.Not(maxsize));                          break;                  }
Missing Default,RaptorDB,WAHBitArray,C:\repos\mgholam_hOOt\Hoot\MGIndex\WAHBitarray2.cs,WAHBitArray,The following switch statement is missing a default case: switch (type)              {                  case TYPE.WAH:                      _compressed = ints;                      Uncompress();                      _state = TYPE.Bitarray;                      _compressed = null;                      break;                  case TYPE.Bitarray:                      _uncompressed = ints;                      break;                  case TYPE.Indexes:                      _offsets = new SortedList<uint' bool>();                               //new Dictionary<uint' bool>();                      foreach (var i in ints)                          _offsets.Add(i' true);                      break;              }
