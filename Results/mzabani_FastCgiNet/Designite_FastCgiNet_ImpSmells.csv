Implementation smell,Namespace,Class,File,Method,Description
Long Method,FastCgiNet,NvpEnumerator,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpEnumerator.cs,MoveNext,The method has 69 lines of code.
Complex Method,FastCgiNet,NvpEnumerator,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpEnumerator.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,CreateRecord,Cyclomatic complexity of the method is 10
Complex Method,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,CreateRecord,Cyclomatic complexity of the method is 9
Complex Method,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,CreateRecordFromHeader,Cyclomatic complexity of the method is 11
Complex Method,FastCgiNet.Streams,RecordContentsStream,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Streams\RecordContentsStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,FastCgiNet.Streams,SocketStream,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Streams\SocketStream.cs,Flush,Cyclomatic complexity of the method is 11
Complex Method,FastCgiNet.Streams,FastCgiStream,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Streams\FastCgiStream.cs,Read,Cyclomatic complexity of the method is 7
Complex Method,FastCgiNet.Streams,FastCgiStream,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Streams\FastCgiStream.cs,Write,Cyclomatic complexity of the method is 7
Complex Method,FastCgiNet.Requests,FastCgiRequest,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Request\FastCgiRequest.cs,Send,Cyclomatic complexity of the method is 7
Complex Method,FastCgiNet.Requests,FastCgiRequest,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Request\FastCgiRequest.cs,AddReceivedRecord,Cyclomatic complexity of the method is 24
Long Parameter List,FastCgiNet,StdinRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StdinRecord.cs,StdinRecord,The method has 4 parameters.
Long Parameter List,FastCgiNet,RecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,FeedBytes,The method has 4 parameters.
Long Parameter List,FastCgiNet,RecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The method has 4 parameters.
Long Parameter List,FastCgiNet,StdoutRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StdoutRecord.cs,StdoutRecord,The method has 4 parameters.
Long Parameter List,FastCgiNet,StderrRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StderrRecord.cs,StderrRecord,The method has 4 parameters.
Long Parameter List,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,FeedBytes,The method has 4 parameters.
Long Parameter List,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The method has 5 parameters.
Long Parameter List,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,FeedBytes,The method has 4 parameters.
Long Parameter List,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The method has 4 parameters.
Long Parameter List,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,FeedBytes,The method has 4 parameters.
Long Parameter List,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The method has 4 parameters.
Long Parameter List,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The method has 5 parameters.
Long Parameter List,FastCgiNet,NameValuePair,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,FeedBytes,The method has 4 parameters.
Long Parameter List,FastCgiNet,ParamsRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\ParamsRecord.cs,ParamsRecord,The method has 4 parameters.
Long Parameter List,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,CreateRecordFromHeader,The method has 4 parameters.
Long Parameter List,FastCgiNet,AbortRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\AbortRequestRecord.cs,FeedBytes,The method has 4 parameters.
Long Parameter List,FastCgiNet,AbortRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\AbortRequestRecord.cs,AbortRequestRecord,The method has 4 parameters.
Long Parameter List,FastCgiNet,DataRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\DataRecord.cs,DataRecord,The method has 4 parameters.
Long Identifier,FastCgiNet.Requests,WebServerSocketRequest,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Request\WebServerSocketRequest.cs,SendBeginRequest,The length of the parameter applicationMustCloseConnection is 30.
Long Statement,FastCgiNet,RecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,Equals,The length of the statement  "	return RecordType == b.RecordType && RequestId == b.RequestId && ContentLength == b.ContentLength && Version == b.Version; " is 122.
Long Statement,FastCgiNet,ExtensionMethods,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordType.cs,IsStreamType,The length of the statement  "	return type == RecordType.FCGIStderr || type == RecordType.FCGIStdin || type == RecordType.FCGIStdout || type == RecordType.FCGIParams || type == RecordType.FCGIData; " is 166.
Long Statement,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The length of the statement  "				if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord) " is 126.
Long Statement,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The length of the statement  "					LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord); " is 134.
Long Statement,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The length of the statement  "				if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord) " is 126.
Long Statement,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,CreateRecordFromHeader,The length of the statement  "		throw new InsufficientBytesException ("There are not enough bytes in the array for a complete header. Make sure at least 8 bytes are available"); " is 145.
Long Statement,FastCgiNet.Streams,RecordContentsStream,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Streams\RecordContentsStream.cs,Write,The length of the statement  "		throw new InvalidOperationException ("You can't write more than " + RecordBase.MaxContentLength + " bytes to a record's contents"); " is 131.
Long Statement,FastCgiNet.Streams,FastCgiStream,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Streams\FastCgiStream.cs,Write,The length of the statement  "		throw new InvalidOperationException ("You can't write to this stream. You should either append a Record's Stream or initialize this stream with Read Mode = false"); " is 164.
Virtual Method Call from Constructor,FastCgiNet.Streams,FastCgiStream,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Streams\FastCgiStream.cs,FastCgiStream,The constructor "FastCgiStream" calls a virtual method "AppendStream".
Magic Number,FastCgiNet,RecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The following statement contains a magic number: Header = new byte[8];  
Magic Number,FastCgiNet,RecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The following statement contains a magic number: if (length < 8 || data.Length < 8)  	throw new ArgumentException ("The length available in the array must be at least 8 bytes");  
Magic Number,FastCgiNet,RecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The following statement contains a magic number: if (length < 8 || data.Length < 8)  	throw new ArgumentException ("The length available in the array must be at least 8 bytes");  
Magic Number,FastCgiNet,RecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The following statement contains a magic number: Array.Copy (data' offset' Header' 0' 8);  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (ContentLength + PaddingLength == 0)  	endOfRecord = offset + 7;  else if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (ContentLength + PaddingLength == 0)  	endOfRecord = offset + 7;  else if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (ContentLength + PaddingLength == 0)  	endOfRecord = offset + 7;  else if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (ContentLength + PaddingLength == 0)  	endOfRecord = offset + 7;  else if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: endOfRecord = offset + 7;  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: FeedBytes (data' offset + 8' length - 8' out endOfRecord);  
Magic Number,FastCgiNet,StreamRecordBase,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: FeedBytes (data' offset + 8' length - 8' out endOfRecord);  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,FeedBytes,The following statement contains a magic number: if (fedBytes == 8)  	throw new InvalidOperationException ("The BeginRequest section of this record is complete.");  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,FeedBytes,The following statement contains a magic number: if (length >= bytesNeeded) {  	Array.Copy (data' offset' RoleAndFlags' fedBytes' bytesNeeded);  	fedBytes = 8;  	endOfRecord = offset + bytesNeeded - 1;  } else {  	Array.Copy (data' offset' RoleAndFlags' fedBytes' length);  	fedBytes += length;  	endOfRecord = -1;  }  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,FeedBytes,The following statement contains a magic number: fedBytes = 8;  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: RoleAndFlags = new byte[8];  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: RoleAndFlags = new byte[8];  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: FeedBytes (data' offset + 8' length - 8' out endOfRecord);  
Magic Number,FastCgiNet,BeginRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: FeedBytes (data' offset + 8' length - 8' out endOfRecord);  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,FeedBytes,The following statement contains a magic number: if (fedBytes == 5)  	throw new InvalidOperationException ("The EndRequest section of this record is complete.");  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,FeedBytes,The following statement contains a magic number: if (length >= bytesNeeded) {  	Array.Copy (data' offset' AppAndProtocolStatus' fedBytes' bytesNeeded);  	fedBytes = 5;  	endOfRecord = offset + bytesNeeded - 1;  } else {  	Array.Copy (data' offset' AppAndProtocolStatus' fedBytes' length);  	fedBytes += length;  	endOfRecord = -1;  }  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,FeedBytes,The following statement contains a magic number: fedBytes = 5;  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: AppAndProtocolStatus = new byte[5];  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: AppAndProtocolStatus = new byte[5];  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: if (length > 8)  	FeedBytes (data' offset + 8' length - 8' out endOfRecord);  else  	endOfRecord = -1;  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: FeedBytes (data' offset + 8' length - 8' out endOfRecord);  
Magic Number,FastCgiNet,EndRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: FeedBytes (data' offset + 8' length - 8' out endOfRecord);  
Magic Number,FastCgiNet,NvpEnumerator,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpEnumerator.cs,NvpEnumerator,The following statement contains a magic number: bufsize = 16;  
Magic Number,FastCgiNet,NvpEnumerator,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpEnumerator.cs,NvpEnumerator,The following statement contains a magic number: bufSmall = new byte[8];  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr [offset] >> 7) == 0) {  	// 1 byte long  	if (length < 1)  		throw new InsufficientBytesException ();  	return arr [offset];  } else {  	// 4 bytes long  	if (length < 4)  		throw new InsufficientBytesException ();  	return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr [offset] >> 7) == 0) {  	// 1 byte long  	if (length < 1)  		throw new InsufficientBytesException ();  	return arr [offset];  } else {  	// 4 bytes long  	if (length < 4)  		throw new InsufficientBytesException ();  	return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr [offset] >> 7) == 0) {  	// 1 byte long  	if (length < 1)  		throw new InsufficientBytesException ();  	return arr [offset];  } else {  	// 4 bytes long  	if (length < 4)  		throw new InsufficientBytesException ();  	return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr [offset] >> 7) == 0) {  	// 1 byte long  	if (length < 1)  		throw new InsufficientBytesException ();  	return arr [offset];  } else {  	// 4 bytes long  	if (length < 4)  		throw new InsufficientBytesException ();  	return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr [offset] >> 7) == 0) {  	// 1 byte long  	if (length < 1)  		throw new InsufficientBytesException ();  	return arr [offset];  } else {  	// 4 bytes long  	if (length < 4)  		throw new InsufficientBytesException ();  	return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr [offset] >> 7) == 0) {  	// 1 byte long  	if (length < 1)  		throw new InsufficientBytesException ();  	return arr [offset];  } else {  	// 4 bytes long  	if (length < 4)  		throw new InsufficientBytesException ();  	return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr [offset] >> 7) == 0) {  	// 1 byte long  	if (length < 1)  		throw new InsufficientBytesException ();  	return arr [offset];  } else {  	// 4 bytes long  	if (length < 4)  		throw new InsufficientBytesException ();  	return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if (length < 4)  	throw new InsufficientBytesException ();  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: return ((arr [offset] & 0x7f) << 24) + (arr [offset + 1] << 16) + (arr [offset + 2] << 8) + arr [offset + 3];  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: try {  	nameLength = GetLengthFromByteArray (firstData' offset' length);  	bytesRead = 0;  	if (nameLength > 0x7f) {  		bytesRead += 4;  		valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  	} else {  		bytesRead += 1;  		valueLength = GetLengthFromByteArray (firstData' offset + 1' length - 1);  	}  	bytesRead += (valueLength > 0x7f) ? 4 : 1;  } catch (InsufficientBytesException) {  	endOfNvp = -1;  	createdNvp = null;  	return false;  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: try {  	nameLength = GetLengthFromByteArray (firstData' offset' length);  	bytesRead = 0;  	if (nameLength > 0x7f) {  		bytesRead += 4;  		valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  	} else {  		bytesRead += 1;  		valueLength = GetLengthFromByteArray (firstData' offset + 1' length - 1);  	}  	bytesRead += (valueLength > 0x7f) ? 4 : 1;  } catch (InsufficientBytesException) {  	endOfNvp = -1;  	createdNvp = null;  	return false;  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: try {  	nameLength = GetLengthFromByteArray (firstData' offset' length);  	bytesRead = 0;  	if (nameLength > 0x7f) {  		bytesRead += 4;  		valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  	} else {  		bytesRead += 1;  		valueLength = GetLengthFromByteArray (firstData' offset + 1' length - 1);  	}  	bytesRead += (valueLength > 0x7f) ? 4 : 1;  } catch (InsufficientBytesException) {  	endOfNvp = -1;  	createdNvp = null;  	return false;  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: try {  	nameLength = GetLengthFromByteArray (firstData' offset' length);  	bytesRead = 0;  	if (nameLength > 0x7f) {  		bytesRead += 4;  		valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  	} else {  		bytesRead += 1;  		valueLength = GetLengthFromByteArray (firstData' offset + 1' length - 1);  	}  	bytesRead += (valueLength > 0x7f) ? 4 : 1;  } catch (InsufficientBytesException) {  	endOfNvp = -1;  	createdNvp = null;  	return false;  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: if (nameLength > 0x7f) {  	bytesRead += 4;  	valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  } else {  	bytesRead += 1;  	valueLength = GetLengthFromByteArray (firstData' offset + 1' length - 1);  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: if (nameLength > 0x7f) {  	bytesRead += 4;  	valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  } else {  	bytesRead += 1;  	valueLength = GetLengthFromByteArray (firstData' offset + 1' length - 1);  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: if (nameLength > 0x7f) {  	bytesRead += 4;  	valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  } else {  	bytesRead += 1;  	valueLength = GetLengthFromByteArray (firstData' offset + 1' length - 1);  }  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: bytesRead += 4;  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: valueLength = GetLengthFromByteArray (firstData' offset + 4' length - 4);  
Magic Number,FastCgiNet,NvpFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: bytesRead += (valueLength > 0x7f) ? 4 : 1;  
Magic Number,FastCgiNet,NameValuePair,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: if (length < 128) {  	headerBytes = new byte[1] {  		(byte)length  	};  } else {  	// MSB first  	headerBytes = new byte[4];  	headerBytes [3] = (byte)(length & 0xff000000);  	headerBytes [2] = (byte)(length & 0xff0000);  	headerBytes [1] = (byte)(length & 0xff00);  	headerBytes [0] = (byte)(length & 0xff);  }  
Magic Number,FastCgiNet,NameValuePair,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: if (length < 128) {  	headerBytes = new byte[1] {  		(byte)length  	};  } else {  	// MSB first  	headerBytes = new byte[4];  	headerBytes [3] = (byte)(length & 0xff000000);  	headerBytes [2] = (byte)(length & 0xff0000);  	headerBytes [1] = (byte)(length & 0xff00);  	headerBytes [0] = (byte)(length & 0xff);  }  
Magic Number,FastCgiNet,NameValuePair,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: if (length < 128) {  	headerBytes = new byte[1] {  		(byte)length  	};  } else {  	// MSB first  	headerBytes = new byte[4];  	headerBytes [3] = (byte)(length & 0xff000000);  	headerBytes [2] = (byte)(length & 0xff0000);  	headerBytes [1] = (byte)(length & 0xff00);  	headerBytes [0] = (byte)(length & 0xff);  }  
Magic Number,FastCgiNet,NameValuePair,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: if (length < 128) {  	headerBytes = new byte[1] {  		(byte)length  	};  } else {  	// MSB first  	headerBytes = new byte[4];  	headerBytes [3] = (byte)(length & 0xff000000);  	headerBytes [2] = (byte)(length & 0xff0000);  	headerBytes [1] = (byte)(length & 0xff00);  	headerBytes [0] = (byte)(length & 0xff);  }  
Magic Number,FastCgiNet,NameValuePair,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: headerBytes = new byte[4];  
Magic Number,FastCgiNet,NameValuePair,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: headerBytes [3] = (byte)(length & 0xff000000);  
Magic Number,FastCgiNet,NameValuePair,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: headerBytes [2] = (byte)(length & 0xff0000);  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead) {  	/* 				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know 				// if something is wrong 				if (bytesFed > bytesRead) 					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads."); 				*/int bytesLeft = bytesRead - bytesFed;  	int lastByteOfRecord;  	// Are we going to create a new record or feed the last incomplete one?  	if (LastIncompleteRecord == null) {  		if (NumUnusedBytes + bytesLeft < 8) {  			// We still can't make a full header with what we have. Save and return.  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  			NumUnusedBytes += bytesLeft;  			yield break;  		} else if (NumUnusedBytes > 0) {  			// We should use these bytes that haven't been fed yet  			int neededForFullHeader = 8 - NumUnusedBytes;  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - neededForFullHeader > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  		} else {  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - 8 > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  		}  	} else {  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  	}  	// Check if we either created a complete record or fed that last incomplete one until its completion  	// If it is incomplete' then we must have fed all bytes read' and as such we should return.  	if (lastByteOfRecord == -1) {  		yield break;  	}  	RecordBase builtRecord = LastIncompleteRecord;  	LastIncompleteRecord = null;  	bytesFed = lastByteOfRecord + 1;  	// Tell all who are interested that we built a new record  	BuiltContentSize += builtRecord.ContentLength;  	yield return builtRecord;  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead) {  	/* 				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know 				// if something is wrong 				if (bytesFed > bytesRead) 					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads."); 				*/int bytesLeft = bytesRead - bytesFed;  	int lastByteOfRecord;  	// Are we going to create a new record or feed the last incomplete one?  	if (LastIncompleteRecord == null) {  		if (NumUnusedBytes + bytesLeft < 8) {  			// We still can't make a full header with what we have. Save and return.  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  			NumUnusedBytes += bytesLeft;  			yield break;  		} else if (NumUnusedBytes > 0) {  			// We should use these bytes that haven't been fed yet  			int neededForFullHeader = 8 - NumUnusedBytes;  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - neededForFullHeader > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  		} else {  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - 8 > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  		}  	} else {  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  	}  	// Check if we either created a complete record or fed that last incomplete one until its completion  	// If it is incomplete' then we must have fed all bytes read' and as such we should return.  	if (lastByteOfRecord == -1) {  		yield break;  	}  	RecordBase builtRecord = LastIncompleteRecord;  	LastIncompleteRecord = null;  	bytesFed = lastByteOfRecord + 1;  	// Tell all who are interested that we built a new record  	BuiltContentSize += builtRecord.ContentLength;  	yield return builtRecord;  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead) {  	/* 				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know 				// if something is wrong 				if (bytesFed > bytesRead) 					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads."); 				*/int bytesLeft = bytesRead - bytesFed;  	int lastByteOfRecord;  	// Are we going to create a new record or feed the last incomplete one?  	if (LastIncompleteRecord == null) {  		if (NumUnusedBytes + bytesLeft < 8) {  			// We still can't make a full header with what we have. Save and return.  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  			NumUnusedBytes += bytesLeft;  			yield break;  		} else if (NumUnusedBytes > 0) {  			// We should use these bytes that haven't been fed yet  			int neededForFullHeader = 8 - NumUnusedBytes;  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - neededForFullHeader > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  		} else {  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - 8 > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  		}  	} else {  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  	}  	// Check if we either created a complete record or fed that last incomplete one until its completion  	// If it is incomplete' then we must have fed all bytes read' and as such we should return.  	if (lastByteOfRecord == -1) {  		yield break;  	}  	RecordBase builtRecord = LastIncompleteRecord;  	LastIncompleteRecord = null;  	bytesFed = lastByteOfRecord + 1;  	// Tell all who are interested that we built a new record  	BuiltContentSize += builtRecord.ContentLength;  	yield return builtRecord;  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead) {  	/* 				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know 				// if something is wrong 				if (bytesFed > bytesRead) 					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads."); 				*/int bytesLeft = bytesRead - bytesFed;  	int lastByteOfRecord;  	// Are we going to create a new record or feed the last incomplete one?  	if (LastIncompleteRecord == null) {  		if (NumUnusedBytes + bytesLeft < 8) {  			// We still can't make a full header with what we have. Save and return.  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  			NumUnusedBytes += bytesLeft;  			yield break;  		} else if (NumUnusedBytes > 0) {  			// We should use these bytes that haven't been fed yet  			int neededForFullHeader = 8 - NumUnusedBytes;  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - neededForFullHeader > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  		} else {  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - 8 > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  		}  	} else {  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  	}  	// Check if we either created a complete record or fed that last incomplete one until its completion  	// If it is incomplete' then we must have fed all bytes read' and as such we should return.  	if (lastByteOfRecord == -1) {  		yield break;  	}  	RecordBase builtRecord = LastIncompleteRecord;  	LastIncompleteRecord = null;  	bytesFed = lastByteOfRecord + 1;  	// Tell all who are interested that we built a new record  	BuiltContentSize += builtRecord.ContentLength;  	yield return builtRecord;  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead) {  	/* 				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know 				// if something is wrong 				if (bytesFed > bytesRead) 					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads."); 				*/int bytesLeft = bytesRead - bytesFed;  	int lastByteOfRecord;  	// Are we going to create a new record or feed the last incomplete one?  	if (LastIncompleteRecord == null) {  		if (NumUnusedBytes + bytesLeft < 8) {  			// We still can't make a full header with what we have. Save and return.  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  			NumUnusedBytes += bytesLeft;  			yield break;  		} else if (NumUnusedBytes > 0) {  			// We should use these bytes that haven't been fed yet  			int neededForFullHeader = 8 - NumUnusedBytes;  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - neededForFullHeader > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  		} else {  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - 8 > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  		}  	} else {  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  	}  	// Check if we either created a complete record or fed that last incomplete one until its completion  	// If it is incomplete' then we must have fed all bytes read' and as such we should return.  	if (lastByteOfRecord == -1) {  		yield break;  	}  	RecordBase builtRecord = LastIncompleteRecord;  	LastIncompleteRecord = null;  	bytesFed = lastByteOfRecord + 1;  	// Tell all who are interested that we built a new record  	BuiltContentSize += builtRecord.ContentLength;  	yield return builtRecord;  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead) {  	/* 				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know 				// if something is wrong 				if (bytesFed > bytesRead) 					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads."); 				*/int bytesLeft = bytesRead - bytesFed;  	int lastByteOfRecord;  	// Are we going to create a new record or feed the last incomplete one?  	if (LastIncompleteRecord == null) {  		if (NumUnusedBytes + bytesLeft < 8) {  			// We still can't make a full header with what we have. Save and return.  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  			NumUnusedBytes += bytesLeft;  			yield break;  		} else if (NumUnusedBytes > 0) {  			// We should use these bytes that haven't been fed yet  			int neededForFullHeader = 8 - NumUnusedBytes;  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - neededForFullHeader > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  		} else {  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - 8 > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  		}  	} else {  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  	}  	// Check if we either created a complete record or fed that last incomplete one until its completion  	// If it is incomplete' then we must have fed all bytes read' and as such we should return.  	if (lastByteOfRecord == -1) {  		yield break;  	}  	RecordBase builtRecord = LastIncompleteRecord;  	LastIncompleteRecord = null;  	bytesFed = lastByteOfRecord + 1;  	// Tell all who are interested that we built a new record  	BuiltContentSize += builtRecord.ContentLength;  	yield return builtRecord;  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead) {  	/* 				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know 				// if something is wrong 				if (bytesFed > bytesRead) 					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads."); 				*/int bytesLeft = bytesRead - bytesFed;  	int lastByteOfRecord;  	// Are we going to create a new record or feed the last incomplete one?  	if (LastIncompleteRecord == null) {  		if (NumUnusedBytes + bytesLeft < 8) {  			// We still can't make a full header with what we have. Save and return.  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  			NumUnusedBytes += bytesLeft;  			yield break;  		} else if (NumUnusedBytes > 0) {  			// We should use these bytes that haven't been fed yet  			int neededForFullHeader = 8 - NumUnusedBytes;  			Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - neededForFullHeader > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  		} else {  			// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  			LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  			if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  				((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  			if (bytesLeft - 8 > 0)  				LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  		}  	} else {  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  	}  	// Check if we either created a complete record or fed that last incomplete one until its completion  	// If it is incomplete' then we must have fed all bytes read' and as such we should return.  	if (lastByteOfRecord == -1) {  		yield break;  	}  	RecordBase builtRecord = LastIncompleteRecord;  	LastIncompleteRecord = null;  	bytesFed = lastByteOfRecord + 1;  	// Tell all who are interested that we built a new record  	BuiltContentSize += builtRecord.ContentLength;  	yield return builtRecord;  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (LastIncompleteRecord == null) {  	if (NumUnusedBytes + bytesLeft < 8) {  		// We still can't make a full header with what we have. Save and return.  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  		NumUnusedBytes += bytesLeft;  		yield break;  	} else if (NumUnusedBytes > 0) {  		// We should use these bytes that haven't been fed yet  		int neededForFullHeader = 8 - NumUnusedBytes;  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - neededForFullHeader > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  	} else {  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - 8 > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  	}  } else {  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (LastIncompleteRecord == null) {  	if (NumUnusedBytes + bytesLeft < 8) {  		// We still can't make a full header with what we have. Save and return.  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  		NumUnusedBytes += bytesLeft;  		yield break;  	} else if (NumUnusedBytes > 0) {  		// We should use these bytes that haven't been fed yet  		int neededForFullHeader = 8 - NumUnusedBytes;  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - neededForFullHeader > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  	} else {  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - 8 > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  	}  } else {  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (LastIncompleteRecord == null) {  	if (NumUnusedBytes + bytesLeft < 8) {  		// We still can't make a full header with what we have. Save and return.  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  		NumUnusedBytes += bytesLeft;  		yield break;  	} else if (NumUnusedBytes > 0) {  		// We should use these bytes that haven't been fed yet  		int neededForFullHeader = 8 - NumUnusedBytes;  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - neededForFullHeader > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  	} else {  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - 8 > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  	}  } else {  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (LastIncompleteRecord == null) {  	if (NumUnusedBytes + bytesLeft < 8) {  		// We still can't make a full header with what we have. Save and return.  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  		NumUnusedBytes += bytesLeft;  		yield break;  	} else if (NumUnusedBytes > 0) {  		// We should use these bytes that haven't been fed yet  		int neededForFullHeader = 8 - NumUnusedBytes;  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - neededForFullHeader > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  	} else {  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - 8 > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  	}  } else {  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (LastIncompleteRecord == null) {  	if (NumUnusedBytes + bytesLeft < 8) {  		// We still can't make a full header with what we have. Save and return.  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  		NumUnusedBytes += bytesLeft;  		yield break;  	} else if (NumUnusedBytes > 0) {  		// We should use these bytes that haven't been fed yet  		int neededForFullHeader = 8 - NumUnusedBytes;  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - neededForFullHeader > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  	} else {  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - 8 > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  	}  } else {  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (LastIncompleteRecord == null) {  	if (NumUnusedBytes + bytesLeft < 8) {  		// We still can't make a full header with what we have. Save and return.  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  		NumUnusedBytes += bytesLeft;  		yield break;  	} else if (NumUnusedBytes > 0) {  		// We should use these bytes that haven't been fed yet  		int neededForFullHeader = 8 - NumUnusedBytes;  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - neededForFullHeader > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  	} else {  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - 8 > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  	}  } else {  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (LastIncompleteRecord == null) {  	if (NumUnusedBytes + bytesLeft < 8) {  		// We still can't make a full header with what we have. Save and return.  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  		NumUnusedBytes += bytesLeft;  		yield break;  	} else if (NumUnusedBytes > 0) {  		// We should use these bytes that haven't been fed yet  		int neededForFullHeader = 8 - NumUnusedBytes;  		Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - neededForFullHeader > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  	} else {  		// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  		LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  		if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  			((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  		if (bytesLeft - 8 > 0)  			LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  	}  } else {  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes + bytesLeft < 8) {  	// We still can't make a full header with what we have. Save and return.  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  	NumUnusedBytes += bytesLeft;  	yield break;  } else if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes + bytesLeft < 8) {  	// We still can't make a full header with what we have. Save and return.  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  	NumUnusedBytes += bytesLeft;  	yield break;  } else if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes + bytesLeft < 8) {  	// We still can't make a full header with what we have. Save and return.  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  	NumUnusedBytes += bytesLeft;  	yield break;  } else if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes + bytesLeft < 8) {  	// We still can't make a full header with what we have. Save and return.  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  	NumUnusedBytes += bytesLeft;  	yield break;  } else if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes + bytesLeft < 8) {  	// We still can't make a full header with what we have. Save and return.  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  	NumUnusedBytes += bytesLeft;  	yield break;  } else if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes + bytesLeft < 8) {  	// We still can't make a full header with what we have. Save and return.  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  	NumUnusedBytes += bytesLeft;  	yield break;  } else if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes + bytesLeft < 8) {  	// We still can't make a full header with what we have. Save and return.  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  	NumUnusedBytes += bytesLeft;  	yield break;  } else if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (NumUnusedBytes > 0) {  	// We should use these bytes that haven't been fed yet  	int neededForFullHeader = 8 - NumUnusedBytes;  	Array.Copy (data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - neededForFullHeader > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);  } else {  	// We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit  	LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  	if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)  		((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream (secondaryStorageStream);  	if (bytesLeft - 8 > 0)  		LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  }  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: LastIncompleteRecord = CreateRecordFromHeader (ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: LastIncompleteRecord = CreateRecordFromHeader (data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (bytesLeft - 8 > 0)  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (bytesLeft - 8 > 0)  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: if (bytesLeft - 8 > 0)  	LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: LastIncompleteRecord.FeedBytes (data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);  
Magic Number,FastCgiNet,RecordFactory,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,CreateRecordFromHeader,The following statement contains a magic number: if (offset + 8 > header.Length)  	throw new InsufficientBytesException ("There are not enough bytes in the array for a complete header. Make sure at least 8 bytes are available");  
Magic Number,FastCgiNet,AbortRequestRecord,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Records\AbortRequestRecord.cs,AbortRequestRecord,The following statement contains a magic number: endOfRecord = offset + 8 - 1;  
Magic Number,FastCgiNet.Streams,RecordContentsStream,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Streams\RecordContentsStream.cs,GetHashCode,The following statement contains a magic number: return length + 31 * MemoryBlocks.Take (1).Sum (mb => mb.GetHashCode ());  
Missing Default,FastCgiNet.Requests,FastCgiRequest,D:\newReposJune17\mzabani_FastCgiNet\FastCgiNet\Request\FastCgiRequest.cs,AddReceivedRecord,The following switch statement is missing a default case: switch (rec.RecordType) {  case RecordType.FCGIBeginRequest:  	// Make sure we are not getting a BeginRequest once again' as this could be serious.  	if (BeginRequestReceived)  		throw new InvalidOperationException ("A BeginRequest Record has already been received by this Request");  	BeginRequestReceived = true;  	RequestId = ((BeginRequestRecord)rec).RequestId;  	break;  case RecordType.FCGIEndRequest:  	// Make sure we are not getting a BeginRequest once again' as this could be serious.  	if (EndRequestReceived)  		throw new InvalidOperationException ("An EndRequest Record has already been received by this Request");  	EndRequestReceived = true;  	break;  case RecordType.FCGIParams:  	Params.AppendStream (((StreamRecordBase)rec).Contents);  	break;  case RecordType.FCGIStdin:  	Stdin.AppendStream (((StreamRecordBase)rec).Contents);  	break;  case RecordType.FCGIStdout:  	Stdout.AppendStream (((StreamRecordBase)rec).Contents);  	break;  case RecordType.FCGIStderr:  	Stderr.AppendStream (((StreamRecordBase)rec).Contents);  	break;  }  
