Implementation smell,Namespace,Class,File,Method,Description
Complex Method,FastCgiNet,NvpEnumerator,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpEnumerator.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,FastCgiNet.Streams,RecordContentsStream,C:\repos\mzabani_FastCgiNet\FastCgiNet\Streams\RecordContentsStream.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,FastCgiNet.Streams,SocketStream,C:\repos\mzabani_FastCgiNet\FastCgiNet\Streams\SocketStream.cs,Flush,Cyclomatic complexity of the method is 8
Long Parameter List,FastCgiNet,StreamRecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The method has 5 parameters. Parameters: recordType' data' offset' length' endOfRecord
Long Parameter List,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The method has 5 parameters. Parameters: firstData' offset' length' createdNvp' endOfNvp
Long Identifier,FastCgiNet.Requests,WebServerSocketRequest,C:\repos\mzabani_FastCgiNet\FastCgiNet\Request\WebServerSocketRequest.cs,SendBeginRequest,The length of the parameter applicationMustCloseConnection is 30.
Long Statement,FastCgiNet,RecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,Equals,The length of the statement  "			return RecordType == b.RecordType && RequestId == b.RequestId && ContentLength == b.ContentLength && Version == b.Version; " is 122.
Long Statement,FastCgiNet,ExtensionMethods,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordType.cs,IsStreamType,The length of the statement  "            return type == RecordType.FCGIStderr || type == RecordType.FCGIStdin || type == RecordType.FCGIStdout || type == RecordType.FCGIParams || type == RecordType.FCGIData; " is 166.
Long Statement,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The length of the statement  "                        if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord) " is 126.
Long Statement,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The length of the statement  "                            LastIncompleteRecord.FeedBytes(data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord); " is 133.
Long Statement,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The length of the statement  "                        if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord) " is 126.
Long Statement,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,CreateRecordFromHeader,The length of the statement  "                throw new InsufficientBytesException("There are not enough bytes in the array for a complete header. Make sure at least 8 bytes are available"); " is 144.
Long Statement,FastCgiNet.Streams,RecordContentsStream,C:\repos\mzabani_FastCgiNet\FastCgiNet\Streams\RecordContentsStream.cs,Write,The length of the statement  "				throw new InvalidOperationException("You can't write more than " + RecordBase.MaxContentLength + " bytes to a record's contents"); " is 130.
Long Statement,FastCgiNet.Streams,FastCgiStream,C:\repos\mzabani_FastCgiNet\FastCgiNet\Streams\FastCgiStream.cs,Write,The length of the statement  "                throw new InvalidOperationException("You can't write to this stream. You should either append a Record's Stream or initialize this stream with Read Mode = false"); " is 163.
Virtual Method Call from Constructor,FastCgiNet.Streams,FastCgiStream,C:\repos\mzabani_FastCgiNet\FastCgiNet\Streams\FastCgiStream.cs,FastCgiStream,The constructor "FastCgiStream" calls a virtual method "AppendStream".
Magic Number,FastCgiNet,RecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The following statement contains a magic number: Header = new byte[8];
Magic Number,FastCgiNet,RecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The following statement contains a magic number: if (length < 8 || data.Length < 8)  				throw new ArgumentException("The length available in the array must be at least 8 bytes");
Magic Number,FastCgiNet,RecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The following statement contains a magic number: if (length < 8 || data.Length < 8)  				throw new ArgumentException("The length available in the array must be at least 8 bytes");
Magic Number,FastCgiNet,RecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordBase.cs,RecordBase,The following statement contains a magic number: Array.Copy(data' offset' Header' 0' 8);
Magic Number,FastCgiNet,StreamRecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (ContentLength + PaddingLength == 0)                  endOfRecord = offset + 7;              else if (length > 8)                  FeedBytes(data' offset + 8' length - 8' out endOfRecord);              else                  endOfRecord = -1;
Magic Number,FastCgiNet,StreamRecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (ContentLength + PaddingLength == 0)                  endOfRecord = offset + 7;              else if (length > 8)                  FeedBytes(data' offset + 8' length - 8' out endOfRecord);              else                  endOfRecord = -1;
Magic Number,FastCgiNet,StreamRecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (ContentLength + PaddingLength == 0)                  endOfRecord = offset + 7;              else if (length > 8)                  FeedBytes(data' offset + 8' length - 8' out endOfRecord);              else                  endOfRecord = -1;
Magic Number,FastCgiNet,StreamRecordBase,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\StreamRecordBase.cs,StreamRecordBase,The following statement contains a magic number: if (ContentLength + PaddingLength == 0)                  endOfRecord = offset + 7;              else if (length > 8)                  FeedBytes(data' offset + 8' length - 8' out endOfRecord);              else                  endOfRecord = -1;
Magic Number,FastCgiNet,BeginRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,FeedBytes,The following statement contains a magic number: if (fedBytes == 8)  				throw new InvalidOperationException("The BeginRequest section of this record is complete.");
Magic Number,FastCgiNet,BeginRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,FeedBytes,The following statement contains a magic number: int bytesNeeded = 8 - fedBytes;
Magic Number,FastCgiNet,BeginRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,FeedBytes,The following statement contains a magic number: if (length >= bytesNeeded)  			{  				Array.Copy(data' offset' RoleAndFlags' fedBytes' bytesNeeded);  				fedBytes = 8;  				endOfRecord = offset + bytesNeeded - 1;  			}  			else  			{  				Array.Copy(data' offset' RoleAndFlags' fedBytes' length);  				fedBytes += length;  				endOfRecord = -1;  			}
Magic Number,FastCgiNet,BeginRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: RoleAndFlags = new byte[8];
Magic Number,FastCgiNet,BeginRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: RoleAndFlags = new byte[8];
Magic Number,FastCgiNet,BeginRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: if (length > 8)  				FeedBytes(data' offset + 8' length - 8' out endOfRecord);  			else  				endOfRecord = -1;
Magic Number,FastCgiNet,BeginRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: if (length > 8)  				FeedBytes(data' offset + 8' length - 8' out endOfRecord);  			else  				endOfRecord = -1;
Magic Number,FastCgiNet,BeginRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\BeginRequest\BeginRequestRecord.cs,BeginRequestRecord,The following statement contains a magic number: if (length > 8)  				FeedBytes(data' offset + 8' length - 8' out endOfRecord);  			else  				endOfRecord = -1;
Magic Number,FastCgiNet,EndRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,FeedBytes,The following statement contains a magic number: if (fedBytes == 5)  				throw new InvalidOperationException("The EndRequest section of this record is complete.");
Magic Number,FastCgiNet,EndRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,FeedBytes,The following statement contains a magic number: int bytesNeeded = 5 - fedBytes;
Magic Number,FastCgiNet,EndRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,FeedBytes,The following statement contains a magic number: if (length >= bytesNeeded)  			{  				Array.Copy(data' offset' AppAndProtocolStatus' fedBytes' bytesNeeded);  				fedBytes = 5;  				endOfRecord = offset + bytesNeeded - 1;  			}  			else  			{  				Array.Copy(data' offset' AppAndProtocolStatus' fedBytes' length);  				fedBytes += length;  				endOfRecord = -1;  			}
Magic Number,FastCgiNet,EndRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: AppAndProtocolStatus = new byte[5];
Magic Number,FastCgiNet,EndRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: AppAndProtocolStatus = new byte[5];
Magic Number,FastCgiNet,EndRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: if (length > 8)  				FeedBytes(data' offset + 8' length - 8' out endOfRecord);  			else  				endOfRecord = -1;
Magic Number,FastCgiNet,EndRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: if (length > 8)  				FeedBytes(data' offset + 8' length - 8' out endOfRecord);  			else  				endOfRecord = -1;
Magic Number,FastCgiNet,EndRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\EndRequest\EndRequestRecord.cs,EndRequestRecord,The following statement contains a magic number: if (length > 8)  				FeedBytes(data' offset + 8' length - 8' out endOfRecord);  			else  				endOfRecord = -1;
Magic Number,FastCgiNet,NvpEnumerator,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpEnumerator.cs,NvpEnumerator,The following statement contains a magic number: bufsize = 16;
Magic Number,FastCgiNet,NvpEnumerator,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpEnumerator.cs,NvpEnumerator,The following statement contains a magic number: bufSmall = new byte[8];
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr[offset] >> 7) == 0)  			{  				// 1 byte long  				if (length < 1)  					throw new InsufficientBytesException();    				return arr[offset];  			}  			else  			{  				// 4 bytes long  				if (length < 4)  					throw new InsufficientBytesException();    				return ((arr[offset] & 0x7f) << 24) + (arr[offset + 1] << 16) + (arr[offset + 2] << 8) + arr[offset + 3];  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr[offset] >> 7) == 0)  			{  				// 1 byte long  				if (length < 1)  					throw new InsufficientBytesException();    				return arr[offset];  			}  			else  			{  				// 4 bytes long  				if (length < 4)  					throw new InsufficientBytesException();    				return ((arr[offset] & 0x7f) << 24) + (arr[offset + 1] << 16) + (arr[offset + 2] << 8) + arr[offset + 3];  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr[offset] >> 7) == 0)  			{  				// 1 byte long  				if (length < 1)  					throw new InsufficientBytesException();    				return arr[offset];  			}  			else  			{  				// 4 bytes long  				if (length < 4)  					throw new InsufficientBytesException();    				return ((arr[offset] & 0x7f) << 24) + (arr[offset + 1] << 16) + (arr[offset + 2] << 8) + arr[offset + 3];  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr[offset] >> 7) == 0)  			{  				// 1 byte long  				if (length < 1)  					throw new InsufficientBytesException();    				return arr[offset];  			}  			else  			{  				// 4 bytes long  				if (length < 4)  					throw new InsufficientBytesException();    				return ((arr[offset] & 0x7f) << 24) + (arr[offset + 1] << 16) + (arr[offset + 2] << 8) + arr[offset + 3];  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr[offset] >> 7) == 0)  			{  				// 1 byte long  				if (length < 1)  					throw new InsufficientBytesException();    				return arr[offset];  			}  			else  			{  				// 4 bytes long  				if (length < 4)  					throw new InsufficientBytesException();    				return ((arr[offset] & 0x7f) << 24) + (arr[offset + 1] << 16) + (arr[offset + 2] << 8) + arr[offset + 3];  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr[offset] >> 7) == 0)  			{  				// 1 byte long  				if (length < 1)  					throw new InsufficientBytesException();    				return arr[offset];  			}  			else  			{  				// 4 bytes long  				if (length < 4)  					throw new InsufficientBytesException();    				return ((arr[offset] & 0x7f) << 24) + (arr[offset + 1] << 16) + (arr[offset + 2] << 8) + arr[offset + 3];  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,GetLengthFromByteArray,The following statement contains a magic number: if ((arr[offset] >> 7) == 0)  			{  				// 1 byte long  				if (length < 1)  					throw new InsufficientBytesException();    				return arr[offset];  			}  			else  			{  				// 4 bytes long  				if (length < 4)  					throw new InsufficientBytesException();    				return ((arr[offset] & 0x7f) << 24) + (arr[offset + 1] << 16) + (arr[offset + 2] << 8) + arr[offset + 3];  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: try  			{  				nameLength = GetLengthFromByteArray(firstData' offset' length);  				bytesRead = 0;  				  				if (nameLength > 0x7f)  				{  					bytesRead += 4;  					valueLength = GetLengthFromByteArray(firstData' offset + 4' length - 4);  				}  				else  				{  					bytesRead += 1;  					valueLength = GetLengthFromByteArray(firstData' offset + 1' length - 1);  				}  				bytesRead += (valueLength > 0x7f) ? 4 : 1;  			}  			catch (InsufficientBytesException)  			{  				endOfNvp = -1;  				createdNvp = null;  				return false;  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: try  			{  				nameLength = GetLengthFromByteArray(firstData' offset' length);  				bytesRead = 0;  				  				if (nameLength > 0x7f)  				{  					bytesRead += 4;  					valueLength = GetLengthFromByteArray(firstData' offset + 4' length - 4);  				}  				else  				{  					bytesRead += 1;  					valueLength = GetLengthFromByteArray(firstData' offset + 1' length - 1);  				}  				bytesRead += (valueLength > 0x7f) ? 4 : 1;  			}  			catch (InsufficientBytesException)  			{  				endOfNvp = -1;  				createdNvp = null;  				return false;  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: try  			{  				nameLength = GetLengthFromByteArray(firstData' offset' length);  				bytesRead = 0;  				  				if (nameLength > 0x7f)  				{  					bytesRead += 4;  					valueLength = GetLengthFromByteArray(firstData' offset + 4' length - 4);  				}  				else  				{  					bytesRead += 1;  					valueLength = GetLengthFromByteArray(firstData' offset + 1' length - 1);  				}  				bytesRead += (valueLength > 0x7f) ? 4 : 1;  			}  			catch (InsufficientBytesException)  			{  				endOfNvp = -1;  				createdNvp = null;  				return false;  			}
Magic Number,FastCgiNet,NvpFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NvpFactory.cs,TryCreateNvp,The following statement contains a magic number: try  			{  				nameLength = GetLengthFromByteArray(firstData' offset' length);  				bytesRead = 0;  				  				if (nameLength > 0x7f)  				{  					bytesRead += 4;  					valueLength = GetLengthFromByteArray(firstData' offset + 4' length - 4);  				}  				else  				{  					bytesRead += 1;  					valueLength = GetLengthFromByteArray(firstData' offset + 1' length - 1);  				}  				bytesRead += (valueLength > 0x7f) ? 4 : 1;  			}  			catch (InsufficientBytesException)  			{  				endOfNvp = -1;  				createdNvp = null;  				return false;  			}
Magic Number,FastCgiNet,NameValuePair,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: if (length < 128)  			{  				headerBytes = new byte[1] { (byte)length };  			}  			else  			{  				// MSB first    				headerBytes = new byte[4];  				headerBytes[3] = (byte) (length & 0xff000000);  				headerBytes[2] = (byte) (length & 0xff0000);  				headerBytes[1] = (byte) (length & 0xff00);  				headerBytes[0] = (byte) (length & 0xff);  			}
Magic Number,FastCgiNet,NameValuePair,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: if (length < 128)  			{  				headerBytes = new byte[1] { (byte)length };  			}  			else  			{  				// MSB first    				headerBytes = new byte[4];  				headerBytes[3] = (byte) (length & 0xff000000);  				headerBytes[2] = (byte) (length & 0xff0000);  				headerBytes[1] = (byte) (length & 0xff00);  				headerBytes[0] = (byte) (length & 0xff);  			}
Magic Number,FastCgiNet,NameValuePair,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: if (length < 128)  			{  				headerBytes = new byte[1] { (byte)length };  			}  			else  			{  				// MSB first    				headerBytes = new byte[4];  				headerBytes[3] = (byte) (length & 0xff000000);  				headerBytes[2] = (byte) (length & 0xff0000);  				headerBytes[1] = (byte) (length & 0xff00);  				headerBytes[0] = (byte) (length & 0xff);  			}
Magic Number,FastCgiNet,NameValuePair,C:\repos\mzabani_FastCgiNet\FastCgiNet\Nvp\NameValuePair.cs,GetHeaderBytes,The following statement contains a magic number: if (length < 128)  			{  				headerBytes = new byte[1] { (byte)length };  			}  			else  			{  				// MSB first    				headerBytes = new byte[4];  				headerBytes[3] = (byte) (length & 0xff000000);  				headerBytes[2] = (byte) (length & 0xff0000);  				headerBytes[1] = (byte) (length & 0xff00);  				headerBytes[0] = (byte) (length & 0xff);  			}
Magic Number,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead)  			{  				/*  				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know  				// if something is wrong  				if (bytesFed > bytesRead)  					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads.");  				*/    				int bytesLeft = bytesRead - bytesFed;  				int lastByteOfRecord;  				  				// Are we going to create a new record or feed the last incomplete one?  				if (LastIncompleteRecord == null)  				{  					if (NumUnusedBytes + bytesLeft < 8)  					{  						// We still can't make a full header with what we have. Save and return.  						Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  						NumUnusedBytes += bytesLeft;    						yield break;  					}                      else if (NumUnusedBytes > 0)                      {                          // We should use these bytes that haven't been fed yet                          int neededForFullHeader = 8 - NumUnusedBytes;                          Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);                            // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - neededForFullHeader > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);                      }                      else                      {                          // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - 8 > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);                      }  				}  				else  				{  					LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  				}  				  				// Check if we either created a complete record or fed that last incomplete one until its completion  				// If it is incomplete' then we must have fed all bytes read' and as such we should return.  				if (lastByteOfRecord == -1)  				{  					yield break;  				}    				RecordBase builtRecord = LastIncompleteRecord;  				LastIncompleteRecord = null;  				bytesFed = lastByteOfRecord + 1;  				  				// Tell all who are interested that we built a new record                  BuiltContentSize += builtRecord.ContentLength;  				yield return builtRecord;  			}
Magic Number,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead)  			{  				/*  				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know  				// if something is wrong  				if (bytesFed > bytesRead)  					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads.");  				*/    				int bytesLeft = bytesRead - bytesFed;  				int lastByteOfRecord;  				  				// Are we going to create a new record or feed the last incomplete one?  				if (LastIncompleteRecord == null)  				{  					if (NumUnusedBytes + bytesLeft < 8)  					{  						// We still can't make a full header with what we have. Save and return.  						Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  						NumUnusedBytes += bytesLeft;    						yield break;  					}                      else if (NumUnusedBytes > 0)                      {                          // We should use these bytes that haven't been fed yet                          int neededForFullHeader = 8 - NumUnusedBytes;                          Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);                            // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - neededForFullHeader > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);                      }                      else                      {                          // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - 8 > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);                      }  				}  				else  				{  					LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  				}  				  				// Check if we either created a complete record or fed that last incomplete one until its completion  				// If it is incomplete' then we must have fed all bytes read' and as such we should return.  				if (lastByteOfRecord == -1)  				{  					yield break;  				}    				RecordBase builtRecord = LastIncompleteRecord;  				LastIncompleteRecord = null;  				bytesFed = lastByteOfRecord + 1;  				  				// Tell all who are interested that we built a new record                  BuiltContentSize += builtRecord.ContentLength;  				yield return builtRecord;  			}
Magic Number,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead)  			{  				/*  				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know  				// if something is wrong  				if (bytesFed > bytesRead)  					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads.");  				*/    				int bytesLeft = bytesRead - bytesFed;  				int lastByteOfRecord;  				  				// Are we going to create a new record or feed the last incomplete one?  				if (LastIncompleteRecord == null)  				{  					if (NumUnusedBytes + bytesLeft < 8)  					{  						// We still can't make a full header with what we have. Save and return.  						Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  						NumUnusedBytes += bytesLeft;    						yield break;  					}                      else if (NumUnusedBytes > 0)                      {                          // We should use these bytes that haven't been fed yet                          int neededForFullHeader = 8 - NumUnusedBytes;                          Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);                            // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - neededForFullHeader > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);                      }                      else                      {                          // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - 8 > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);                      }  				}  				else  				{  					LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  				}  				  				// Check if we either created a complete record or fed that last incomplete one until its completion  				// If it is incomplete' then we must have fed all bytes read' and as such we should return.  				if (lastByteOfRecord == -1)  				{  					yield break;  				}    				RecordBase builtRecord = LastIncompleteRecord;  				LastIncompleteRecord = null;  				bytesFed = lastByteOfRecord + 1;  				  				// Tell all who are interested that we built a new record                  BuiltContentSize += builtRecord.ContentLength;  				yield return builtRecord;  			}
Magic Number,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead)  			{  				/*  				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know  				// if something is wrong  				if (bytesFed > bytesRead)  					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads.");  				*/    				int bytesLeft = bytesRead - bytesFed;  				int lastByteOfRecord;  				  				// Are we going to create a new record or feed the last incomplete one?  				if (LastIncompleteRecord == null)  				{  					if (NumUnusedBytes + bytesLeft < 8)  					{  						// We still can't make a full header with what we have. Save and return.  						Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  						NumUnusedBytes += bytesLeft;    						yield break;  					}                      else if (NumUnusedBytes > 0)                      {                          // We should use these bytes that haven't been fed yet                          int neededForFullHeader = 8 - NumUnusedBytes;                          Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);                            // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - neededForFullHeader > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);                      }                      else                      {                          // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - 8 > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);                      }  				}  				else  				{  					LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  				}  				  				// Check if we either created a complete record or fed that last incomplete one until its completion  				// If it is incomplete' then we must have fed all bytes read' and as such we should return.  				if (lastByteOfRecord == -1)  				{  					yield break;  				}    				RecordBase builtRecord = LastIncompleteRecord;  				LastIncompleteRecord = null;  				bytesFed = lastByteOfRecord + 1;  				  				// Tell all who are interested that we built a new record                  BuiltContentSize += builtRecord.ContentLength;  				yield return builtRecord;  			}
Magic Number,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead)  			{  				/*  				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know  				// if something is wrong  				if (bytesFed > bytesRead)  					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads.");  				*/    				int bytesLeft = bytesRead - bytesFed;  				int lastByteOfRecord;  				  				// Are we going to create a new record or feed the last incomplete one?  				if (LastIncompleteRecord == null)  				{  					if (NumUnusedBytes + bytesLeft < 8)  					{  						// We still can't make a full header with what we have. Save and return.  						Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  						NumUnusedBytes += bytesLeft;    						yield break;  					}                      else if (NumUnusedBytes > 0)                      {                          // We should use these bytes that haven't been fed yet                          int neededForFullHeader = 8 - NumUnusedBytes;                          Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);                            // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - neededForFullHeader > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);                      }                      else                      {                          // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - 8 > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);                      }  				}  				else  				{  					LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  				}  				  				// Check if we either created a complete record or fed that last incomplete one until its completion  				// If it is incomplete' then we must have fed all bytes read' and as such we should return.  				if (lastByteOfRecord == -1)  				{  					yield break;  				}    				RecordBase builtRecord = LastIncompleteRecord;  				LastIncompleteRecord = null;  				bytesFed = lastByteOfRecord + 1;  				  				// Tell all who are interested that we built a new record                  BuiltContentSize += builtRecord.ContentLength;  				yield return builtRecord;  			}
Magic Number,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead)  			{  				/*  				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know  				// if something is wrong  				if (bytesFed > bytesRead)  					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads.");  				*/    				int bytesLeft = bytesRead - bytesFed;  				int lastByteOfRecord;  				  				// Are we going to create a new record or feed the last incomplete one?  				if (LastIncompleteRecord == null)  				{  					if (NumUnusedBytes + bytesLeft < 8)  					{  						// We still can't make a full header with what we have. Save and return.  						Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  						NumUnusedBytes += bytesLeft;    						yield break;  					}                      else if (NumUnusedBytes > 0)                      {                          // We should use these bytes that haven't been fed yet                          int neededForFullHeader = 8 - NumUnusedBytes;                          Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);                            // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - neededForFullHeader > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);                      }                      else                      {                          // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - 8 > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);                      }  				}  				else  				{  					LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  				}  				  				// Check if we either created a complete record or fed that last incomplete one until its completion  				// If it is incomplete' then we must have fed all bytes read' and as such we should return.  				if (lastByteOfRecord == -1)  				{  					yield break;  				}    				RecordBase builtRecord = LastIncompleteRecord;  				LastIncompleteRecord = null;  				bytesFed = lastByteOfRecord + 1;  				  				// Tell all who are interested that we built a new record                  BuiltContentSize += builtRecord.ContentLength;  				yield return builtRecord;  			}
Magic Number,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,Read,The following statement contains a magic number: while (bytesFed < bytesRead)  			{  				/*  				//TODO: Until we are 100% certain this loop works without any flaws' let's keep this so that we easily know  				// if something is wrong  				if (bytesFed > bytesRead)  					throw new InvalidOperationException("The loop is badly wrong. It feeds more bytes than it reads.");  				*/    				int bytesLeft = bytesRead - bytesFed;  				int lastByteOfRecord;  				  				// Are we going to create a new record or feed the last incomplete one?  				if (LastIncompleteRecord == null)  				{  					if (NumUnusedBytes + bytesLeft < 8)  					{  						// We still can't make a full header with what we have. Save and return.  						Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' bytesLeft);  						NumUnusedBytes += bytesLeft;    						yield break;  					}                      else if (NumUnusedBytes > 0)                      {                          // We should use these bytes that haven't been fed yet                          int neededForFullHeader = 8 - NumUnusedBytes;                          Array.Copy(data.Array' data.Offset + bytesFed' ReceivedButUnusedBytes' NumUnusedBytes' neededForFullHeader);                            // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(ReceivedButUnusedBytes' 0' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - neededForFullHeader > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + neededForFullHeader' bytesLeft - neededForFullHeader' out lastByteOfRecord);                      }                      else                      {                          // We must not forget to store this record's contents in secondary storage if it's going to surpass our in-memory limit                          LastIncompleteRecord = CreateRecordFromHeader(data.Array' data.Offset + bytesFed' 8' out lastByteOfRecord);                          if (LastIncompleteRecord.ContentLength + BuiltContentSize > MaxInMemoryContentSize && LastIncompleteRecord.IsByteStreamRecord)                              ((StreamRecordBase)LastIncompleteRecord).Contents = new RecordContentsStream(secondaryStorageStream);                          if (bytesLeft - 8 > 0)                              LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed + 8' bytesLeft - 8' out lastByteOfRecord);                      }  				}  				else  				{  					LastIncompleteRecord.FeedBytes(data.Array' data.Offset + bytesFed' bytesLeft' out lastByteOfRecord);  				}  				  				// Check if we either created a complete record or fed that last incomplete one until its completion  				// If it is incomplete' then we must have fed all bytes read' and as such we should return.  				if (lastByteOfRecord == -1)  				{  					yield break;  				}    				RecordBase builtRecord = LastIncompleteRecord;  				LastIncompleteRecord = null;  				bytesFed = lastByteOfRecord + 1;  				  				// Tell all who are interested that we built a new record                  BuiltContentSize += builtRecord.ContentLength;  				yield return builtRecord;  			}
Magic Number,FastCgiNet,RecordFactory,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\RecordFactory.cs,CreateRecordFromHeader,The following statement contains a magic number: if (offset + 8 > header.Length)                  throw new InsufficientBytesException("There are not enough bytes in the array for a complete header. Make sure at least 8 bytes are available");
Magic Number,FastCgiNet,AbortRequestRecord,C:\repos\mzabani_FastCgiNet\FastCgiNet\Records\AbortRequestRecord.cs,AbortRequestRecord,The following statement contains a magic number: endOfRecord = offset + 8 - 1;
Magic Number,FastCgiNet.Streams,RecordContentsStream,C:\repos\mzabani_FastCgiNet\FastCgiNet\Streams\RecordContentsStream.cs,Equals,The following statement contains a magic number: byte[] bufForB = new byte[128];
Magic Number,FastCgiNet.Streams,RecordContentsStream,C:\repos\mzabani_FastCgiNet\FastCgiNet\Streams\RecordContentsStream.cs,Equals,The following statement contains a magic number: byte[] bufForA = new byte[128];
Magic Number,FastCgiNet.Streams,RecordContentsStream,C:\repos\mzabani_FastCgiNet\FastCgiNet\Streams\RecordContentsStream.cs,GetHashCode,The following statement contains a magic number: return length + 31 * MemoryBlocks.Take(1).Sum(mb => mb.GetHashCode());
Missing Default,FastCgiNet.Requests,FastCgiRequest,C:\repos\mzabani_FastCgiNet\FastCgiNet\Request\FastCgiRequest.cs,AddReceivedRecord,The following switch statement is missing a default case: switch (rec.RecordType)              {                  case RecordType.FCGIBeginRequest:                      // Make sure we are not getting a BeginRequest once again' as this could be serious.                      if (BeginRequestReceived)                          throw new InvalidOperationException("A BeginRequest Record has already been received by this Request");                        BeginRequestReceived = true;                      RequestId = ((BeginRequestRecord)rec).RequestId;                      break;                    case RecordType.FCGIEndRequest:                      // Make sure we are not getting a BeginRequest once again' as this could be serious.                      if (EndRequestReceived)                          throw new InvalidOperationException("An EndRequest Record has already been received by this Request");                                            EndRequestReceived = true;                      break;                    case RecordType.FCGIParams:                      Params.AppendStream(((StreamRecordBase)rec).Contents);                      break;                  case RecordType.FCGIStdin:                      Stdin.AppendStream(((StreamRecordBase)rec).Contents);                      break;                  case RecordType.FCGIStdout:                      Stdout.AppendStream(((StreamRecordBase)rec).Contents);                      break;                  case RecordType.FCGIStderr:                      Stderr.AppendStream(((StreamRecordBase)rec).Contents);                      break;              }
