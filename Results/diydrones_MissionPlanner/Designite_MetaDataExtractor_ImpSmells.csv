Implementation smell,Namespace,Class,File,Method,Description
Long Method,com.codec.jpeg,JPEGHuffmanTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGHuffmanTable.cs,InitStdACLuminance,The method has 191 lines of code.
Long Method,com.codec.jpeg,JPEGHuffmanTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGHuffmanTable.cs,InitStdACChrominance,The method has 191 lines of code.
Long Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetDescription,The method has 132 lines of code.
Long Method,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The method has 115 lines of code.
Long Method,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The method has 110 lines of code.
Long Method,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The method has 116 lines of code.
Complex Method,com.codec.jpeg,JPEGHuffmanTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGHuffmanTable.cs,JPEGHuffmanTable,Cyclomatic complexity of the method is 9
Complex Method,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetInt,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetStringArray,Cyclomatic complexity of the method is 10
Complex Method,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetIntArray,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetByteArray,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetString,Cyclomatic complexity of the method is 12
Complex Method,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetDescription,Cyclomatic complexity of the method is 40
Complex Method,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetWhiteBalanceDescription,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetExposureModeDescription,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetIsoDescription,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,Cyclomatic complexity of the method is 14
Complex Method,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusMode1Description,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashModeDescription,Cyclomatic complexity of the method is 10
Complex Method,com.drew.metadata.exif,CanonDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDirectory.cs,SetIntArray,Cyclomatic complexity of the method is 13
Complex Method,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetDescription,Cyclomatic complexity of the method is 13
Complex Method,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetCcdSensitivityDescription,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetWhiteBalanceDescription,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetDescription,Cyclomatic complexity of the method is 29
Complex Method,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetWhiteBalance1Description,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetImageSizeDescription,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetDescription,Cyclomatic complexity of the method is 13
Complex Method,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetWhiteBalanceDescription,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetDescription,Cyclomatic complexity of the method is 64
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetNewSubfileTypeDescription,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureProgramDescription,Cyclomatic complexity of the method is 10
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,Cyclomatic complexity of the method is 16
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,Cyclomatic complexity of the method is 29
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,Cyclomatic complexity of the method is 14
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetMeteringModeDescription,Cyclomatic complexity of the method is 10
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetOrientationDescription,Cyclomatic complexity of the method is 10
Complex Method,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSensingMethodDescription,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,Cyclomatic complexity of the method is 26
Complex Method,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,Cyclomatic complexity of the method is 19
Complex Method,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,Cyclomatic complexity of the method is 48
Complex Method,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetDescription,Cyclomatic complexity of the method is 15
Complex Method,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetPictureModeDescription,Cyclomatic complexity of the method is 10
Complex Method,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetWhiteBalanceDescription,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,GpsDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\GpsDescriptor.cs,GetDescription,Cyclomatic complexity of the method is 16
Complex Method,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetDescription,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetWhiteBalanceDescription,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetQualityDescription,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetDescription,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFocusPositionDescription,Cyclomatic complexity of the method is 8
Complex Method,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetSpecialModeDescription,Cyclomatic complexity of the method is 32
Complex Method,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,Extract,Cyclomatic complexity of the method is 9
Complex Method,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,Cyclomatic complexity of the method is 16
Complex Method,com.drew.metadata.jpeg,JpegDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegDescriptor.cs,GetDescription,Cyclomatic complexity of the method is 8
Complex Method,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,Cyclomatic complexity of the method is 11
Complex Method,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,CreateTag,Cyclomatic complexity of the method is 24
Long Parameter List,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The method has 5 parameters.
Long Parameter List,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The method has 5 parameters.
Long Parameter List,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,Open,The method has 5 parameters.
Long Parameter List,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,Open,The method has 7 parameters.
Long Parameter List,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,Open,The method has 5 parameters.
Long Statement,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The length of the statement  "				throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X")); " is 163.
Long Statement,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,IsInteger,The length of the statement  "	return (this.denominator == 1 || (this.denominator != 0 && (this.numerator % this.denominator == 0)) || (this.denominator == 0 && this.numerator == 0)); " is 152.
Long Statement,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetInt,The length of the statement  "			throw new MetadataException ("Unable to parse as int object of type:'" + lcObj.GetType () + "' that look like:'" + lcObj.ToString () + "'"' e); " is 143.
Long Statement,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetDouble,The length of the statement  "			throw new MetadataException ("Unable to parse as double object of type:'" + lcObj.GetType () + "' that look like:'" + lcObj.ToString () + "'"' e); " is 146.
Long Statement,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetFloat,The length of the statement  "			throw new MetadataException ("Unable to parse as float object of type:'" + lcObj.GetType () + "' that look like:'" + lcObj.ToString () + "'"' e); " is 145.
Long Statement,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetLong,The length of the statement  "			throw new MetadataException ("Unable to parse as long object of type:'" + lcObj.GetType () + "' that look like:'" + lcObj.ToString () + "'"' e); " is 144.
Long Statement,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetBoolean,The length of the statement  "			throw new MetadataException ("Unable to parse as boolean object of type:'" + lcObj.GetType () + "' that look like:'" + lcObj.ToString () + "'"' e); " is 147.
Long Statement,com.drew.metadata,Metadata,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\Metadata.cs,GetDirectory,The length of the statement  "		throw new ArgumentException ("Class type passed to GetDirectory must be an implementation of com.drew.metadata.AbstractDirectory"); " is 131.
Long Statement,com.drew.metadata,Tag,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\Tag.cs,GetTagValue,The length of the statement  "	if (this.tagType == ExifDirectory.TAG_DATETIME || this.tagType == ExifDirectory.TAG_DATETIME_DIGITIZED || this.tagType == ExifDirectory.TAG_DATETIME_ORIGINAL || this.tagType == IptcDirectory.TAG_DATE_CREATED) { " is 210.
Long Statement,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetFocalPlaneXResolutionDescription,The length of the statement  "	return BUNDLE ["FOCAL_PLANE"' lcRational.GetReciprocal ().ToSimpleString (allowDecimalRepresentationOfRationals)' GetFocalPlaneResolutionUnitDescription ().ToLower ()]; " is 168.
Long Statement,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetFocalPlaneYResolutionDescription,The length of the statement  "	return BUNDLE ["FOCAL_PLANE"' lcRational.GetReciprocal ().ToSimpleString (allowDecimalRepresentationOfRationals)' GetFocalPlaneResolutionUnitDescription ().ToLower ()]; " is 168.
Long Statement,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetYResolutionDescription,The length of the statement  "	return BUNDLE ["DOTS_PER"' lcResolution.ToSimpleString (allowDecimalRepresentationOfRationals)' GetResolutionDescription ().ToLower ()]; " is 136.
Long Statement,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetXResolutionDescription,The length of the statement  "	return BUNDLE ["DOTS_PER"' lcResolution.ToSimpleString (allowDecimalRepresentationOfRationals)' GetResolutionDescription ().ToLower ()]; " is 136.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,StoreThumbnailBytes,The length of the statement  "	if (!exifDirectory.ContainsTag (ExifDirectory.TAG_THUMBNAIL_LENGTH) || !exifDirectory.ContainsTag (ExifDirectory.TAG_THUMBNAIL_OFFSET)) { " is 137.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,The length of the statement  "	// check for directories we've already visited to avoid stack overflows when recursive/cyclic directory structures exist " is 120.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,The length of the statement  "			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.ExifDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset); " is 146.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,The length of the statement  "			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.ExifInteropDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset); " is 153.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,The length of the statement  "			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.GpsDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset); " is 145.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,The length of the statement  "			Trace.TraceWarning ("Last 4 bytes of IFD reference another IFD with an address that is out of bounds\nNote this could have been caused by jhead 1.3 cropping too much"); " is 168.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,The length of the statement  "			Trace.TraceWarning ("Last 4 bytes of IFD reference another IFD with an address that is before the start of this directory"); " is 124.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset); " is 153.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "				ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset); " is 156.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "				ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10); " is 158.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset); " is 152.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset); " is 151.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset); " is 152.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset); " is 147.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset); " is 156.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset); " is 152.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset); " is 146.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset); " is 149.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "	} else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) { " is 149.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset); " is 154.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset); " is 156.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset); " is 152.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "	} else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) { " is 130.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The length of the statement  "		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset); " is 144.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get16Bits,The length of the statement  "		throw new IndexOutOfRangeException ("attempt to read data outside of exif segment (index " + offSet + " where max index is " + (base.data.Length - 1) + ")"); " is 157.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The length of the statement  "		throw new IndexOutOfRangeException ("attempt to read data outside of exif segment (index " + offSet + " where max index is " + (base.data.Length - 1) + ")"); " is 157.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The length of the statement  "		return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF))); " is 205.
Long Statement,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The length of the statement  "		return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF))); " is 205.
Long Statement,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,FindFileNames,The length of the statement  "		if (AS_XML.Equals (someArgs [i]' StringComparison.OrdinalIgnoreCase) || NO_UNKNOWN.Equals (someArgs [i]' StringComparison.OrdinalIgnoreCase) || DO_SUB.Equals (someArgs [i]' StringComparison.OrdinalIgnoreCase)) { " is 211.
Long Statement,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The length of the statement  "		Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ and img1.jpg and img2.jpg info as text:"); " is 125.
Long Statement,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The length of the statement  "		Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\Temp\\ and all its subdirectories as XML but with no unkown tags:"); " is 150.
Long Statement,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The length of the statement  "		Console.Error.WriteLine ("     - Will put in a file called sample.xml all c:\\Temp\\ *.jpg|*.raw|*.cr2|*.crw and all its subdirectories as XML but with no unkown tags:"); " is 170.
Long Statement,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The length of the statement  "				if (lcFileName.ToLower ().EndsWith (".raw") || lcFileName.ToLower ().EndsWith (".cr2") || lcFileName.ToLower ().EndsWith (".crw")) { " is 132.
Long Statement,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,CreateTag,The length of the statement  "		if (!this.DoUnknown && (lcName.ToLower ().StartsWith ("unknown") || (lcDescription != null && lcDescription.ToLower ().StartsWith ("unknown")))) { " is 146.
Long Statement,com.utils,Utils,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\Utils.cs,SearchAllFileIn,The length of the statement  "		string[] lc2List = Directory.GetFiles (aRootDirectory' aSearchPattern' (doRecurse) ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly); " is 146.
Complex Conditional,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The conditional expression  "(lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)"  is complex.
Complex Conditional,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetInt,The conditional expression  "lcObj is int || lcObj is byte || lcObj is long || lcObj is float || lcObj is double"  is complex.
Complex Conditional,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetDouble,The conditional expression  "lcObj is double || lcObj is string || lcObj is int || lcObj is byte || lcObj is long || lcObj is float"  is complex.
Complex Conditional,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetFloat,The conditional expression  "lcObj is float || lcObj is string || lcObj is int || lcObj is byte || lcObj is long || lcObj is double"  is complex.
Complex Conditional,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetLong,The conditional expression  "lcObj is long || lcObj is string || lcObj is int || lcObj is byte || lcObj is double || lcObj is double"  is complex.
Complex Conditional,com.drew.metadata,Tag,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\Tag.cs,GetTagValue,The conditional expression  "this.tagType == ExifDirectory.TAG_DATETIME || this.tagType == ExifDirectory.TAG_DATETIME_DIGITIZED || this.tagType == ExifDirectory.TAG_DATETIME_ORIGINAL || this.tagType == IptcDirectory.TAG_DATE_CREATED"  is complex.
Complex Conditional,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The conditional expression  ""KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)"  is complex.
Complex Conditional,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFocusPositionDescription,The conditional expression  "values.Length != 4 || values [0] != 0 || values [2] != 0 || values [3] != 0"  is complex.
Complex Conditional,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,CreateTag,The conditional expression  "!this.DoUnknown && (lcName.ToLower ().StartsWith ("unknown") || (lcDescription != null && lcDescription.ToLower ().StartsWith ("unknown")))"  is complex.
Empty Catch Block,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetDate,The method has an empty catch block.
Empty Catch Block,com.drew.metadata,Tag,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\Tag.cs,GetTagValue,The method has an empty catch block.
Empty Catch Block,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The method has an empty catch block.
Empty Catch Block,com.utils.xml,TxtOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\TxtOutPutStreamHandler.cs,CreateTag,The method has an empty catch block.
Magic Number,com.codec.jpeg,JPEGHuffmanTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGHuffmanTable.cs,checkTable,The following statement contains a magic number: for (int i = 1; i < lengths.Length; i++) {  	sum += lengths [i];  	numVals -= lengths [i];  	numVals *= 2;  }  
Magic Number,com.codec.jpeg,JPEGHuffmanTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGHuffmanTable.cs,checkTable,The following statement contains a magic number: numVals *= 2;  
Magic Number,com.codec.jpeg,JPEGQTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGQTable.cs,GetScaledInstance,The following statement contains a magic number: for (int i = 0; i < QTABLESIZE; i++) {  	long holder = (long)((quantval [i] * scaleFactor) + 0.5);  	// limit to valid range  	if (holder <= 0L)  		holder = 1L;  	// Max quantizer for 12 bits  	if (holder > max)  		holder = max;  	ret [i] = (int)holder;  }  
Magic Number,com.drew.imaging.jpg,JpegSegmentData,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentData.cs,JpegSegmentData,The following statement contains a magic number: this.segmentDataMap = new Dictionary<byte' IList<byte[]>> (10);  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: try {  	int lcOffset = 0;  	// first two bytes should be jpeg magic number  	if (!this.IsValidJpegHeaderBytes (lcInStream)) {  		throw new JpegProcessingException ("not a jpeg file");  	}  	lcOffset += 2;  	do {  		// next byte is 0xFF  		byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  		if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  			throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  		}  		lcOffset++;  		// next byte is <segment-marker>  		byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  		lcOffset++;  		// next 2-bytes are <segment-size>: [high-byte] [low-byte]  		byte[] lcSegmentLengthBytes = new byte[2];  		lcInStream.Read (lcSegmentLengthBytes' 0' 2);  		lcOffset += 2;  		int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  		// segment length includes size bytes' so subtract two  		lcSegmentLength -= 2;  		if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  			throw new JpegProcessingException ("segment size would extend beyond file stream length");  		} else if (lcSegmentLength < 0) {  			throw new JpegProcessingException ("segment size would be less than zero");  		}  		byte[] lcSegmentBytes = new byte[lcSegmentLength];  		lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  		lcOffset += lcSegmentLength;  		if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  			// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  			// have to search for the two bytes: 0xFF 0xD9 (EOI).  			// It comes last so simply return at this point  			return;  		} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  			// the 'End-Of-Image' segment -- this should never be found in this fashion  			return;  		} else {  			this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  		}  		// didn't find the one we're looking for' loop through to the next segment  	} while (true);  } catch (IOException ioe) {  	//throw new JpegProcessingException("IOException processing Jpeg aFile"' ioe);  	throw new JpegProcessingException ("IOException processing Jpeg file: " + ioe.Message' ioe);  } finally {  	if (lcInStream != null) {  		lcInStream.Close ();  		lcInStream.Dispose ();  	}  }  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: try {  	int lcOffset = 0;  	// first two bytes should be jpeg magic number  	if (!this.IsValidJpegHeaderBytes (lcInStream)) {  		throw new JpegProcessingException ("not a jpeg file");  	}  	lcOffset += 2;  	do {  		// next byte is 0xFF  		byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  		if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  			throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  		}  		lcOffset++;  		// next byte is <segment-marker>  		byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  		lcOffset++;  		// next 2-bytes are <segment-size>: [high-byte] [low-byte]  		byte[] lcSegmentLengthBytes = new byte[2];  		lcInStream.Read (lcSegmentLengthBytes' 0' 2);  		lcOffset += 2;  		int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  		// segment length includes size bytes' so subtract two  		lcSegmentLength -= 2;  		if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  			throw new JpegProcessingException ("segment size would extend beyond file stream length");  		} else if (lcSegmentLength < 0) {  			throw new JpegProcessingException ("segment size would be less than zero");  		}  		byte[] lcSegmentBytes = new byte[lcSegmentLength];  		lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  		lcOffset += lcSegmentLength;  		if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  			// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  			// have to search for the two bytes: 0xFF 0xD9 (EOI).  			// It comes last so simply return at this point  			return;  		} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  			// the 'End-Of-Image' segment -- this should never be found in this fashion  			return;  		} else {  			this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  		}  		// didn't find the one we're looking for' loop through to the next segment  	} while (true);  } catch (IOException ioe) {  	//throw new JpegProcessingException("IOException processing Jpeg aFile"' ioe);  	throw new JpegProcessingException ("IOException processing Jpeg file: " + ioe.Message' ioe);  } finally {  	if (lcInStream != null) {  		lcInStream.Close ();  		lcInStream.Dispose ();  	}  }  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: try {  	int lcOffset = 0;  	// first two bytes should be jpeg magic number  	if (!this.IsValidJpegHeaderBytes (lcInStream)) {  		throw new JpegProcessingException ("not a jpeg file");  	}  	lcOffset += 2;  	do {  		// next byte is 0xFF  		byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  		if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  			throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  		}  		lcOffset++;  		// next byte is <segment-marker>  		byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  		lcOffset++;  		// next 2-bytes are <segment-size>: [high-byte] [low-byte]  		byte[] lcSegmentLengthBytes = new byte[2];  		lcInStream.Read (lcSegmentLengthBytes' 0' 2);  		lcOffset += 2;  		int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  		// segment length includes size bytes' so subtract two  		lcSegmentLength -= 2;  		if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  			throw new JpegProcessingException ("segment size would extend beyond file stream length");  		} else if (lcSegmentLength < 0) {  			throw new JpegProcessingException ("segment size would be less than zero");  		}  		byte[] lcSegmentBytes = new byte[lcSegmentLength];  		lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  		lcOffset += lcSegmentLength;  		if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  			// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  			// have to search for the two bytes: 0xFF 0xD9 (EOI).  			// It comes last so simply return at this point  			return;  		} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  			// the 'End-Of-Image' segment -- this should never be found in this fashion  			return;  		} else {  			this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  		}  		// didn't find the one we're looking for' loop through to the next segment  	} while (true);  } catch (IOException ioe) {  	//throw new JpegProcessingException("IOException processing Jpeg aFile"' ioe);  	throw new JpegProcessingException ("IOException processing Jpeg file: " + ioe.Message' ioe);  } finally {  	if (lcInStream != null) {  		lcInStream.Close ();  		lcInStream.Dispose ();  	}  }  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: try {  	int lcOffset = 0;  	// first two bytes should be jpeg magic number  	if (!this.IsValidJpegHeaderBytes (lcInStream)) {  		throw new JpegProcessingException ("not a jpeg file");  	}  	lcOffset += 2;  	do {  		// next byte is 0xFF  		byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  		if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  			throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  		}  		lcOffset++;  		// next byte is <segment-marker>  		byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  		lcOffset++;  		// next 2-bytes are <segment-size>: [high-byte] [low-byte]  		byte[] lcSegmentLengthBytes = new byte[2];  		lcInStream.Read (lcSegmentLengthBytes' 0' 2);  		lcOffset += 2;  		int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  		// segment length includes size bytes' so subtract two  		lcSegmentLength -= 2;  		if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  			throw new JpegProcessingException ("segment size would extend beyond file stream length");  		} else if (lcSegmentLength < 0) {  			throw new JpegProcessingException ("segment size would be less than zero");  		}  		byte[] lcSegmentBytes = new byte[lcSegmentLength];  		lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  		lcOffset += lcSegmentLength;  		if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  			// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  			// have to search for the two bytes: 0xFF 0xD9 (EOI).  			// It comes last so simply return at this point  			return;  		} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  			// the 'End-Of-Image' segment -- this should never be found in this fashion  			return;  		} else {  			this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  		}  		// didn't find the one we're looking for' loop through to the next segment  	} while (true);  } catch (IOException ioe) {  	//throw new JpegProcessingException("IOException processing Jpeg aFile"' ioe);  	throw new JpegProcessingException ("IOException processing Jpeg file: " + ioe.Message' ioe);  } finally {  	if (lcInStream != null) {  		lcInStream.Close ();  		lcInStream.Dispose ();  	}  }  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: try {  	int lcOffset = 0;  	// first two bytes should be jpeg magic number  	if (!this.IsValidJpegHeaderBytes (lcInStream)) {  		throw new JpegProcessingException ("not a jpeg file");  	}  	lcOffset += 2;  	do {  		// next byte is 0xFF  		byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  		if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  			throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  		}  		lcOffset++;  		// next byte is <segment-marker>  		byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  		lcOffset++;  		// next 2-bytes are <segment-size>: [high-byte] [low-byte]  		byte[] lcSegmentLengthBytes = new byte[2];  		lcInStream.Read (lcSegmentLengthBytes' 0' 2);  		lcOffset += 2;  		int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  		// segment length includes size bytes' so subtract two  		lcSegmentLength -= 2;  		if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  			throw new JpegProcessingException ("segment size would extend beyond file stream length");  		} else if (lcSegmentLength < 0) {  			throw new JpegProcessingException ("segment size would be less than zero");  		}  		byte[] lcSegmentBytes = new byte[lcSegmentLength];  		lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  		lcOffset += lcSegmentLength;  		if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  			// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  			// have to search for the two bytes: 0xFF 0xD9 (EOI).  			// It comes last so simply return at this point  			return;  		} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  			// the 'End-Of-Image' segment -- this should never be found in this fashion  			return;  		} else {  			this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  		}  		// didn't find the one we're looking for' loop through to the next segment  	} while (true);  } catch (IOException ioe) {  	//throw new JpegProcessingException("IOException processing Jpeg aFile"' ioe);  	throw new JpegProcessingException ("IOException processing Jpeg file: " + ioe.Message' ioe);  } finally {  	if (lcInStream != null) {  		lcInStream.Close ();  		lcInStream.Dispose ();  	}  }  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: try {  	int lcOffset = 0;  	// first two bytes should be jpeg magic number  	if (!this.IsValidJpegHeaderBytes (lcInStream)) {  		throw new JpegProcessingException ("not a jpeg file");  	}  	lcOffset += 2;  	do {  		// next byte is 0xFF  		byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  		if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  			throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  		}  		lcOffset++;  		// next byte is <segment-marker>  		byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  		lcOffset++;  		// next 2-bytes are <segment-size>: [high-byte] [low-byte]  		byte[] lcSegmentLengthBytes = new byte[2];  		lcInStream.Read (lcSegmentLengthBytes' 0' 2);  		lcOffset += 2;  		int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  		// segment length includes size bytes' so subtract two  		lcSegmentLength -= 2;  		if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  			throw new JpegProcessingException ("segment size would extend beyond file stream length");  		} else if (lcSegmentLength < 0) {  			throw new JpegProcessingException ("segment size would be less than zero");  		}  		byte[] lcSegmentBytes = new byte[lcSegmentLength];  		lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  		lcOffset += lcSegmentLength;  		if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  			// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  			// have to search for the two bytes: 0xFF 0xD9 (EOI).  			// It comes last so simply return at this point  			return;  		} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  			// the 'End-Of-Image' segment -- this should never be found in this fashion  			return;  		} else {  			this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  		}  		// didn't find the one we're looking for' loop through to the next segment  	} while (true);  } catch (IOException ioe) {  	//throw new JpegProcessingException("IOException processing Jpeg aFile"' ioe);  	throw new JpegProcessingException ("IOException processing Jpeg file: " + ioe.Message' ioe);  } finally {  	if (lcInStream != null) {  		lcInStream.Close ();  		lcInStream.Dispose ();  	}  }  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: lcOffset += 2;  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: do {  	// next byte is 0xFF  	byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  	if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  		throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  	}  	lcOffset++;  	// next byte is <segment-marker>  	byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  	lcOffset++;  	// next 2-bytes are <segment-size>: [high-byte] [low-byte]  	byte[] lcSegmentLengthBytes = new byte[2];  	lcInStream.Read (lcSegmentLengthBytes' 0' 2);  	lcOffset += 2;  	int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  	// segment length includes size bytes' so subtract two  	lcSegmentLength -= 2;  	if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  		throw new JpegProcessingException ("segment size would extend beyond file stream length");  	} else if (lcSegmentLength < 0) {  		throw new JpegProcessingException ("segment size would be less than zero");  	}  	byte[] lcSegmentBytes = new byte[lcSegmentLength];  	lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  	lcOffset += lcSegmentLength;  	if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  		// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  		// have to search for the two bytes: 0xFF 0xD9 (EOI).  		// It comes last so simply return at this point  		return;  	} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  		// the 'End-Of-Image' segment -- this should never be found in this fashion  		return;  	} else {  		this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  	}  	// didn't find the one we're looking for' loop through to the next segment  } while (true);  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: do {  	// next byte is 0xFF  	byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  	if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  		throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  	}  	lcOffset++;  	// next byte is <segment-marker>  	byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  	lcOffset++;  	// next 2-bytes are <segment-size>: [high-byte] [low-byte]  	byte[] lcSegmentLengthBytes = new byte[2];  	lcInStream.Read (lcSegmentLengthBytes' 0' 2);  	lcOffset += 2;  	int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  	// segment length includes size bytes' so subtract two  	lcSegmentLength -= 2;  	if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  		throw new JpegProcessingException ("segment size would extend beyond file stream length");  	} else if (lcSegmentLength < 0) {  		throw new JpegProcessingException ("segment size would be less than zero");  	}  	byte[] lcSegmentBytes = new byte[lcSegmentLength];  	lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  	lcOffset += lcSegmentLength;  	if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  		// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  		// have to search for the two bytes: 0xFF 0xD9 (EOI).  		// It comes last so simply return at this point  		return;  	} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  		// the 'End-Of-Image' segment -- this should never be found in this fashion  		return;  	} else {  		this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  	}  	// didn't find the one we're looking for' loop through to the next segment  } while (true);  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: do {  	// next byte is 0xFF  	byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  	if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  		throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  	}  	lcOffset++;  	// next byte is <segment-marker>  	byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  	lcOffset++;  	// next 2-bytes are <segment-size>: [high-byte] [low-byte]  	byte[] lcSegmentLengthBytes = new byte[2];  	lcInStream.Read (lcSegmentLengthBytes' 0' 2);  	lcOffset += 2;  	int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  	// segment length includes size bytes' so subtract two  	lcSegmentLength -= 2;  	if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  		throw new JpegProcessingException ("segment size would extend beyond file stream length");  	} else if (lcSegmentLength < 0) {  		throw new JpegProcessingException ("segment size would be less than zero");  	}  	byte[] lcSegmentBytes = new byte[lcSegmentLength];  	lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  	lcOffset += lcSegmentLength;  	if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  		// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  		// have to search for the two bytes: 0xFF 0xD9 (EOI).  		// It comes last so simply return at this point  		return;  	} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  		// the 'End-Of-Image' segment -- this should never be found in this fashion  		return;  	} else {  		this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  	}  	// didn't find the one we're looking for' loop through to the next segment  } while (true);  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: do {  	// next byte is 0xFF  	byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  	if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  		throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  	}  	lcOffset++;  	// next byte is <segment-marker>  	byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  	lcOffset++;  	// next 2-bytes are <segment-size>: [high-byte] [low-byte]  	byte[] lcSegmentLengthBytes = new byte[2];  	lcInStream.Read (lcSegmentLengthBytes' 0' 2);  	lcOffset += 2;  	int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  	// segment length includes size bytes' so subtract two  	lcSegmentLength -= 2;  	if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  		throw new JpegProcessingException ("segment size would extend beyond file stream length");  	} else if (lcSegmentLength < 0) {  		throw new JpegProcessingException ("segment size would be less than zero");  	}  	byte[] lcSegmentBytes = new byte[lcSegmentLength];  	lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  	lcOffset += lcSegmentLength;  	if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  		// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  		// have to search for the two bytes: 0xFF 0xD9 (EOI).  		// It comes last so simply return at this point  		return;  	} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  		// the 'End-Of-Image' segment -- this should never be found in this fashion  		return;  	} else {  		this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  	}  	// didn't find the one we're looking for' loop through to the next segment  } while (true);  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: do {  	// next byte is 0xFF  	byte lcSegmentIdentifier = (byte)(lcInStream.ReadByte () & 0xFF);  	if ((lcSegmentIdentifier & 0xFF) != 0xFF) {  		throw new JpegProcessingException ("expected jpeg segment start identifier 0xFF at offset " + lcOffset + "' not 0x" + (lcSegmentIdentifier & 0xFF).ToString ("X"));  	}  	lcOffset++;  	// next byte is <segment-marker>  	byte lcSegmentMarker = (byte)(lcInStream.ReadByte () & 0xFF);  	lcOffset++;  	// next 2-bytes are <segment-size>: [high-byte] [low-byte]  	byte[] lcSegmentLengthBytes = new byte[2];  	lcInStream.Read (lcSegmentLengthBytes' 0' 2);  	lcOffset += 2;  	int lcSegmentLength = ((lcSegmentLengthBytes [0] << 8) & 0xFF00) | (lcSegmentLengthBytes [1] & 0xFF);  	// segment length includes size bytes' so subtract two  	lcSegmentLength -= 2;  	if (lcSegmentLength > (lcInStream.Length - lcInStream.Position)) {  		throw new JpegProcessingException ("segment size would extend beyond file stream length");  	} else if (lcSegmentLength < 0) {  		throw new JpegProcessingException ("segment size would be less than zero");  	}  	byte[] lcSegmentBytes = new byte[lcSegmentLength];  	lcInStream.Read (lcSegmentBytes' 0' lcSegmentLength);  	lcOffset += lcSegmentLength;  	if ((lcSegmentMarker & 0xFF) == (SEGMENT_SOS & 0xFF)) {  		// The 'Start-Of-Scan' segment'str length doesn't include the image data' instead would  		// have to search for the two bytes: 0xFF 0xD9 (EOI).  		// It comes last so simply return at this point  		return;  	} else if ((lcSegmentMarker & 0xFF) == (MARKER_EOI & 0xFF)) {  		// the 'End-Of-Image' segment -- this should never be found in this fashion  		return;  	} else {  		this.segmentDataMap.AddSegment (lcSegmentMarker' lcSegmentBytes);  	}  	// didn't find the one we're looking for' loop through to the next segment  } while (true);  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: lcInStream.Read (lcSegmentLengthBytes' 0' 2);  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: lcOffset += 2;  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: lcSegmentLength -= 2;  
Magic Number,com.drew.imaging.jpg,JpegSegmentReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\imaging\jpg\JpegSegmentReader.cs,IsValidJpegHeaderBytes,The following statement contains a magic number: aFileStream.Read (lcHeader' 0' 2);  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,ToSimpleString,The following statement contains a magic number: if (this.denominator == 0 && this.numerator != 0) {  	return this.ToString ();  } else if (this.IsInteger ()) {  	return this.IntValue ().ToString ();  } else if (this.numerator != 1 && this.denominator % this.numerator == 0) {  	// common lcFactor between denominator and numerator  	int lcNewDenominator = this.denominator / this.numerator;  	return new Rational (1' lcNewDenominator).ToSimpleString (isAllowDecimal);  } else {  	Rational lcSimplifiedInstance = this.GetSimplifiedInstance ();  	if (isAllowDecimal) {  		String lcDoubleString = lcSimplifiedInstance.DoubleValue ().ToString ();  		if (lcDoubleString.Length < 5) {  			return lcDoubleString;  		}  	}  	return lcSimplifiedInstance.ToString ();  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,ToSimpleString,The following statement contains a magic number: if (this.IsInteger ()) {  	return this.IntValue ().ToString ();  } else if (this.numerator != 1 && this.denominator % this.numerator == 0) {  	// common lcFactor between denominator and numerator  	int lcNewDenominator = this.denominator / this.numerator;  	return new Rational (1' lcNewDenominator).ToSimpleString (isAllowDecimal);  } else {  	Rational lcSimplifiedInstance = this.GetSimplifiedInstance ();  	if (isAllowDecimal) {  		String lcDoubleString = lcSimplifiedInstance.DoubleValue ().ToString ();  		if (lcDoubleString.Length < 5) {  			return lcDoubleString;  		}  	}  	return lcSimplifiedInstance.ToString ();  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,ToSimpleString,The following statement contains a magic number: if (this.numerator != 1 && this.denominator % this.numerator == 0) {  	// common lcFactor between denominator and numerator  	int lcNewDenominator = this.denominator / this.numerator;  	return new Rational (1' lcNewDenominator).ToSimpleString (isAllowDecimal);  } else {  	Rational lcSimplifiedInstance = this.GetSimplifiedInstance ();  	if (isAllowDecimal) {  		String lcDoubleString = lcSimplifiedInstance.DoubleValue ().ToString ();  		if (lcDoubleString.Length < 5) {  			return lcDoubleString;  		}  	}  	return lcSimplifiedInstance.ToString ();  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,ToSimpleString,The following statement contains a magic number: if (isAllowDecimal) {  	String lcDoubleString = lcSimplifiedInstance.DoubleValue ().ToString ();  	if (lcDoubleString.Length < 5) {  		return lcDoubleString;  	}  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,ToSimpleString,The following statement contains a magic number: if (lcDoubleString.Length < 5) {  	return lcDoubleString;  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: for (int lcFactor = 2; lcFactor <= Math.Min (this.denominator' this.numerator); lcFactor++) {  	if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  		continue;  	}  	if (this.denominator % lcFactor == 0 && this.numerator % lcFactor == 0) {  		// found a common lcFactor  		return new Rational (this.numerator / lcFactor' this.denominator / lcFactor);  	}  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: for (int lcFactor = 2; lcFactor <= Math.Min (this.denominator' this.numerator); lcFactor++) {  	if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  		continue;  	}  	if (this.denominator % lcFactor == 0 && this.numerator % lcFactor == 0) {  		// found a common lcFactor  		return new Rational (this.numerator / lcFactor' this.denominator / lcFactor);  	}  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: for (int lcFactor = 2; lcFactor <= Math.Min (this.denominator' this.numerator); lcFactor++) {  	if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  		continue;  	}  	if (this.denominator % lcFactor == 0 && this.numerator % lcFactor == 0) {  		// found a common lcFactor  		return new Rational (this.numerator / lcFactor' this.denominator / lcFactor);  	}  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: for (int lcFactor = 2; lcFactor <= Math.Min (this.denominator' this.numerator); lcFactor++) {  	if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  		continue;  	}  	if (this.denominator % lcFactor == 0 && this.numerator % lcFactor == 0) {  		// found a common lcFactor  		return new Rational (this.numerator / lcFactor' this.denominator / lcFactor);  	}  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: for (int lcFactor = 2; lcFactor <= Math.Min (this.denominator' this.numerator); lcFactor++) {  	if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  		continue;  	}  	if (this.denominator % lcFactor == 0 && this.numerator % lcFactor == 0) {  		// found a common lcFactor  		return new Rational (this.numerator / lcFactor' this.denominator / lcFactor);  	}  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  	continue;  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  	continue;  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  	continue;  }  
Magic Number,com.drew.lang,Rational,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\lang\Rational.cs,GetSimplifiedInstance,The following statement contains a magic number: if ((lcFactor % 2 == 0 && lcFactor > 2) || (lcFactor % 5 == 0 && lcFactor > 5)) {  	continue;  }  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,AbstractDirectory,The following statement contains a magic number: if (AbstractDirectory.tagNameMap == null) {  	AbstractDirectory.tagNameMap = new Dictionary<Type' IDictionary<int' string>> (25);  }  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,AbstractDirectory,The following statement contains a magic number: AbstractDirectory.tagNameMap = new Dictionary<Type' IDictionary<int' string>> (25);  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetInt,The following statement contains a magic number: if (lcObj == null) {  	throw new MetadataException ("Tag " + GetTagName (aTagType) + " has not been set -- check using containsTag() first");  } else if (lcObj is string) {  	try {  		return Convert.ToInt32 ((string)lcObj);  	} catch (FormatException) {  		string lcStr = (string)lcObj;  		int lcVal = 0;  		for (int i = lcStr.Length - 1; i >= 0; i--) {  			lcVal += lcStr [i] << (i * 8);  		}  		return lcVal;  	}  } else if (lcObj is Rational) {  	return ((Rational)lcObj).IntValue ();  } else if (lcObj is byte[]) {  	byte[] lcTab = (byte[])lcObj;  	if (lcTab.Length >= 0) {  		return (int)lcTab [0];  	}  } else if (lcObj is int || lcObj is byte || lcObj is long || lcObj is float || lcObj is double) {  	try {  		return Convert.ToInt32 (lcObj);  	} catch (FormatException e) {  		throw new MetadataException ("Unable to parse as int object of type:'" + lcObj.GetType () + "' that look like:'" + lcObj.ToString () + "'"' e);  	}  }  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetInt,The following statement contains a magic number: if (lcObj is string) {  	try {  		return Convert.ToInt32 ((string)lcObj);  	} catch (FormatException) {  		string lcStr = (string)lcObj;  		int lcVal = 0;  		for (int i = lcStr.Length - 1; i >= 0; i--) {  			lcVal += lcStr [i] << (i * 8);  		}  		return lcVal;  	}  } else if (lcObj is Rational) {  	return ((Rational)lcObj).IntValue ();  } else if (lcObj is byte[]) {  	byte[] lcTab = (byte[])lcObj;  	if (lcTab.Length >= 0) {  		return (int)lcTab [0];  	}  } else if (lcObj is int || lcObj is byte || lcObj is long || lcObj is float || lcObj is double) {  	try {  		return Convert.ToInt32 (lcObj);  	} catch (FormatException e) {  		throw new MetadataException ("Unable to parse as int object of type:'" + lcObj.GetType () + "' that look like:'" + lcObj.ToString () + "'"' e);  	}  }  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetInt,The following statement contains a magic number: try {  	return Convert.ToInt32 ((string)lcObj);  } catch (FormatException) {  	string lcStr = (string)lcObj;  	int lcVal = 0;  	for (int i = lcStr.Length - 1; i >= 0; i--) {  		lcVal += lcStr [i] << (i * 8);  	}  	return lcVal;  }  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetInt,The following statement contains a magic number: for (int i = lcStr.Length - 1; i >= 0; i--) {  	lcVal += lcStr [i] << (i * 8);  }  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetInt,The following statement contains a magic number: lcVal += lcStr [i] << (i * 8);  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetTagName,The following statement contains a magic number: if (!AbstractDirectory.tagNameMap [this.GetType ()].ContainsKey (aTagType)) {  	StringBuilder buff = new StringBuilder (32);  	buff.Append ("Unknown tag (0x");  	string lcHex = aTagType.ToString ("X");  	for (int i = 0; i < 4 - lcHex.Length; i++) {  		buff.Append ('0');  	}  	return buff.Append (lcHex).Append (')').ToString ();  }  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetTagName,The following statement contains a magic number: if (!AbstractDirectory.tagNameMap [this.GetType ()].ContainsKey (aTagType)) {  	StringBuilder buff = new StringBuilder (32);  	buff.Append ("Unknown tag (0x");  	string lcHex = aTagType.ToString ("X");  	for (int i = 0; i < 4 - lcHex.Length; i++) {  		buff.Append ('0');  	}  	return buff.Append (lcHex).Append (')').ToString ();  }  
Magic Number,com.drew.metadata,AbstractDirectory,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractDirectory.cs,GetTagName,The following statement contains a magic number: for (int i = 0; i < 4 - lcHex.Length; i++) {  	buff.Append ('0');  }  
Magic Number,com.drew.metadata,AbstractMetadataReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractMetadataReader.cs,Get32Bits,The following statement contains a magic number: return ((this.data [anOffset] & 255) << 8) | (this.data [anOffset + 1] & 255);  
Magic Number,com.drew.metadata,AbstractMetadataReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractMetadataReader.cs,Get32Bits,The following statement contains a magic number: return ((this.data [anOffset] & 255) << 8) | (this.data [anOffset + 1] & 255);  
Magic Number,com.drew.metadata,AbstractMetadataReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractMetadataReader.cs,Get32Bits,The following statement contains a magic number: return ((this.data [anOffset] & 255) << 8) | (this.data [anOffset + 1] & 255);  
Magic Number,com.drew.metadata,AbstractMetadataReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\AbstractMetadataReader.cs,Get16Bits,The following statement contains a magic number: return (this.data [anOffset] & 255);  
Magic Number,com.drew.metadata,Tag,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\Tag.cs,GetTagTypeHex,The following statement contains a magic number: while (lcHex.Length < 4) {  	lcHex = "0" + lcHex;  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetMenuButtonReturnPositionDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["TOP"];  case 1:  	return BUNDLE ["PREVIOUS_VOLATILE"];  case 2:  	return BUNDLE ["PREVIOUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetSetButtonFunctionWhenShootingDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NOT_ASSIGNED"];  case 1:  	return BUNDLE ["CHANGE_QUALITY"];  case 2:  	return BUNDLE ["CHANGE_ISO_SPEED"];  case 3:  	return BUNDLE ["SELECT_PARAMETERS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetSetButtonFunctionWhenShootingDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NOT_ASSIGNED"];  case 1:  	return BUNDLE ["CHANGE_QUALITY"];  case 2:  	return BUNDLE ["CHANGE_ISO_SPEED"];  case 3:  	return BUNDLE ["SELECT_PARAMETERS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetLensAutoFocusStopButtonDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AF_STOP"];  case 1:  	return BUNDLE ["OPERATE_AF"];  case 2:  	return BUNDLE ["LOCK_AE_AND_START_TIMER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetAutoExposureBrackettingSequenceAndAutoCancellationDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["0_M_P_ENABLED"];  case 1:  	return BUNDLE ["0_M_P_DISABLED"];  case 2:  	return BUNDLE ["M_0_P_ENABLED"];  case 3:  	return BUNDLE ["M_0_P_DISABLED"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetAutoExposureBrackettingSequenceAndAutoCancellationDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["0_M_P_ENABLED"];  case 1:  	return BUNDLE ["0_M_P_DISABLED"];  case 2:  	return BUNDLE ["M_0_P_ENABLED"];  case 3:  	return BUNDLE ["M_0_P_DISABLED"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetShutterAutoExposureLockButtonDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AF_AE_LOCK"];  case 1:  	return BUNDLE ["AE_LOCK_AF"];  case 2:  	return BUNDLE ["AE_AF_LOCK"];  case 3:  	return BUNDLE ["AE_RELEASE_AE_AF"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetShutterAutoExposureLockButtonDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AF_AE_LOCK"];  case 1:  	return BUNDLE ["AE_LOCK_AF"];  case 2:  	return BUNDLE ["AE_AF_LOCK"];  case 3:  	return BUNDLE ["AE_RELEASE_AE_AF"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["NORMAL"];  case 3:  	return BUNDLE ["FINE"];  case 5:  	return BUNDLE ["SUPERFINE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["NORMAL"];  case 3:  	return BUNDLE ["FINE"];  case 5:  	return BUNDLE ["SUPERFINE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["NORMAL"];  case 3:  	return BUNDLE ["FINE"];  case 5:  	return BUNDLE ["SUPERFINE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetDigitalZoomDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NO_DIGITAL_ZOOM"];  case 1:  	return BUNDLE ["DIGITAL_ZOOM"' "2"];  case 2:  	return BUNDLE ["DIGITAL_ZOOM"' "4"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["MANUAL"];  case 1:  case 2:  	return BUNDLE ["AUTO"];  case 3:  	return BUNDLE ["CLOSE_UP_MACRO"];  case 8:  	return BUNDLE ["LOCKED_PAN_MODE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["MANUAL"];  case 1:  case 2:  	return BUNDLE ["AUTO"];  case 3:  	return BUNDLE ["CLOSE_UP_MACRO"];  case 8:  	return BUNDLE ["LOCKED_PAN_MODE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["MANUAL"];  case 1:  case 2:  	return BUNDLE ["AUTO"];  case 3:  	return BUNDLE ["CLOSE_UP_MACRO"];  case 8:  	return BUNDLE ["LOCKED_PAN_MODE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashBiasDescription,The following statement contains a magic number: return BUNDLE ["FLASH_BIAS_NEW"' ((isNegative) ? "-" : "")' (lcVal / 32.0).ToString ()];  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetAfPointUsedDescription,The following statement contains a magic number: if ((lcVal & 0x7) == 0) {  	return BUNDLE ["RIGHT"];  } else if ((lcVal & 0x7) == 1) {  	return BUNDLE ["CENTER"];  	;  } else if ((lcVal & 0x7) == 2) {  	return BUNDLE ["LEFT"];  } else {  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetAfPointUsedDescription,The following statement contains a magic number: if ((lcVal & 0x7) == 1) {  	return BUNDLE ["CENTER"];  	;  } else if ((lcVal & 0x7) == 2) {  	return BUNDLE ["LEFT"];  } else {  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetAfPointUsedDescription,The following statement contains a magic number: if ((lcVal & 0x7) == 2) {  	return BUNDLE ["LEFT"];  } else {  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["SUNNY"];  case 2:  	return BUNDLE ["CLOUDY"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["FLASH"];  case 6:  	return BUNDLE ["CUSTOM"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["SUNNY"];  case 2:  	return BUNDLE ["CLOUDY"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["FLASH"];  case 6:  	return BUNDLE ["CUSTOM"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["SUNNY"];  case 2:  	return BUNDLE ["CLOUDY"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["FLASH"];  case 6:  	return BUNDLE ["CUSTOM"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["SUNNY"];  case 2:  	return BUNDLE ["CLOUDY"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["FLASH"];  case 6:  	return BUNDLE ["CUSTOM"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["SUNNY"];  case 2:  	return BUNDLE ["CLOUDY"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["FLASH"];  case 6:  	return BUNDLE ["CUSTOM"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashDetailsDescription,The following statement contains a magic number: if (((lcVal << 14) & 1) > 0) {  	return BUNDLE ["EXTERNAL_E_TTL"];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashDetailsDescription,The following statement contains a magic number: if (((lcVal << 13) & 1) > 0) {  	return BUNDLE ["INTERNAL_FLASH"];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashDetailsDescription,The following statement contains a magic number: if (((lcVal << 11) & 1) > 0) {  	return BUNDLE ["FP_SYNC_USED"];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashDetailsDescription,The following statement contains a magic number: if (((lcVal << 4) & 1) > 0) {  	return BUNDLE ["FP_SYNC_ENABLED"];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetExposureModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["EASY_SHOOTING"];  case 1:  	return BUNDLE ["PROGRAM"];  case 2:  	return BUNDLE ["TV_PRIORITY"];  case 3:  	return BUNDLE ["AV_PRIORITY"];  case 4:  	return BUNDLE ["MANUAL"];  case 5:  	return BUNDLE ["A_DEP"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetExposureModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["EASY_SHOOTING"];  case 1:  	return BUNDLE ["PROGRAM"];  case 2:  	return BUNDLE ["TV_PRIORITY"];  case 3:  	return BUNDLE ["AV_PRIORITY"];  case 4:  	return BUNDLE ["MANUAL"];  case 5:  	return BUNDLE ["A_DEP"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetExposureModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["EASY_SHOOTING"];  case 1:  	return BUNDLE ["PROGRAM"];  case 2:  	return BUNDLE ["TV_PRIORITY"];  case 3:  	return BUNDLE ["AV_PRIORITY"];  case 4:  	return BUNDLE ["MANUAL"];  case 5:  	return BUNDLE ["A_DEP"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetExposureModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["EASY_SHOOTING"];  case 1:  	return BUNDLE ["PROGRAM"];  case 2:  	return BUNDLE ["TV_PRIORITY"];  case 3:  	return BUNDLE ["AV_PRIORITY"];  case 4:  	return BUNDLE ["MANUAL"];  case 5:  	return BUNDLE ["A_DEP"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcVal) {  case 3:  	return BUNDLE ["EVALUATIVE"];  case 4:  	return BUNDLE ["PARTIAL"];  case 5:  	return BUNDLE ["CENTER_WEIGHTED"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcVal) {  case 3:  	return BUNDLE ["EVALUATIVE"];  case 4:  	return BUNDLE ["PARTIAL"];  case 5:  	return BUNDLE ["CENTER_WEIGHTED"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcVal) {  case 3:  	return BUNDLE ["EVALUATIVE"];  case 4:  	return BUNDLE ["PARTIAL"];  case 5:  	return BUNDLE ["CENTER_WEIGHTED"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetIsoDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ISO_NOT_SPECIFIED"];  case 15:  	return BUNDLE ["AUTO"];  case 16:  	return BUNDLE ["ISO"' "50"];  case 17:  	return BUNDLE ["ISO"' "100"];  case 18:  	return BUNDLE ["ISO"' "200"];  case 19:  	return BUNDLE ["ISO"' "400"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetIsoDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ISO_NOT_SPECIFIED"];  case 15:  	return BUNDLE ["AUTO"];  case 16:  	return BUNDLE ["ISO"' "50"];  case 17:  	return BUNDLE ["ISO"' "100"];  case 18:  	return BUNDLE ["ISO"' "200"];  case 19:  	return BUNDLE ["ISO"' "400"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetIsoDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ISO_NOT_SPECIFIED"];  case 15:  	return BUNDLE ["AUTO"];  case 16:  	return BUNDLE ["ISO"' "50"];  case 17:  	return BUNDLE ["ISO"' "100"];  case 18:  	return BUNDLE ["ISO"' "200"];  case 19:  	return BUNDLE ["ISO"' "400"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetIsoDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ISO_NOT_SPECIFIED"];  case 15:  	return BUNDLE ["AUTO"];  case 16:  	return BUNDLE ["ISO"' "50"];  case 17:  	return BUNDLE ["ISO"' "100"];  case 18:  	return BUNDLE ["ISO"' "200"];  case 19:  	return BUNDLE ["ISO"' "400"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetIsoDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ISO_NOT_SPECIFIED"];  case 15:  	return BUNDLE ["AUTO"];  case 16:  	return BUNDLE ["ISO"' "50"];  case 17:  	return BUNDLE ["ISO"' "100"];  case 18:  	return BUNDLE ["ISO"' "200"];  case 19:  	return BUNDLE ["ISO"' "400"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetEasyShootingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["FULL_AUTO"];  case 1:  	return BUNDLE ["MANUAL"];  case 2:  	return BUNDLE ["LANDSCAPE"];  case 3:  	return BUNDLE ["FAST_SHUTTER"];  case 4:  	return BUNDLE ["SLOW_SHUTTER"];  case 5:  	return BUNDLE ["NIGHT"];  case 6:  	return BUNDLE ["BLACK_AND_WHITE"];  case 7:  	return BUNDLE ["SEPIA"];  case 8:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["SPORTS"];  case 10:  	return BUNDLE ["MACRO_CLOSEUP"];  case 11:  	return BUNDLE ["PAN_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetImageSizeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["LARGE"];  case 1:  	return BUNDLE ["MEDIUM"];  case 2:  	return BUNDLE ["SMALL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusMode1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ONE_SHOT"];  case 1:  	return BUNDLE ["AI_SERVO"];  case 2:  	return BUNDLE ["AI_FOCUS"];  case 3:  	return BUNDLE ["MF"];  case 4:  	// TODO should check field 32 here (FOCUS_MODE_2)  	return BUNDLE ["SINGLE"];  case 5:  	return BUNDLE ["CONTINUOUS"];  case 6:  	return BUNDLE ["MF"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusMode1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ONE_SHOT"];  case 1:  	return BUNDLE ["AI_SERVO"];  case 2:  	return BUNDLE ["AI_FOCUS"];  case 3:  	return BUNDLE ["MF"];  case 4:  	// TODO should check field 32 here (FOCUS_MODE_2)  	return BUNDLE ["SINGLE"];  case 5:  	return BUNDLE ["CONTINUOUS"];  case 6:  	return BUNDLE ["MF"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusMode1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ONE_SHOT"];  case 1:  	return BUNDLE ["AI_SERVO"];  case 2:  	return BUNDLE ["AI_FOCUS"];  case 3:  	return BUNDLE ["MF"];  case 4:  	// TODO should check field 32 here (FOCUS_MODE_2)  	return BUNDLE ["SINGLE"];  case 5:  	return BUNDLE ["CONTINUOUS"];  case 6:  	return BUNDLE ["MF"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusMode1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ONE_SHOT"];  case 1:  	return BUNDLE ["AI_SERVO"];  case 2:  	return BUNDLE ["AI_FOCUS"];  case 3:  	return BUNDLE ["MF"];  case 4:  	// TODO should check field 32 here (FOCUS_MODE_2)  	return BUNDLE ["SINGLE"];  case 5:  	return BUNDLE ["CONTINUOUS"];  case 6:  	return BUNDLE ["MF"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFocusMode1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["ONE_SHOT"];  case 1:  	return BUNDLE ["AI_SERVO"];  case 2:  	return BUNDLE ["AI_FOCUS"];  case 3:  	return BUNDLE ["MF"];  case 4:  	// TODO should check field 32 here (FOCUS_MODE_2)  	return BUNDLE ["SINGLE"];  case 5:  	return BUNDLE ["CONTINUOUS"];  case 6:  	return BUNDLE ["MF"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NO_FLASH_FIRED"];  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["RED_EYE_REDUCTION"];  case 4:  	return BUNDLE ["SLOW_SYNCHRO"];  case 5:  	return BUNDLE ["AUTO_AND_RED_EYE_REDUCTION"];  case 6:  	return BUNDLE ["ON_AND_RED_EYE_REDUCTION"];  case 16:  	// note: this lcVal not set on Canon D30  	return BUNDLE ["EXTERNAL_FLASH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NO_FLASH_FIRED"];  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["RED_EYE_REDUCTION"];  case 4:  	return BUNDLE ["SLOW_SYNCHRO"];  case 5:  	return BUNDLE ["AUTO_AND_RED_EYE_REDUCTION"];  case 6:  	return BUNDLE ["ON_AND_RED_EYE_REDUCTION"];  case 16:  	// note: this lcVal not set on Canon D30  	return BUNDLE ["EXTERNAL_FLASH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NO_FLASH_FIRED"];  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["RED_EYE_REDUCTION"];  case 4:  	return BUNDLE ["SLOW_SYNCHRO"];  case 5:  	return BUNDLE ["AUTO_AND_RED_EYE_REDUCTION"];  case 6:  	return BUNDLE ["ON_AND_RED_EYE_REDUCTION"];  case 16:  	// note: this lcVal not set on Canon D30  	return BUNDLE ["EXTERNAL_FLASH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NO_FLASH_FIRED"];  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["RED_EYE_REDUCTION"];  case 4:  	return BUNDLE ["SLOW_SYNCHRO"];  case 5:  	return BUNDLE ["AUTO_AND_RED_EYE_REDUCTION"];  case 6:  	return BUNDLE ["ON_AND_RED_EYE_REDUCTION"];  case 16:  	// note: this lcVal not set on Canon D30  	return BUNDLE ["EXTERNAL_FLASH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NO_FLASH_FIRED"];  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["RED_EYE_REDUCTION"];  case 4:  	return BUNDLE ["SLOW_SYNCHRO"];  case 5:  	return BUNDLE ["AUTO_AND_RED_EYE_REDUCTION"];  case 6:  	return BUNDLE ["ON_AND_RED_EYE_REDUCTION"];  case 16:  	// note: this lcVal not set on Canon D30  	return BUNDLE ["EXTERNAL_FLASH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NO_FLASH_FIRED"];  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["RED_EYE_REDUCTION"];  case 4:  	return BUNDLE ["SLOW_SYNCHRO"];  case 5:  	return BUNDLE ["AUTO_AND_RED_EYE_REDUCTION"];  case 6:  	return BUNDLE ["ON_AND_RED_EYE_REDUCTION"];  case 16:  	// note: this lcVal not set on Canon D30  	return BUNDLE ["EXTERNAL_FLASH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CanonDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CanonDescriptor.cs,GetMacroModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["OFF"];  case 1:  	return BUNDLE ["MACRO"];  case 2:  	return BUNDLE ["NORMAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  // these four for QV3000  case 64:  	return BUNDLE ["NORMAL"];  case 125:  	return BUNDLE ["CCD_P_1"];  case 250:  	return BUNDLE ["CCD_P_2"];  case 244:  	return BUNDLE ["CCD_P_3"];  // these two for QV8000/2000  case 80:  	return BUNDLE ["NORMAL"];  case 100:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  // these four for QV3000  case 64:  	return BUNDLE ["NORMAL"];  case 125:  	return BUNDLE ["CCD_P_1"];  case 250:  	return BUNDLE ["CCD_P_2"];  case 244:  	return BUNDLE ["CCD_P_3"];  // these two for QV8000/2000  case 80:  	return BUNDLE ["NORMAL"];  case 100:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  // these four for QV3000  case 64:  	return BUNDLE ["NORMAL"];  case 125:  	return BUNDLE ["CCD_P_1"];  case 250:  	return BUNDLE ["CCD_P_2"];  case 244:  	return BUNDLE ["CCD_P_3"];  // these two for QV8000/2000  case 80:  	return BUNDLE ["NORMAL"];  case 100:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  // these four for QV3000  case 64:  	return BUNDLE ["NORMAL"];  case 125:  	return BUNDLE ["CCD_P_1"];  case 250:  	return BUNDLE ["CCD_P_2"];  case 244:  	return BUNDLE ["CCD_P_3"];  // these two for QV8000/2000  case 80:  	return BUNDLE ["NORMAL"];  case 100:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  // these four for QV3000  case 64:  	return BUNDLE ["NORMAL"];  case 125:  	return BUNDLE ["CCD_P_1"];  case 250:  	return BUNDLE ["CCD_P_2"];  case 244:  	return BUNDLE ["CCD_P_3"];  // these two for QV8000/2000  case 80:  	return BUNDLE ["NORMAL"];  case 100:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  // these four for QV3000  case 64:  	return BUNDLE ["NORMAL"];  case 125:  	return BUNDLE ["CCD_P_1"];  case 250:  	return BUNDLE ["CCD_P_2"];  case 244:  	return BUNDLE ["CCD_P_3"];  // these two for QV8000/2000  case 80:  	return BUNDLE ["NORMAL"];  case 100:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetSaturationDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["LOW"];  case 2:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetContrastDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["LOW"];  case 2:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetSharpnessDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["SOFT"];  	;  case 2:  	return BUNDLE ["HARD"];  	;  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["TUNGSTEN"];  case 3:  	return BUNDLE ["DAYLIGHT"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["SHADE"];  case 129:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["TUNGSTEN"];  case 3:  	return BUNDLE ["DAYLIGHT"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["SHADE"];  case 129:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["TUNGSTEN"];  case 3:  	return BUNDLE ["DAYLIGHT"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["SHADE"];  case 129:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["TUNGSTEN"];  case 3:  	return BUNDLE ["DAYLIGHT"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["SHADE"];  case 129:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["TUNGSTEN"];  case 3:  	return BUNDLE ["DAYLIGHT"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["SHADE"];  case 129:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFlashIntensityDescription,The following statement contains a magic number: switch (lcVal) {  case 11:  	return BUNDLE ["WEAK"];  case 13:  	return BUNDLE ["NORMAL"];  case 15:  	return BUNDLE ["STRONG"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFlashIntensityDescription,The following statement contains a magic number: switch (lcVal) {  case 11:  	return BUNDLE ["WEAK"];  case 13:  	return BUNDLE ["NORMAL"];  case 15:  	return BUNDLE ["STRONG"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFlashIntensityDescription,The following statement contains a magic number: switch (lcVal) {  case 11:  	return BUNDLE ["WEAK"];  case 13:  	return BUNDLE ["NORMAL"];  case 15:  	return BUNDLE ["STRONG"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["OFF"];  case 4:  	// this documented as additional value for off here:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/casio_mn.html  	return BUNDLE ["RED_EYE_REDUCTION"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["OFF"];  case 4:  	// this documented as additional value for off here:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/casio_mn.html  	return BUNDLE ["RED_EYE_REDUCTION"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["ON"];  case 3:  	return BUNDLE ["OFF"];  case 4:  	// this documented as additional value for off here:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/casio_mn.html  	return BUNDLE ["RED_EYE_REDUCTION"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFocusingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["MACRO"];  case 3:  	return BUNDLE ["AUTO_FOCUS"];  case 4:  	return BUNDLE ["MANUAL_FOCUS"];  case 5:  	return BUNDLE ["INFINITY"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFocusingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["MACRO"];  case 3:  	return BUNDLE ["AUTO_FOCUS"];  case 4:  	return BUNDLE ["MANUAL_FOCUS"];  case 5:  	return BUNDLE ["INFINITY"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFocusingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["MACRO"];  case 3:  	return BUNDLE ["AUTO_FOCUS"];  case 4:  	return BUNDLE ["MANUAL_FOCUS"];  case 5:  	return BUNDLE ["INFINITY"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFocusingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["MACRO"];  case 3:  	return BUNDLE ["AUTO_FOCUS"];  case 4:  	return BUNDLE ["MANUAL_FOCUS"];  case 5:  	return BUNDLE ["INFINITY"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["ECONOMY"];  case 2:  	return BUNDLE ["NORMAL"];  case 3:  	return BUNDLE ["FINE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["ECONOMY"];  case 2:  	return BUNDLE ["NORMAL"];  case 3:  	return BUNDLE ["FINE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFocussingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["MACRO"];  case 3:  	return BUNDLE ["AUTO_FOCUS"];  case 4:  	return BUNDLE ["MANUAL_FOCUS"];  case 5:  	return BUNDLE ["INFINITY"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFocussingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["MACRO"];  case 3:  	return BUNDLE ["AUTO_FOCUS"];  case 4:  	return BUNDLE ["MANUAL_FOCUS"];  case 5:  	return BUNDLE ["INFINITY"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFocussingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["MACRO"];  case 3:  	return BUNDLE ["AUTO_FOCUS"];  case 4:  	return BUNDLE ["MANUAL_FOCUS"];  case 5:  	return BUNDLE ["INFINITY"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetFocussingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["MACRO"];  case 3:  	return BUNDLE ["AUTO_FOCUS"];  case 4:  	return BUNDLE ["MANUAL_FOCUS"];  case 5:  	return BUNDLE ["INFINITY"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetRecordingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["SINGLE_SHUTTER"];  case 2:  	return BUNDLE ["PANORAMA"];  case 3:  	return BUNDLE ["NIGHT_SCENE"];  case 4:  	return BUNDLE ["PORTRAIT"];  case 5:  	return BUNDLE ["LANDSCAPE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetRecordingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["SINGLE_SHUTTER"];  case 2:  	return BUNDLE ["PANORAMA"];  case 3:  	return BUNDLE ["NIGHT_SCENE"];  case 4:  	return BUNDLE ["PORTRAIT"];  case 5:  	return BUNDLE ["LANDSCAPE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetRecordingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["SINGLE_SHUTTER"];  case 2:  	return BUNDLE ["PANORAMA"];  case 3:  	return BUNDLE ["NIGHT_SCENE"];  case 4:  	return BUNDLE ["PORTRAIT"];  case 5:  	return BUNDLE ["LANDSCAPE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType1Descriptor.cs,GetRecordingModeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["SINGLE_SHUTTER"];  case 2:  	return BUNDLE ["PANORAMA"];  case 3:  	return BUNDLE ["NIGHT_SCENE"];  case 4:  	return BUNDLE ["PORTRAIT"];  case 5:  	return BUNDLE ["LANDSCAPE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetFocusMode2Description,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FIXATION"];  case 6:  	return BUNDLE ["MULTI_AREA_FOCUS"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (lcVal) {  case 3:  	return BUNDLE ["FINE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetRecordModeDescription,The following statement contains a magic number: switch (lcVal) {  case 2:  	return BUNDLE ["NORMAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetWhiteBalance2Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["MANUAL"];  case 1:  	return BUNDLE ["AUTO"];  // unsure about this  case 4:  	return BUNDLE ["FLASH"];  // unsure about this  case 12:  	return BUNDLE ["FLASH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetWhiteBalance2Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["MANUAL"];  case 1:  	return BUNDLE ["AUTO"];  // unsure about this  case 4:  	return BUNDLE ["FLASH"];  // unsure about this  case 12:  	return BUNDLE ["FLASH"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetSharpnessDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return "-1";  case 1:  	return BUNDLE ["NORMAL"];  case 2:  	return "+1";  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetContrastDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return "-1";  case 1:  	return BUNDLE ["NORMAL"];  case 2:  	return "+1";  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetSaturationDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return "-1";  case 1:  	return BUNDLE ["NORMAL"];  case 2:  	return "+1";  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetFocalLengthDescription,The following statement contains a magic number: return BUNDLE ["DISTANCE_MM"' (lcVal / 10.0).ToString ()];  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetWhiteBalance1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["SHADE"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetWhiteBalance1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["SHADE"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetWhiteBalance1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["SHADE"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetWhiteBalance1Description,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["SHADE"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetIsoSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  case 3:  	return BUNDLE ["ISO"' "50"];  case 4:  	return BUNDLE ["ISO"' "64"];  case 6:  	return BUNDLE ["ISO"' "100"];  case 9:  	return BUNDLE ["ISO"' "200"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetIsoSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  case 3:  	return BUNDLE ["ISO"' "50"];  case 4:  	return BUNDLE ["ISO"' "64"];  case 6:  	return BUNDLE ["ISO"' "100"];  case 9:  	return BUNDLE ["ISO"' "200"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetIsoSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  case 3:  	return BUNDLE ["ISO"' "50"];  case 4:  	return BUNDLE ["ISO"' "64"];  case 6:  	return BUNDLE ["ISO"' "100"];  case 9:  	return BUNDLE ["ISO"' "200"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetIsoSensitivityDescription,The following statement contains a magic number: switch (lcVal) {  case 3:  	return BUNDLE ["ISO"' "50"];  case 4:  	return BUNDLE ["ISO"' "64"];  case 6:  	return BUNDLE ["ISO"' "100"];  case 9:  	return BUNDLE ["ISO"' "200"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetImageSizeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["PIXELS"' "640 x 480"];  case 4:  	return BUNDLE ["PIXELS"' "1600 x 1200"];  case 5:  	return BUNDLE ["PIXELS"' "2048 x 1536"];  case 20:  	return BUNDLE ["PIXELS"' "2288 x 1712"];  case 21:  	return BUNDLE ["PIXELS"' "2592 x 1944"];  case 22:  	return BUNDLE ["PIXELS"' "2304 x 1728"];  case 36:  	return BUNDLE ["PIXELS"' "3008 x 2008"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetImageSizeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["PIXELS"' "640 x 480"];  case 4:  	return BUNDLE ["PIXELS"' "1600 x 1200"];  case 5:  	return BUNDLE ["PIXELS"' "2048 x 1536"];  case 20:  	return BUNDLE ["PIXELS"' "2288 x 1712"];  case 21:  	return BUNDLE ["PIXELS"' "2592 x 1944"];  case 22:  	return BUNDLE ["PIXELS"' "2304 x 1728"];  case 36:  	return BUNDLE ["PIXELS"' "3008 x 2008"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetImageSizeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["PIXELS"' "640 x 480"];  case 4:  	return BUNDLE ["PIXELS"' "1600 x 1200"];  case 5:  	return BUNDLE ["PIXELS"' "2048 x 1536"];  case 20:  	return BUNDLE ["PIXELS"' "2288 x 1712"];  case 21:  	return BUNDLE ["PIXELS"' "2592 x 1944"];  case 22:  	return BUNDLE ["PIXELS"' "2304 x 1728"];  case 36:  	return BUNDLE ["PIXELS"' "3008 x 2008"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetImageSizeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["PIXELS"' "640 x 480"];  case 4:  	return BUNDLE ["PIXELS"' "1600 x 1200"];  case 5:  	return BUNDLE ["PIXELS"' "2048 x 1536"];  case 20:  	return BUNDLE ["PIXELS"' "2288 x 1712"];  case 21:  	return BUNDLE ["PIXELS"' "2592 x 1944"];  case 22:  	return BUNDLE ["PIXELS"' "2304 x 1728"];  case 36:  	return BUNDLE ["PIXELS"' "3008 x 2008"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetImageSizeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["PIXELS"' "640 x 480"];  case 4:  	return BUNDLE ["PIXELS"' "1600 x 1200"];  case 5:  	return BUNDLE ["PIXELS"' "2048 x 1536"];  case 20:  	return BUNDLE ["PIXELS"' "2288 x 1712"];  case 21:  	return BUNDLE ["PIXELS"' "2592 x 1944"];  case 22:  	return BUNDLE ["PIXELS"' "2304 x 1728"];  case 36:  	return BUNDLE ["PIXELS"' "3008 x 2008"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetImageSizeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["PIXELS"' "640 x 480"];  case 4:  	return BUNDLE ["PIXELS"' "1600 x 1200"];  case 5:  	return BUNDLE ["PIXELS"' "2048 x 1536"];  case 20:  	return BUNDLE ["PIXELS"' "2288 x 1712"];  case 21:  	return BUNDLE ["PIXELS"' "2592 x 1944"];  case 22:  	return BUNDLE ["PIXELS"' "2304 x 1728"];  case 36:  	return BUNDLE ["PIXELS"' "3008 x 2008"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetQualityModeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FINE"];  case 2:  	return BUNDLE ["SUPERFINE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,CasioType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\CasioType2Descriptor.cs,GetThumbnailDimensionsDescription,The following statement contains a magic number: if (lcDimensions.Length != 2) {  	return base.directory.GetString (CasioType2Directory.TAG_CASIO_TYPE2_THUMBNAIL_DIMENSIONS);  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetColorDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["NORMAL"];  case 2:  	return BUNDLE ["BLACK_AND_WHITE"];  case 3:  	return BUNDLE ["SEPIA"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetColorDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["NORMAL"];  case 2:  	return BUNDLE ["BLACK_AND_WHITE"];  case 3:  	return BUNDLE ["SEPIA"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetIsoSpeedDescription,The following statement contains a magic number: switch (aValue) {  case 100:  case 10:  	return BUNDLE ["ISO"' "100"];  case 16:  case 200:  	return BUNDLE ["ISO"' "200"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetIsoSpeedDescription,The following statement contains a magic number: switch (aValue) {  case 100:  case 10:  	return BUNDLE ["ISO"' "100"];  case 16:  case 200:  	return BUNDLE ["ISO"' "200"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetIsoSpeedDescription,The following statement contains a magic number: switch (aValue) {  case 100:  case 10:  	return BUNDLE ["ISO"' "100"];  case 16:  case 200:  	return BUNDLE ["ISO"' "200"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetIsoSpeedDescription,The following statement contains a magic number: switch (aValue) {  case 100:  case 10:  	return BUNDLE ["ISO"' "100"];  case 16:  case 200:  	return BUNDLE ["ISO"' "200"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetSaturationDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["LOW"];  case 2:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetContrastDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["LOW"];  case 2:  	return BUNDLE ["HIGH"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetSharpnessDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["SOFT"];  case 2:  	return BUNDLE ["HARD"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["SHADE"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["SHADE"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["SHADE"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["SHADE"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["MANUAL"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["FLASH_ON"];  case 4:  	return BUNDLE ["FLASH_OFF"];  case 6:  	return BUNDLE ["RED_EYE_REDUCTION"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["FLASH_ON"];  case 4:  	return BUNDLE ["FLASH_OFF"];  case 6:  	return BUNDLE ["RED_EYE_REDUCTION"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["FLASH_ON"];  case 4:  	return BUNDLE ["FLASH_OFF"];  case 6:  	return BUNDLE ["RED_EYE_REDUCTION"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetFocusModeDescription,The following statement contains a magic number: switch (aValue) {  case 2:  	return BUNDLE ["CUSTOM"];  case 3:  	return BUNDLE ["AUTO"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetFocusModeDescription,The following statement contains a magic number: switch (aValue) {  case 2:  	return BUNDLE ["CUSTOM"];  case 3:  	return BUNDLE ["AUTO"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetQualityLevelDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["GOOD"];  case 1:  	return BUNDLE ["BETTER"];  case 2:  	return BUNDLE ["BEST"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetCaptureModeDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["NIGHT_SCENE"];  case 3:  	return BUNDLE ["MANUAL"];  case 4:  	return BUNDLE ["MULTIPLE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetCaptureModeDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["NIGHT_SCENE"];  case 3:  	return BUNDLE ["MANUAL"];  case 4:  	return BUNDLE ["MULTIPLE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PentaxDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PentaxDescriptor.cs,GetCaptureModeDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["AUTO"];  case 2:  	return BUNDLE ["NIGHT_SCENE"];  case 3:  	return BUNDLE ["MANUAL"];  case 4:  	return BUNDLE ["MULTIPLE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PanasonicDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PanasonicDescriptor.cs,GetMacroModeDescription,The following statement contains a magic number: switch (value) {  case 1:  	return BUNDLE ["ON"];  case 2:  	return BUNDLE ["OFF"];  default:  	return BUNDLE ["UNKNOWN"' value.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PanasonicDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PanasonicDescriptor.cs,GetRecordModeDescription,The following statement contains a magic number: switch (value) {  case 1:  	return BUNDLE ["NORMAL"];  case 2:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["MACRO"];  default:  	return BUNDLE ["UNKNOWN"' value.ToString ()];  }  
Magic Number,com.drew.metadata.exif,PanasonicDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\PanasonicDescriptor.cs,GetRecordModeDescription,The following statement contains a magic number: switch (value) {  case 1:  	return BUNDLE ["NORMAL"];  case 2:  	return BUNDLE ["PORTRAIT"];  case 9:  	return BUNDLE ["MACRO"];  default:  	return BUNDLE ["UNKNOWN"' value.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureModeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["AUTO_EXPOSURE"];  case 1:  	return BUNDLE ["MANUAL_EXPOSURE"];  case 2:  	return BUNDLE ["AUTO_BRACKET"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSceneCaptureTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["STANDARD"];  case 1:  	return BUNDLE ["LANDSCAPE"];  case 2:  	return BUNDLE ["PORTRAIT"];  case 3:  	return BUNDLE ["NIGHT_SCENE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSceneCaptureTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["STANDARD"];  case 1:  	return BUNDLE ["LANDSCAPE"];  case 2:  	return BUNDLE ["PORTRAIT"];  case 3:  	return BUNDLE ["NIGHT_SCENE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetGainControlDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NONE"];  case 1:  	return BUNDLE ["LOW_GAIN_UP"];  case 2:  	return BUNDLE ["LOW_GAIN_DOWN"];  case 3:  	return BUNDLE ["HIGH_GAIN_UP"];  case 4:  	return BUNDLE ["HIGH_GAIN_DOWN"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetGainControlDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NONE"];  case 1:  	return BUNDLE ["LOW_GAIN_UP"];  case 2:  	return BUNDLE ["LOW_GAIN_DOWN"];  case 3:  	return BUNDLE ["HIGH_GAIN_UP"];  case 4:  	return BUNDLE ["HIGH_GAIN_DOWN"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetGainControlDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NONE"];  case 1:  	return BUNDLE ["LOW_GAIN_UP"];  case 2:  	return BUNDLE ["LOW_GAIN_DOWN"];  case 3:  	return BUNDLE ["HIGH_GAIN_UP"];  case 4:  	return BUNDLE ["HIGH_GAIN_DOWN"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetContrastDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NONE"];  case 1:  	return BUNDLE ["SOFT"];  case 2:  	return BUNDLE ["HARD"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,getSubfileTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FULL_RESOLUTION_IMAGE"];  case 2:  	return BUNDLE ["REDUCED_RESOLUTION_IMAGE"];  case 3:  	return BUNDLE ["SINGLE_PAGE_OF_MULTI_PAGE_IMAGE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,getSubfileTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FULL_RESOLUTION_IMAGE"];  case 2:  	return BUNDLE ["REDUCED_RESOLUTION_IMAGE"];  case 3:  	return BUNDLE ["SINGLE_PAGE_OF_MULTI_PAGE_IMAGE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetNewSubfileTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FULL_RESOLUTION_IMAGE"];  case 2:  	return BUNDLE ["REDUCED_RESOLUTION_IMAGE"];  case 3:  	return BUNDLE ["SINGLE_PAGE_OF_MULTI_PAGE_REDUCED_RESOLUTION_IMAGE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_IMAGE"];  case 6:  	return BUNDLE ["TRANSPARENCY_MASK_OF_MULTI_PAGE_IMAGE"];  case 7:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_MULTI_PAGE_IMAGE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetNewSubfileTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FULL_RESOLUTION_IMAGE"];  case 2:  	return BUNDLE ["REDUCED_RESOLUTION_IMAGE"];  case 3:  	return BUNDLE ["SINGLE_PAGE_OF_MULTI_PAGE_REDUCED_RESOLUTION_IMAGE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_IMAGE"];  case 6:  	return BUNDLE ["TRANSPARENCY_MASK_OF_MULTI_PAGE_IMAGE"];  case 7:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_MULTI_PAGE_IMAGE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetNewSubfileTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FULL_RESOLUTION_IMAGE"];  case 2:  	return BUNDLE ["REDUCED_RESOLUTION_IMAGE"];  case 3:  	return BUNDLE ["SINGLE_PAGE_OF_MULTI_PAGE_REDUCED_RESOLUTION_IMAGE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_IMAGE"];  case 6:  	return BUNDLE ["TRANSPARENCY_MASK_OF_MULTI_PAGE_IMAGE"];  case 7:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_MULTI_PAGE_IMAGE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetNewSubfileTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FULL_RESOLUTION_IMAGE"];  case 2:  	return BUNDLE ["REDUCED_RESOLUTION_IMAGE"];  case 3:  	return BUNDLE ["SINGLE_PAGE_OF_MULTI_PAGE_REDUCED_RESOLUTION_IMAGE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_IMAGE"];  case 6:  	return BUNDLE ["TRANSPARENCY_MASK_OF_MULTI_PAGE_IMAGE"];  case 7:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_MULTI_PAGE_IMAGE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetNewSubfileTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FULL_RESOLUTION_IMAGE"];  case 2:  	return BUNDLE ["REDUCED_RESOLUTION_IMAGE"];  case 3:  	return BUNDLE ["SINGLE_PAGE_OF_MULTI_PAGE_REDUCED_RESOLUTION_IMAGE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_IMAGE"];  case 6:  	return BUNDLE ["TRANSPARENCY_MASK_OF_MULTI_PAGE_IMAGE"];  case 7:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_MULTI_PAGE_IMAGE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetNewSubfileTypeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["FULL_RESOLUTION_IMAGE"];  case 2:  	return BUNDLE ["REDUCED_RESOLUTION_IMAGE"];  case 3:  	return BUNDLE ["SINGLE_PAGE_OF_MULTI_PAGE_REDUCED_RESOLUTION_IMAGE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_IMAGE"];  case 6:  	return BUNDLE ["TRANSPARENCY_MASK_OF_MULTI_PAGE_IMAGE"];  case 7:  	return BUNDLE ["TRANSPARENCY_MASK_OF_REDUCED_RESOLUTION_MULTI_PAGE_IMAGE"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetThresholdingDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["NO_DITHERING_OR_HALFTONING"];  case 2:  	return BUNDLE ["ORDERED_DITHER_OR_HALFTONE"];  case 3:  	return BUNDLE ["RANDOMIZED_DITHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetThresholdingDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["NO_DITHERING_OR_HALFTONING"];  case 2:  	return BUNDLE ["ORDERED_DITHER_OR_HALFTONE"];  case 3:  	return BUNDLE ["RANDOMIZED_DITHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetFillOrderDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["NORMAL"];  case 2:  	return BUNDLE ["REVERSED"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSubjectDistanceRangeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MACRO"];  case 2:  	return BUNDLE ["CLOSE_VIEW"];  case 3:  	return BUNDLE ["DISTANT_VIEW"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSubjectDistanceRangeDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MACRO"];  case 2:  	return BUNDLE ["CLOSE_VIEW"];  case 3:  	return BUNDLE ["DISTANT_VIEW"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSharpnessDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NONE"];  case 1:  	return BUNDLE ["LOW"];  case 2:  	return BUNDLE ["HARD"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSaturationDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["NONE"];  case 1:  	return BUNDLE ["LOW_SATURATION"];  case 2:  	return BUNDLE ["HIGH_SATURATION"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetIsoEquivalentDescription,The following statement contains a magic number: if (lcIsoEquiv < 50) {  	lcIsoEquiv *= 200;  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetIsoEquivalentDescription,The following statement contains a magic number: if (lcIsoEquiv < 50) {  	lcIsoEquiv *= 200;  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetIsoEquivalentDescription,The following statement contains a magic number: lcIsoEquiv *= 200;  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetFileSourceDescription,The following statement contains a magic number: if (lcFileSource == 3) {  	return BUNDLE ["DIGITAL_STILL_CAMERA"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureProgramDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MANUAL_CONTROL"];  case 2:  	return BUNDLE ["PROGRAM_NORMAL"];  case 3:  	return BUNDLE ["APERTURE_PRIORITY"];  case 4:  	return BUNDLE ["SHUTTER_PRIORITY"];  case 5:  	return BUNDLE ["PROGRAM_CREATIVE"];  case 6:  	return BUNDLE ["PROGRAM_ACTION"];  case 7:  	return BUNDLE ["PORTRAIT_MODE"];  case 8:  	return BUNDLE ["LANDSCAPE_MODE"];  default:  	return BUNDLE ["UNKNOWN_PROGRAM"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureProgramDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MANUAL_CONTROL"];  case 2:  	return BUNDLE ["PROGRAM_NORMAL"];  case 3:  	return BUNDLE ["APERTURE_PRIORITY"];  case 4:  	return BUNDLE ["SHUTTER_PRIORITY"];  case 5:  	return BUNDLE ["PROGRAM_CREATIVE"];  case 6:  	return BUNDLE ["PROGRAM_ACTION"];  case 7:  	return BUNDLE ["PORTRAIT_MODE"];  case 8:  	return BUNDLE ["LANDSCAPE_MODE"];  default:  	return BUNDLE ["UNKNOWN_PROGRAM"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureProgramDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MANUAL_CONTROL"];  case 2:  	return BUNDLE ["PROGRAM_NORMAL"];  case 3:  	return BUNDLE ["APERTURE_PRIORITY"];  case 4:  	return BUNDLE ["SHUTTER_PRIORITY"];  case 5:  	return BUNDLE ["PROGRAM_CREATIVE"];  case 6:  	return BUNDLE ["PROGRAM_ACTION"];  case 7:  	return BUNDLE ["PORTRAIT_MODE"];  case 8:  	return BUNDLE ["LANDSCAPE_MODE"];  default:  	return BUNDLE ["UNKNOWN_PROGRAM"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureProgramDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MANUAL_CONTROL"];  case 2:  	return BUNDLE ["PROGRAM_NORMAL"];  case 3:  	return BUNDLE ["APERTURE_PRIORITY"];  case 4:  	return BUNDLE ["SHUTTER_PRIORITY"];  case 5:  	return BUNDLE ["PROGRAM_CREATIVE"];  case 6:  	return BUNDLE ["PROGRAM_ACTION"];  case 7:  	return BUNDLE ["PORTRAIT_MODE"];  case 8:  	return BUNDLE ["LANDSCAPE_MODE"];  default:  	return BUNDLE ["UNKNOWN_PROGRAM"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureProgramDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MANUAL_CONTROL"];  case 2:  	return BUNDLE ["PROGRAM_NORMAL"];  case 3:  	return BUNDLE ["APERTURE_PRIORITY"];  case 4:  	return BUNDLE ["SHUTTER_PRIORITY"];  case 5:  	return BUNDLE ["PROGRAM_CREATIVE"];  case 6:  	return BUNDLE ["PROGRAM_ACTION"];  case 7:  	return BUNDLE ["PORTRAIT_MODE"];  case 8:  	return BUNDLE ["LANDSCAPE_MODE"];  default:  	return BUNDLE ["UNKNOWN_PROGRAM"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureProgramDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MANUAL_CONTROL"];  case 2:  	return BUNDLE ["PROGRAM_NORMAL"];  case 3:  	return BUNDLE ["APERTURE_PRIORITY"];  case 4:  	return BUNDLE ["SHUTTER_PRIORITY"];  case 5:  	return BUNDLE ["PROGRAM_CREATIVE"];  case 6:  	return BUNDLE ["PROGRAM_ACTION"];  case 7:  	return BUNDLE ["PORTRAIT_MODE"];  case 8:  	return BUNDLE ["LANDSCAPE_MODE"];  default:  	return BUNDLE ["UNKNOWN_PROGRAM"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetExposureProgramDescription,The following statement contains a magic number: switch (lcVal) {  case 1:  	return BUNDLE ["MANUAL_CONTROL"];  case 2:  	return BUNDLE ["PROGRAM_NORMAL"];  case 3:  	return BUNDLE ["APERTURE_PRIORITY"];  case 4:  	return BUNDLE ["SHUTTER_PRIORITY"];  case 5:  	return BUNDLE ["PROGRAM_CREATIVE"];  case 6:  	return BUNDLE ["PROGRAM_ACTION"];  case 7:  	return BUNDLE ["PORTRAIT_MODE"];  case 8:  	return BUNDLE ["LANDSCAPE_MODE"];  default:  	return BUNDLE ["UNKNOWN_PROGRAM"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetYCbCrSubsamplingDescription,The following statement contains a magic number: if (lcPositions [0] == 2 && lcPositions [1] == 1) {  	return BUNDLE ["YCBCR_422"];  } else if (lcPositions [0] == 2 && lcPositions [1] == 2) {  	return BUNDLE ["YCBCR_420"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetYCbCrSubsamplingDescription,The following statement contains a magic number: if (lcPositions [0] == 2 && lcPositions [1] == 1) {  	return BUNDLE ["YCBCR_422"];  } else if (lcPositions [0] == 2 && lcPositions [1] == 2) {  	return BUNDLE ["YCBCR_420"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetYCbCrSubsamplingDescription,The following statement contains a magic number: if (lcPositions [0] == 2 && lcPositions [1] == 1) {  	return BUNDLE ["YCBCR_422"];  } else if (lcPositions [0] == 2 && lcPositions [1] == 2) {  	return BUNDLE ["YCBCR_420"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetYCbCrSubsamplingDescription,The following statement contains a magic number: if (lcPositions [0] == 2 && lcPositions [1] == 2) {  	return BUNDLE ["YCBCR_420"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetYCbCrSubsamplingDescription,The following statement contains a magic number: if (lcPositions [0] == 2 && lcPositions [1] == 2) {  	return BUNDLE ["YCBCR_420"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPlanarConfigurationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PLANAR_CONFIGURATION)) {  case 1:  	return BUNDLE ["CHUNKY"];  case 2:  	return BUNDLE ["SEPARATE"];  default:  	return BUNDLE ["UNKNOWN_CONFIGURATION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetPhotometricInterpretationDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_PHOTOMETRIC_INTERPRETATION)) {  case 0:  	return BUNDLE ["WHITE_IS_ZERO"];  case 1:  	return BUNDLE ["BLACK_IS_ZERO"];  case 2:  	return BUNDLE ["RGB"];  case 3:  	return BUNDLE ["RGB_PALETTE"];  case 4:  	return BUNDLE ["TRANSPARENCY_MASK"];  case 5:  	return BUNDLE ["CMYK"];  case 6:  	return BUNDLE ["YCBCR"];  case 8:  	return BUNDLE ["CIELAB"];  case 9:  	return BUNDLE ["ICCLAB"];  case 10:  	return BUNDLE ["ITULAB"];  case 32803:  	return BUNDLE ["COLOR_FILTER_ARRAY"];  case 32844:  	return BUNDLE ["PIXAR_LOGL"];  case 32845:  	return BUNDLE ["PIXAR_LOGLUV"];  case 32892:  	return BUNDLE ["LINEAR_RAW"];  default:  	return BUNDLE ["UNKNOWN_COLOR_SPACE"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetCompressionDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_COMPRESSION)) {  case 1:  	return BUNDLE ["UNCOMPRESSED"];  case 2:  	return BUNDLE ["CCITT_1D"];  case 3:  	return BUNDLE ["T4_GROUP_3_FAC"];  case 4:  	return BUNDLE ["T6_GROUP_4_FAC"];  case 5:  	return BUNDLE ["LZW"];  case 6:  	return BUNDLE ["JPEG_OLD_STYLE"];  case 7:  	return BUNDLE ["JPEG"];  case 8:  	return BUNDLE ["ADOBE_DEFLATE"];  case 9:  	return BUNDLE ["JBIG_B_W"];  case 10:  	return BUNDLE ["JBIG_COLOR"];  case 32766:  	return BUNDLE ["NEXT"];  case 32771:  	return BUNDLE ["CCIRLEW"];  case 32773:  	return BUNDLE ["PACKBITS"];  case 32809:  	return BUNDLE ["THUNDERSCA"];  case 32895:  	return BUNDLE ["IT8CTPAD"];  case 32896:  	return BUNDLE ["IT8LW"];  case 32897:  	return BUNDLE ["IT8MP"];  case 32898:  	return BUNDLE ["IT8BL"];  case 32908:  	return BUNDLE ["PIXARFILM"];  case 32909:  	return BUNDLE ["PIXARLOG"];  case 32946:  	return BUNDLE ["DEFLATE"];  case 32947:  	return BUNDLE ["DCS"];  case 32661:  	return BUNDLE ["JBIG"];  case 32676:  	return BUNDLE ["SGILOG"];  case 32677:  	return BUNDLE ["SGILOG24"];  case 32712:  	return BUNDLE ["JPEG_2000"];  case 32713:  	return BUNDLE ["NIKON_NEF_COMPRESSED"];  default:  	return BUNDLE ["UNKNOWN_COMPRESSION"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetFocalPlaneResolutionUnitDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_FOCAL_PLANE_UNIT)) {  case 1:  	return BUNDLE ["NO_UNIT"];  case 2:  	return BUNDLE ["INCHES"];  case 3:  	return BUNDLE ["CM"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetFocalPlaneResolutionUnitDescription,The following statement contains a magic number: switch (base.directory.GetInt (ExifDirectory.TAG_FOCAL_PLANE_UNIT)) {  case 1:  	return BUNDLE ["NO_UNIT"];  case 2:  	return BUNDLE ["INCHES"];  case 3:  	return BUNDLE ["CM"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetColorSpaceDescription,The following statement contains a magic number: switch (lcColorSpace) {  case 1:  	return BUNDLE ["SRGB"];  case 65535:  	return BUNDLE ["UNDEFINED"];  default:  	return BUNDLE ["UNKNOWN"];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetLightSourceDescription,The following statement contains a magic number: switch (lcVal) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["DAYLIGHT"];  case 2:  	return BUNDLE ["FLUORESCENT"];  case 3:  	return BUNDLE ["TUNGSTEN"];  case 10:  	return BUNDLE ["FLASH"];  case 17:  	return BUNDLE ["STANDARD_LIGHT"];  case 18:  	return BUNDLE ["STANDARD_LIGHT_B"];  case 19:  	return BUNDLE ["STANDARD_LIGHT_C"];  case 20:  	return BUNDLE ["D55"];  case 21:  	return BUNDLE ["D65"];  case 22:  	return BUNDLE ["D75"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return BUNDLE ["UNKNOWN"' lcVal.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcMeteringMode) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["AVERAGE"];  case 2:  	return BUNDLE ["CENTER_WEIGHTED_AVERAGE"];  case 3:  	return BUNDLE ["SPOT"];  case 4:  	return BUNDLE ["MULTI_SPOT"];  case 5:  	return BUNDLE ["MULTI_SEGMENT"];  case 6:  	return BUNDLE ["PARTIAL"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcMeteringMode) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["AVERAGE"];  case 2:  	return BUNDLE ["CENTER_WEIGHTED_AVERAGE"];  case 3:  	return BUNDLE ["SPOT"];  case 4:  	return BUNDLE ["MULTI_SPOT"];  case 5:  	return BUNDLE ["MULTI_SEGMENT"];  case 6:  	return BUNDLE ["PARTIAL"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcMeteringMode) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["AVERAGE"];  case 2:  	return BUNDLE ["CENTER_WEIGHTED_AVERAGE"];  case 3:  	return BUNDLE ["SPOT"];  case 4:  	return BUNDLE ["MULTI_SPOT"];  case 5:  	return BUNDLE ["MULTI_SEGMENT"];  case 6:  	return BUNDLE ["PARTIAL"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcMeteringMode) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["AVERAGE"];  case 2:  	return BUNDLE ["CENTER_WEIGHTED_AVERAGE"];  case 3:  	return BUNDLE ["SPOT"];  case 4:  	return BUNDLE ["MULTI_SPOT"];  case 5:  	return BUNDLE ["MULTI_SEGMENT"];  case 6:  	return BUNDLE ["PARTIAL"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcMeteringMode) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["AVERAGE"];  case 2:  	return BUNDLE ["CENTER_WEIGHTED_AVERAGE"];  case 3:  	return BUNDLE ["SPOT"];  case 4:  	return BUNDLE ["MULTI_SPOT"];  case 5:  	return BUNDLE ["MULTI_SEGMENT"];  case 6:  	return BUNDLE ["PARTIAL"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetMeteringModeDescription,The following statement contains a magic number: switch (lcMeteringMode) {  case 0:  	return BUNDLE ["UNKNOWN"];  case 1:  	return BUNDLE ["AVERAGE"];  case 2:  	return BUNDLE ["CENTER_WEIGHTED_AVERAGE"];  case 3:  	return BUNDLE ["SPOT"];  case 4:  	return BUNDLE ["MULTI_SPOT"];  case 5:  	return BUNDLE ["MULTI_SEGMENT"];  case 6:  	return BUNDLE ["PARTIAL"];  case 255:  	return BUNDLE ["OTHER"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetShutterSpeedDescription,The following statement contains a magic number: if (lcApexValue <= 1) {  	float lcApexPower = (float)(1 / (Math.Exp (lcApexValue * Math.Log (2))));  	long lcApexPower10 = (long)Math.Round ((double)lcApexPower * 10.0);  	float lcFApexPower = (float)lcApexPower10 / 10.0f;  	return BUNDLE ["SHUTTER_SPEED_SEC"' lcFApexPower.ToString ()];  } else {  	int apexPower = (int)((Math.Exp (lcApexValue * Math.Log (2))));  	return BUNDLE ["SHUTTER_SPEED"' apexPower.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetShutterSpeedDescription,The following statement contains a magic number: if (lcApexValue <= 1) {  	float lcApexPower = (float)(1 / (Math.Exp (lcApexValue * Math.Log (2))));  	long lcApexPower10 = (long)Math.Round ((double)lcApexPower * 10.0);  	float lcFApexPower = (float)lcApexPower10 / 10.0f;  	return BUNDLE ["SHUTTER_SPEED_SEC"' lcFApexPower.ToString ()];  } else {  	int apexPower = (int)((Math.Exp (lcApexValue * Math.Log (2))));  	return BUNDLE ["SHUTTER_SPEED"' apexPower.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetShutterSpeedDescription,The following statement contains a magic number: if (lcApexValue <= 1) {  	float lcApexPower = (float)(1 / (Math.Exp (lcApexValue * Math.Log (2))));  	long lcApexPower10 = (long)Math.Round ((double)lcApexPower * 10.0);  	float lcFApexPower = (float)lcApexPower10 / 10.0f;  	return BUNDLE ["SHUTTER_SPEED_SEC"' lcFApexPower.ToString ()];  } else {  	int apexPower = (int)((Math.Exp (lcApexValue * Math.Log (2))));  	return BUNDLE ["SHUTTER_SPEED"' apexPower.ToString ()];  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetYCbCrPositioningDescription,The following statement contains a magic number: switch (lcYCbCrPosition) {  case 1:  	return BUNDLE ["CENTER_OF_PIXEL_ARRAY"];  case 2:  	return BUNDLE ["DATUM_POINT"];  default:  	return lcYCbCrPosition.ToString ();  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetOrientationDescription,The following statement contains a magic number: switch (lcOrientation) {  case 1:  	return BUNDLE ["TOP_LEFT_SIDE"];  case 2:  	return BUNDLE ["TOP_RIGHT_SIDE"];  case 3:  	return BUNDLE ["BOTTOM_RIGHT_SIDE"];  case 4:  	return BUNDLE ["BOTTOM_LEFT_SIDE"];  case 5:  	return BUNDLE ["LEFT_SIDE_TOP"];  case 6:  	return BUNDLE ["RIGHT_SIDE_TOP"];  case 7:  	return BUNDLE ["RIGHT_SIDE_BOTTOM"];  case 8:  	return BUNDLE ["LEFT_SIDE_BOTTOM"];  default:  	return lcOrientation.ToString ();  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetOrientationDescription,The following statement contains a magic number: switch (lcOrientation) {  case 1:  	return BUNDLE ["TOP_LEFT_SIDE"];  case 2:  	return BUNDLE ["TOP_RIGHT_SIDE"];  case 3:  	return BUNDLE ["BOTTOM_RIGHT_SIDE"];  case 4:  	return BUNDLE ["BOTTOM_LEFT_SIDE"];  case 5:  	return BUNDLE ["LEFT_SIDE_TOP"];  case 6:  	return BUNDLE ["RIGHT_SIDE_TOP"];  case 7:  	return BUNDLE ["RIGHT_SIDE_BOTTOM"];  case 8:  	return BUNDLE ["LEFT_SIDE_BOTTOM"];  default:  	return lcOrientation.ToString ();  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetOrientationDescription,The following statement contains a magic number: switch (lcOrientation) {  case 1:  	return BUNDLE ["TOP_LEFT_SIDE"];  case 2:  	return BUNDLE ["TOP_RIGHT_SIDE"];  case 3:  	return BUNDLE ["BOTTOM_RIGHT_SIDE"];  case 4:  	return BUNDLE ["BOTTOM_LEFT_SIDE"];  case 5:  	return BUNDLE ["LEFT_SIDE_TOP"];  case 6:  	return BUNDLE ["RIGHT_SIDE_TOP"];  case 7:  	return BUNDLE ["RIGHT_SIDE_BOTTOM"];  case 8:  	return BUNDLE ["LEFT_SIDE_BOTTOM"];  default:  	return lcOrientation.ToString ();  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetOrientationDescription,The following statement contains a magic number: switch (lcOrientation) {  case 1:  	return BUNDLE ["TOP_LEFT_SIDE"];  case 2:  	return BUNDLE ["TOP_RIGHT_SIDE"];  case 3:  	return BUNDLE ["BOTTOM_RIGHT_SIDE"];  case 4:  	return BUNDLE ["BOTTOM_LEFT_SIDE"];  case 5:  	return BUNDLE ["LEFT_SIDE_TOP"];  case 6:  	return BUNDLE ["RIGHT_SIDE_TOP"];  case 7:  	return BUNDLE ["RIGHT_SIDE_BOTTOM"];  case 8:  	return BUNDLE ["LEFT_SIDE_BOTTOM"];  default:  	return lcOrientation.ToString ();  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetOrientationDescription,The following statement contains a magic number: switch (lcOrientation) {  case 1:  	return BUNDLE ["TOP_LEFT_SIDE"];  case 2:  	return BUNDLE ["TOP_RIGHT_SIDE"];  case 3:  	return BUNDLE ["BOTTOM_RIGHT_SIDE"];  case 4:  	return BUNDLE ["BOTTOM_LEFT_SIDE"];  case 5:  	return BUNDLE ["LEFT_SIDE_TOP"];  case 6:  	return BUNDLE ["RIGHT_SIDE_TOP"];  case 7:  	return BUNDLE ["RIGHT_SIDE_BOTTOM"];  case 8:  	return BUNDLE ["LEFT_SIDE_BOTTOM"];  default:  	return lcOrientation.ToString ();  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetOrientationDescription,The following statement contains a magic number: switch (lcOrientation) {  case 1:  	return BUNDLE ["TOP_LEFT_SIDE"];  case 2:  	return BUNDLE ["TOP_RIGHT_SIDE"];  case 3:  	return BUNDLE ["BOTTOM_RIGHT_SIDE"];  case 4:  	return BUNDLE ["BOTTOM_LEFT_SIDE"];  case 5:  	return BUNDLE ["LEFT_SIDE_TOP"];  case 6:  	return BUNDLE ["RIGHT_SIDE_TOP"];  case 7:  	return BUNDLE ["RIGHT_SIDE_BOTTOM"];  case 8:  	return BUNDLE ["LEFT_SIDE_BOTTOM"];  default:  	return lcOrientation.ToString ();  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetOrientationDescription,The following statement contains a magic number: switch (lcOrientation) {  case 1:  	return BUNDLE ["TOP_LEFT_SIDE"];  case 2:  	return BUNDLE ["TOP_RIGHT_SIDE"];  case 3:  	return BUNDLE ["BOTTOM_RIGHT_SIDE"];  case 4:  	return BUNDLE ["BOTTOM_LEFT_SIDE"];  case 5:  	return BUNDLE ["LEFT_SIDE_TOP"];  case 6:  	return BUNDLE ["RIGHT_SIDE_TOP"];  case 7:  	return BUNDLE ["RIGHT_SIDE_BOTTOM"];  case 8:  	return BUNDLE ["LEFT_SIDE_BOTTOM"];  default:  	return lcOrientation.ToString ();  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetResolutionDescription,The following statement contains a magic number: switch (lcResolutionUnit) {  case 1:  	return BUNDLE ["NO_UNIT"];  case 2:  	return BUNDLE ["INCHES"];  case 3:  	return BUNDLE ["CM"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetResolutionDescription,The following statement contains a magic number: switch (lcResolutionUnit) {  case 1:  	return BUNDLE ["NO_UNIT"];  case 2:  	return BUNDLE ["INCHES"];  case 3:  	return BUNDLE ["CM"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSensingMethodDescription,The following statement contains a magic number: switch (lcSensingMethod) {  case 1:  	return BUNDLE ["NOT_DEFINED"];  case 2:  	return BUNDLE ["ONE_CHIP_COLOR"];  case 3:  	return BUNDLE ["TWO_CHIP_COLOR"];  case 4:  	return BUNDLE ["THREE_CHIP_COLOR"];  case 5:  	return BUNDLE ["COLOR_SEQUENTIAL"];  case 7:  	return BUNDLE ["TRILINEAR_SENSOR"];  case 8:  	return BUNDLE ["COLOR_SEQUENTIAL_LINEAR"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSensingMethodDescription,The following statement contains a magic number: switch (lcSensingMethod) {  case 1:  	return BUNDLE ["NOT_DEFINED"];  case 2:  	return BUNDLE ["ONE_CHIP_COLOR"];  case 3:  	return BUNDLE ["TWO_CHIP_COLOR"];  case 4:  	return BUNDLE ["THREE_CHIP_COLOR"];  case 5:  	return BUNDLE ["COLOR_SEQUENTIAL"];  case 7:  	return BUNDLE ["TRILINEAR_SENSOR"];  case 8:  	return BUNDLE ["COLOR_SEQUENTIAL_LINEAR"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSensingMethodDescription,The following statement contains a magic number: switch (lcSensingMethod) {  case 1:  	return BUNDLE ["NOT_DEFINED"];  case 2:  	return BUNDLE ["ONE_CHIP_COLOR"];  case 3:  	return BUNDLE ["TWO_CHIP_COLOR"];  case 4:  	return BUNDLE ["THREE_CHIP_COLOR"];  case 5:  	return BUNDLE ["COLOR_SEQUENTIAL"];  case 7:  	return BUNDLE ["TRILINEAR_SENSOR"];  case 8:  	return BUNDLE ["COLOR_SEQUENTIAL_LINEAR"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSensingMethodDescription,The following statement contains a magic number: switch (lcSensingMethod) {  case 1:  	return BUNDLE ["NOT_DEFINED"];  case 2:  	return BUNDLE ["ONE_CHIP_COLOR"];  case 3:  	return BUNDLE ["TWO_CHIP_COLOR"];  case 4:  	return BUNDLE ["THREE_CHIP_COLOR"];  case 5:  	return BUNDLE ["COLOR_SEQUENTIAL"];  case 7:  	return BUNDLE ["TRILINEAR_SENSOR"];  case 8:  	return BUNDLE ["COLOR_SEQUENTIAL_LINEAR"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSensingMethodDescription,The following statement contains a magic number: switch (lcSensingMethod) {  case 1:  	return BUNDLE ["NOT_DEFINED"];  case 2:  	return BUNDLE ["ONE_CHIP_COLOR"];  case 3:  	return BUNDLE ["TWO_CHIP_COLOR"];  case 4:  	return BUNDLE ["THREE_CHIP_COLOR"];  case 5:  	return BUNDLE ["COLOR_SEQUENTIAL"];  case 7:  	return BUNDLE ["TRILINEAR_SENSOR"];  case 8:  	return BUNDLE ["COLOR_SEQUENTIAL_LINEAR"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetSensingMethodDescription,The following statement contains a magic number: switch (lcSensingMethod) {  case 1:  	return BUNDLE ["NOT_DEFINED"];  case 2:  	return BUNDLE ["ONE_CHIP_COLOR"];  case 3:  	return BUNDLE ["TWO_CHIP_COLOR"];  case 4:  	return BUNDLE ["THREE_CHIP_COLOR"];  case 5:  	return BUNDLE ["COLOR_SEQUENTIAL"];  case 7:  	return BUNDLE ["TRILINEAR_SENSOR"];  case 8:  	return BUNDLE ["COLOR_SEQUENTIAL_LINEAR"];  default:  	return "";  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,GetComponentConfigurationDescription,The following statement contains a magic number: for (int i = 0; i < Math.Min (4' lcComponents.Length); i++) {  	int lcId = lcComponents [i];  	if (lcId > 0 && lcId < lcComponentStrings.Length) {  		lcComponentConfig.Append (lcComponentStrings [lcId]);  	}  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,ConvertBytesToVersionString,The following statement contains a magic number: for (int i = 0; i < 4 && i < someComponents.Length; i++) {  	// In order to avoid strange characters in some version (like Nikon)  	if (someComponents [i] > 31) {  		if (i == 2) {  			lcVersion.Append ('.');  		}  		string digit = ((char)someComponents [i]).ToString ();  		if (i == 0 && "0".Equals (digit)) {  			continue;  		}  		lcVersion.Append (digit);  	}  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,ConvertBytesToVersionString,The following statement contains a magic number: for (int i = 0; i < 4 && i < someComponents.Length; i++) {  	// In order to avoid strange characters in some version (like Nikon)  	if (someComponents [i] > 31) {  		if (i == 2) {  			lcVersion.Append ('.');  		}  		string digit = ((char)someComponents [i]).ToString ();  		if (i == 0 && "0".Equals (digit)) {  			continue;  		}  		lcVersion.Append (digit);  	}  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,ConvertBytesToVersionString,The following statement contains a magic number: for (int i = 0; i < 4 && i < someComponents.Length; i++) {  	// In order to avoid strange characters in some version (like Nikon)  	if (someComponents [i] > 31) {  		if (i == 2) {  			lcVersion.Append ('.');  		}  		string digit = ((char)someComponents [i]).ToString ();  		if (i == 0 && "0".Equals (digit)) {  			continue;  		}  		lcVersion.Append (digit);  	}  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,ConvertBytesToVersionString,The following statement contains a magic number: if (someComponents [i] > 31) {  	if (i == 2) {  		lcVersion.Append ('.');  	}  	string digit = ((char)someComponents [i]).ToString ();  	if (i == 0 && "0".Equals (digit)) {  		continue;  	}  	lcVersion.Append (digit);  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,ConvertBytesToVersionString,The following statement contains a magic number: if (someComponents [i] > 31) {  	if (i == 2) {  		lcVersion.Append ('.');  	}  	string digit = ((char)someComponents [i]).ToString ();  	if (i == 0 && "0".Equals (digit)) {  		continue;  	}  	lcVersion.Append (digit);  }  
Magic Number,com.drew.metadata.exif,ExifDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifDescriptor.cs,ConvertBytesToVersionString,The following statement contains a magic number: if (i == 2) {  	lcVersion.Append ('.');  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ExtractIFD,The following statement contains a magic number: if (this.Get16Bits (2 + aTiffHeaderOffset) != 0x2a) {  	//  directory.AddError("Invalid Exif start - should have 0x2A at offset 8 in Exif header");  	//  return this.metadata;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ExtractIFD,The following statement contains a magic number: if (firstDirectoryOffset >= base.data.Length - 1) {  	directory.HasError = true;  	Trace.TraceError ("First exif directory offset is beyond end of Exif data segment");  	// First directory normally starts 14 bytes in -- try it here and catch another error in the worst case  	firstDirectoryOffset = 14;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ExtractIFD,The following statement contains a magic number: firstDirectoryOffset = 14;  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Extract,The following statement contains a magic number: if (base.data.Length <= 14) {  	directory.HasError = true;  	Trace.TraceError ("Exif data segment must contain at least 14 bytes");  	return this.metadata;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Extract,The following statement contains a magic number: if (!"Exif\0\0".Equals (Utils.Decode (base.data' 0' 6' false))) {  	directory.HasError = true;  	Trace.TraceError ("Exif data segment doesn't begin with 'Exif'");  	return this.metadata;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Extract,The following statement contains a magic number: if (Get16Bits (8) != 0x2a) {  	directory.HasError = true;  	Trace.TraceError ("Invalid Exif start - should have 0x2A at offSet 8 in Exif header");  	return this.metadata;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Extract,The following statement contains a magic number: if (firstDirectoryOffSet >= base.data.Length - 1) {  	directory.HasError = true;  	Trace.TraceError ("First exif directory offSet is beyond end of Exif data segment");  	// First directory normally starts 14 bytes in -- try it here and catch another error in the worst case  	firstDirectoryOffSet = 14;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Extract,The following statement contains a magic number: firstDirectoryOffSet = 14;  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,CalculateTagOffset,The following statement contains a magic number: return dirStartOffset + 2 + (12 * entryNumber);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,CalculateTagOffset,The following statement contains a magic number: return dirStartOffset + 2 + (12 * entryNumber);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,CalculateTagValueOffset,The following statement contains a magic number: if (byteCount > 4) {  	// If its bigger than 4 bytes' the dir entry contains an lcOffset.  	// dirEntryOffset must be passed' as some makernote implementations (e.g. FujiFilm) incorrectly use an  	// lcOffset relative to the start of the makernote itself' not the TIFF segment.  	int offsetVal = Get32Bits (dirEntryOffset + 8);  	if (offsetVal + byteCount > base.data.Length) {  		// Bogus pointer lcOffset and / or bytecount value  		return -1;  		// signal error  	}  	return tiffHeaderOffset + offsetVal;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,CalculateTagValueOffset,The following statement contains a magic number: if (byteCount > 4) {  	// If its bigger than 4 bytes' the dir entry contains an lcOffset.  	// dirEntryOffset must be passed' as some makernote implementations (e.g. FujiFilm) incorrectly use an  	// lcOffset relative to the start of the makernote itself' not the TIFF segment.  	int offsetVal = Get32Bits (dirEntryOffset + 8);  	if (offsetVal + byteCount > base.data.Length) {  		// Bogus pointer lcOffset and / or bytecount value  		return -1;  		// signal error  	}  	return tiffHeaderOffset + offsetVal;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,CalculateTagValueOffset,The following statement contains a magic number: return dirEntryOffset + 8;  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,The following statement contains a magic number: for (int tagNumber = 0; tagNumber < dirTagCount; tagNumber++) {  	int tagOffset = CalculateTagOffset (dirStartOffset' tagNumber);  	// 2 bytes for the tag type  	int tagType = Get16Bits (tagOffset);  	// 2 bytes for the format code  	int formatCode = Get16Bits (tagOffset + 2);  	if (formatCode < 1 || formatCode > MAX_FORMAT_CODE) {  		directory.HasError = true;  		Trace.TraceError ("Invalid format code: " + formatCode);  		continue;  	}  	// 4 bytes dictate the number of components in this tag'lcStr data  	int componentCount = Get32Bits (tagOffset + 4);  	if (componentCount < 0) {  		directory.HasError = true;  		Trace.TraceError ("Negative component count in EXIF");  		continue;  	}  	// each component may have more than one byte... calculate the total number of bytes  	int byteCount = componentCount * BYTES_PER_FORMAT [formatCode];  	int tagValueOffset = CalculateTagValueOffset (byteCount' tagOffset' tiffHeaderOffset);  	if (tagValueOffset < 0 || tagValueOffset > base.data.Length) {  		directory.HasError = true;  		Trace.TraceError ("Illegal pointer offset value in EXIF");  		continue;  	}  	// Check that this tag isn't going to allocate outside the bounds of the data array.  	// This addresses an uncommon OutOfMemoryError.  	if (byteCount < 0 || tagValueOffset + byteCount > base.data.Length) {  		directory.HasError = true;  		Trace.TraceError ("Illegal number of bytes: " + byteCount);  		continue;  	}  	// Calculate the value as an lcOffset for cases where the tag represents directory  	int subdirOffset = tiffHeaderOffset + Get32Bits (tagValueOffset);  	switch (tagType) {  	case TAG_EXIF_OFFSET:  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.ExifDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  		continue;  	case TAG_INTEROP_OFFSET:  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.ExifInteropDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  		continue;  	case TAG_GPS_INFO_OFFSET:  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.GpsDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  		continue;  	case TAG_MAKER_NOTE:  		ProcessMakerNote (tagValueOffset' processedDirectoryOffsets' tiffHeaderOffset);  		continue;  	default:  		ProcessTag (directory' tagType' tagValueOffset' componentCount' formatCode);  		break;  	}  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessDirectory,The following statement contains a magic number: for (int tagNumber = 0; tagNumber < dirTagCount; tagNumber++) {  	int tagOffset = CalculateTagOffset (dirStartOffset' tagNumber);  	// 2 bytes for the tag type  	int tagType = Get16Bits (tagOffset);  	// 2 bytes for the format code  	int formatCode = Get16Bits (tagOffset + 2);  	if (formatCode < 1 || formatCode > MAX_FORMAT_CODE) {  		directory.HasError = true;  		Trace.TraceError ("Invalid format code: " + formatCode);  		continue;  	}  	// 4 bytes dictate the number of components in this tag'lcStr data  	int componentCount = Get32Bits (tagOffset + 4);  	if (componentCount < 0) {  		directory.HasError = true;  		Trace.TraceError ("Negative component count in EXIF");  		continue;  	}  	// each component may have more than one byte... calculate the total number of bytes  	int byteCount = componentCount * BYTES_PER_FORMAT [formatCode];  	int tagValueOffset = CalculateTagValueOffset (byteCount' tagOffset' tiffHeaderOffset);  	if (tagValueOffset < 0 || tagValueOffset > base.data.Length) {  		directory.HasError = true;  		Trace.TraceError ("Illegal pointer offset value in EXIF");  		continue;  	}  	// Check that this tag isn't going to allocate outside the bounds of the data array.  	// This addresses an uncommon OutOfMemoryError.  	if (byteCount < 0 || tagValueOffset + byteCount > base.data.Length) {  		directory.HasError = true;  		Trace.TraceError ("Illegal number of bytes: " + byteCount);  		continue;  	}  	// Calculate the value as an lcOffset for cases where the tag represents directory  	int subdirOffset = tiffHeaderOffset + Get32Bits (tagValueOffset);  	switch (tagType) {  	case TAG_EXIF_OFFSET:  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.ExifDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  		continue;  	case TAG_INTEROP_OFFSET:  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.ExifInteropDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  		continue;  	case TAG_GPS_INFO_OFFSET:  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.GpsDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  		continue;  	case TAG_MAKER_NOTE:  		ProcessMakerNote (tagValueOffset' processedDirectoryOffsets' tiffHeaderOffset);  		continue;  	default:  		ProcessTag (directory' tagType' tagValueOffset' componentCount' formatCode);  		break;  	}  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("OLYMP".Equals (firstFiveChars) || "EPSON".Equals (firstFiveChars) || "AGFA".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found an Olympus/Epson/Agfa directory.");  	// Olympus Makernote  	// Epson and Agfa use Olypus maker note standard' see:  	//     http://www.ozhiker.com/electronics/pjmt/jpeg_info/  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.Trim ().ToUpper ().StartsWith ("NIKON")) {  	if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  		// There are two scenarios here:  		// Type 1:  		// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  		// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  		// Type 3:  		// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  		// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  		if (base.data [subdirOffset + 6] == 1) {  			Trace.TraceInformation ("Found an Nykon Type 1 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  		} else if (base.data [subdirOffset + 6] == 2) {  			Trace.TraceInformation ("Found an Nykon Type 2 directory.");  			ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  		} else {  			exifDirectory.HasError = true;  			Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  		}  	} else {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  	// There are two scenarios here:  	// Type 1:  	// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  	// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  	// Type 3:  	// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  	// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  	if (base.data [subdirOffset + 6] == 1) {  		Trace.TraceInformation ("Found an Nykon Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  	} else if (base.data [subdirOffset + 6] == 2) {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  	} else {  		exifDirectory.HasError = true;  		Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  	}  } else {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  	// There are two scenarios here:  	// Type 1:  	// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  	// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  	// Type 3:  	// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  	// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  	if (base.data [subdirOffset + 6] == 1) {  		Trace.TraceInformation ("Found an Nykon Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  	} else if (base.data [subdirOffset + 6] == 2) {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  	} else {  		exifDirectory.HasError = true;  		Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  	}  } else {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  	// There are two scenarios here:  	// Type 1:  	// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  	// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  	// Type 3:  	// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  	// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  	if (base.data [subdirOffset + 6] == 1) {  		Trace.TraceInformation ("Found an Nykon Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  	} else if (base.data [subdirOffset + 6] == 2) {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  	} else {  		exifDirectory.HasError = true;  		Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  	}  } else {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  	// There are two scenarios here:  	// Type 1:  	// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  	// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  	// Type 3:  	// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  	// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  	if (base.data [subdirOffset + 6] == 1) {  		Trace.TraceInformation ("Found an Nykon Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  	} else if (base.data [subdirOffset + 6] == 2) {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  	} else {  		exifDirectory.HasError = true;  		Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  	}  } else {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  	// There are two scenarios here:  	// Type 1:  	// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  	// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  	// Type 3:  	// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  	// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  	if (base.data [subdirOffset + 6] == 1) {  		Trace.TraceInformation ("Found an Nykon Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  	} else if (base.data [subdirOffset + 6] == 2) {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  	} else {  		exifDirectory.HasError = true;  		Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  	}  } else {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  	// There are two scenarios here:  	// Type 1:  	// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  	// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  	// Type 3:  	// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  	// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  	if (base.data [subdirOffset + 6] == 1) {  		Trace.TraceInformation ("Found an Nykon Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  	} else if (base.data [subdirOffset + 6] == 2) {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  	} else {  		exifDirectory.HasError = true;  		Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  	}  } else {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Nikon".Equals (Utils.Decode (base.data' subdirOffset' 5' false))) {  	// There are two scenarios here:  	// Type 1:  	// :0000: 4E 69 6B 6F 6E 00 01 00-05 00 02 00 02 00 06 00 Nikon...........  	// :0010: 00 00 EC 02 00 00 03 00-03 00 01 00 00 00 06 00 ................  	// Type 3:  	// :0000: 4E 69 6B 6F 6E 00 02 00-00 00 4D 4D 00 2A 00 00 Nikon....MM.*...  	// :0010: 00 08 00 1E 00 01 00 07-00 00 00 04 30 32 30 30 ............0200  	if (base.data [subdirOffset + 6] == 1) {  		Trace.TraceInformation ("Found an Nykon Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  	} else if (base.data [subdirOffset + 6] == 2) {  		Trace.TraceInformation ("Found an Nykon Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  	} else {  		exifDirectory.HasError = true;  		Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  	}  } else {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 1) {  	Trace.TraceInformation ("Found an Nykon Type 1 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 1) {  	Trace.TraceInformation ("Found an Nykon Type 1 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 1) {  	Trace.TraceInformation ("Found an Nykon Type 1 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 1) {  	Trace.TraceInformation ("Found an Nykon Type 1 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 1) {  	Trace.TraceInformation ("Found an Nykon Type 1 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 1) {  	Trace.TraceInformation ("Found an Nykon Type 1 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  } else if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType1Directory")' processedDirectoryOffsets' subdirOffset + 8' tiffHeaderOffset);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (base.data [subdirOffset + 6] == 2) {  	Trace.TraceInformation ("Found an Nykon Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  } else {  	exifDirectory.HasError = true;  	Trace.TraceError ("Unsupported makernote for Nikon data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.NikonType2Directory")' processedDirectoryOffsets' subdirOffset + 18' subdirOffset + 10);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("SONY CAM".Equals (firstEightChars) || "SONY DSC".Equals (firstEightChars)) {  	Trace.TraceInformation ("Found a Sony directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.SonyDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KDK".Equals (firstThreeChars)) {  	Trace.TraceInformation ("Found a Kodak directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  } else if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KodakDirectory")' processedDirectoryOffsets' subdirOffset + 20' tiffHeaderOffset);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Canon".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Canon directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CanonDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("CASIO")) {  	if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  		Trace.TraceInformation ("Found a Casion Type 2 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  	} else {  		Trace.TraceInformation ("Found a Casion Type 1 directory.");  		ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  	}  } else if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("QVC\u0000\u0000\u0000".Equals (firstSixChars)) {  	Trace.TraceInformation ("Found a Casion Type 2 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  } else {  	Trace.TraceInformation ("Found a Casion Type 1 directory.");  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType1Directory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' tiffHeaderOffset);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("FUJIFILM".Equals (firstEightChars) || "Fujifilm".ToUpper ().Equals (cameraModel.ToUpper ())) {  	Trace.TraceInformation ("Found a Fujifilm directory.");  	// TODO make this field a passed parameter' to avoid threading issues  	bool byteOrderBefore = this.isMotorollaByteOrder;  	// bug in fujifilm makernote ifd means we temporarily use Intel byte ordering  	this.isMotorollaByteOrder = false;  	// the 4 bytes after "FUJIFILM" in the makernote point to the start of the makernote  	// IFD' though the lcOffset is relative to the start of the makernote' not the TIFF  	// lcHeader (like everywhere else)  	int ifdStart = subdirOffset + Get32Bits (subdirOffset + 8);  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.FujifilmDirectory")' processedDirectoryOffsets' ifdStart' tiffHeaderOffset);  	this.isMotorollaByteOrder = byteOrderBefore;  } else if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if (cameraModel != null && cameraModel.ToUpper ().StartsWith ("MINOLTA")) {  	Trace.TraceInformation ("Found a Minolta directory' will use Olympus directory.");  	// Cases seen with the model starting with MINOLTA in capitals seem to have a valid Olympus makernote  	// area that commences immediately.  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.OlympusDirectory")' processedDirectoryOffsets' subdirOffset' tiffHeaderOffset);  } else if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KC".Equals (firstTwoChars) || "MINOL".Equals (firstFiveChars) || "MLY".Equals (firstThreeChars) || "+M+M+M+M".Equals (firstEightChars)) {  	// This Konica data is not understood.  Header identified in accordance with information at this site:  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/minolta_mn.html  	// TODO determine how to process the information described at the above website  	Trace.TraceError ("Unsupported Konica/Minolta data ignored.");  } else if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("KYOCERA".Equals (firstSevenChars)) {  	Trace.TraceInformation ("Found a Kyocera directory");  	// http://www.ozhiker.com/electronics/pjmt/jpeg_info/kyocera_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  } else if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.KyoceraDirectory")' processedDirectoryOffsets' subdirOffset + 22' tiffHeaderOffset);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("Panasonic\u0000\u0000\u0000".Equals (Utils.Decode (base.data' subdirOffset' 12' false))) {  	Trace.TraceInformation ("Found a panasonic directory");  	// NON-Standard TIFF IFD Data using Panasonic Tags. There is no Next-IFD pointer after the IFD  	// Offsets are relative to the start of the TIFF lcHeader at the beginning of the EXIF segment  	// more information here: http://www.ozhiker.com/electronics/pjmt/jpeg_info/panasonic_mn.html  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  } else if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PanasonicDirectory")' processedDirectoryOffsets' subdirOffset + 12' tiffHeaderOffset);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: if ("AOC\u0000".Equals (firstFourChars)) {  	Trace.TraceInformation ("Found a Casio type 2 directory");  	// NON-Standard TIFF IFD Data using Casio Type 2 Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - Pentax ist D  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  } else if (cameraModel != null && (cameraModel.ToUpper ().StartsWith ("PENTAX") || cameraModel.ToUpper ().StartsWith ("ASAHI"))) {  	Trace.TraceInformation ("Found a Pentax directory");  	// NON-Standard TIFF IFD Data using Pentax Tags  	// IFD has no Next-IFD pointer at end of IFD' and  	// Offsets are relative to the start of the current IFD tag' not the TIFF lcHeader  	// Observed for:  	// - PENTAX Optio 330  	// - PENTAX Optio 430  	ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.PentaxDirectory")' processedDirectoryOffsets' subdirOffset' subdirOffset);  } else {  	// TODO how to store makernote data when it'str not from a supported camera model?  	Trace.TraceError ("Unsupported directory data ignored.");  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessMakerNote,The following statement contains a magic number: ProcessDirectory (this.metadata.GetDirectory ("com.drew.metadata.exif.CasioType2Directory")' processedDirectoryOffsets' subdirOffset + 6' subdirOffset);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode) {  case FMT_UNDEFINED:  	Debug.Write ("Found a tag made of bytes");  	// this includes exif user comments  	byte[] tagBytes = new byte[componentCount];  	int byteCount = componentCount * BYTES_PER_FORMAT [formatCode];  	for (int i = 0; i < byteCount; i++) {  		tagBytes [i] = base.data [tagValueOffset + i];  	}  	directory.SetObject (tagType' tagBytes);  	break;  case FMT_STRING:  	Debug.Write ("Found a tag made of string");  	string lcStr = null;  	if (tagType == ExifDirectory.TAG_USER_COMMENT) {  		lcStr = ReadCommentString (tagValueOffset' componentCount' formatCode);  	} else {  		lcStr = ReadString (tagValueOffset' componentCount);  	}  	directory.SetObject (tagType' lcStr);  	break;  case FMT_SRATIONAL:  //goto case FMT_URATIONAL;  case FMT_URATIONAL:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of rational");  		Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  		directory.SetObject (tagType' rational);  	} else {  		Debug.Write ("Found a tag made of rationals");  		Rational[] rationals = new Rational[componentCount];  		for (int i = 0; i < componentCount; i++) {  			rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  		}  		directory.SetObject (tagType' rationals);  	}  	break;  case FMT_SBYTE:  //goto case FMT_BYTE;  case FMT_BYTE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of byte");  		// this may need to be a byte' but I think casting to int is fine  		int b = base.data [tagValueOffset];  		directory.SetObject (tagType' b);  	} else {  		Debug.Write ("Found a tag made of bytes but will use ints");  		int[] bytes = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			bytes [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' bytes);  	}  	break;  case FMT_SINGLE:  //goto case FMT_DOUBLE;  case FMT_DOUBLE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of double but will use int");  		int i = base.data [tagValueOffset];  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of doubles but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_USHORT:  //goto case FMT_SSHORT;  case FMT_SSHORT:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of short but will use int");  		int i = Get16Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of shorts but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get16Bits (tagValueOffset + (i * 2));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_SLONG:  //goto case FMT_ULONG;  case FMT_ULONG:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of long but will use int");  		int i = Get32Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of longs but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get32Bits (tagValueOffset + (i * 4));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  default:  	Trace.TraceWarning ("Unknown format code " + formatCode + " for tag " + tagType);  	break;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode) {  case FMT_UNDEFINED:  	Debug.Write ("Found a tag made of bytes");  	// this includes exif user comments  	byte[] tagBytes = new byte[componentCount];  	int byteCount = componentCount * BYTES_PER_FORMAT [formatCode];  	for (int i = 0; i < byteCount; i++) {  		tagBytes [i] = base.data [tagValueOffset + i];  	}  	directory.SetObject (tagType' tagBytes);  	break;  case FMT_STRING:  	Debug.Write ("Found a tag made of string");  	string lcStr = null;  	if (tagType == ExifDirectory.TAG_USER_COMMENT) {  		lcStr = ReadCommentString (tagValueOffset' componentCount' formatCode);  	} else {  		lcStr = ReadString (tagValueOffset' componentCount);  	}  	directory.SetObject (tagType' lcStr);  	break;  case FMT_SRATIONAL:  //goto case FMT_URATIONAL;  case FMT_URATIONAL:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of rational");  		Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  		directory.SetObject (tagType' rational);  	} else {  		Debug.Write ("Found a tag made of rationals");  		Rational[] rationals = new Rational[componentCount];  		for (int i = 0; i < componentCount; i++) {  			rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  		}  		directory.SetObject (tagType' rationals);  	}  	break;  case FMT_SBYTE:  //goto case FMT_BYTE;  case FMT_BYTE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of byte");  		// this may need to be a byte' but I think casting to int is fine  		int b = base.data [tagValueOffset];  		directory.SetObject (tagType' b);  	} else {  		Debug.Write ("Found a tag made of bytes but will use ints");  		int[] bytes = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			bytes [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' bytes);  	}  	break;  case FMT_SINGLE:  //goto case FMT_DOUBLE;  case FMT_DOUBLE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of double but will use int");  		int i = base.data [tagValueOffset];  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of doubles but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_USHORT:  //goto case FMT_SSHORT;  case FMT_SSHORT:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of short but will use int");  		int i = Get16Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of shorts but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get16Bits (tagValueOffset + (i * 2));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_SLONG:  //goto case FMT_ULONG;  case FMT_ULONG:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of long but will use int");  		int i = Get32Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of longs but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get32Bits (tagValueOffset + (i * 4));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  default:  	Trace.TraceWarning ("Unknown format code " + formatCode + " for tag " + tagType);  	break;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode) {  case FMT_UNDEFINED:  	Debug.Write ("Found a tag made of bytes");  	// this includes exif user comments  	byte[] tagBytes = new byte[componentCount];  	int byteCount = componentCount * BYTES_PER_FORMAT [formatCode];  	for (int i = 0; i < byteCount; i++) {  		tagBytes [i] = base.data [tagValueOffset + i];  	}  	directory.SetObject (tagType' tagBytes);  	break;  case FMT_STRING:  	Debug.Write ("Found a tag made of string");  	string lcStr = null;  	if (tagType == ExifDirectory.TAG_USER_COMMENT) {  		lcStr = ReadCommentString (tagValueOffset' componentCount' formatCode);  	} else {  		lcStr = ReadString (tagValueOffset' componentCount);  	}  	directory.SetObject (tagType' lcStr);  	break;  case FMT_SRATIONAL:  //goto case FMT_URATIONAL;  case FMT_URATIONAL:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of rational");  		Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  		directory.SetObject (tagType' rational);  	} else {  		Debug.Write ("Found a tag made of rationals");  		Rational[] rationals = new Rational[componentCount];  		for (int i = 0; i < componentCount; i++) {  			rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  		}  		directory.SetObject (tagType' rationals);  	}  	break;  case FMT_SBYTE:  //goto case FMT_BYTE;  case FMT_BYTE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of byte");  		// this may need to be a byte' but I think casting to int is fine  		int b = base.data [tagValueOffset];  		directory.SetObject (tagType' b);  	} else {  		Debug.Write ("Found a tag made of bytes but will use ints");  		int[] bytes = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			bytes [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' bytes);  	}  	break;  case FMT_SINGLE:  //goto case FMT_DOUBLE;  case FMT_DOUBLE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of double but will use int");  		int i = base.data [tagValueOffset];  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of doubles but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_USHORT:  //goto case FMT_SSHORT;  case FMT_SSHORT:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of short but will use int");  		int i = Get16Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of shorts but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get16Bits (tagValueOffset + (i * 2));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_SLONG:  //goto case FMT_ULONG;  case FMT_ULONG:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of long but will use int");  		int i = Get32Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of longs but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get32Bits (tagValueOffset + (i * 4));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  default:  	Trace.TraceWarning ("Unknown format code " + formatCode + " for tag " + tagType);  	break;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode) {  case FMT_UNDEFINED:  	Debug.Write ("Found a tag made of bytes");  	// this includes exif user comments  	byte[] tagBytes = new byte[componentCount];  	int byteCount = componentCount * BYTES_PER_FORMAT [formatCode];  	for (int i = 0; i < byteCount; i++) {  		tagBytes [i] = base.data [tagValueOffset + i];  	}  	directory.SetObject (tagType' tagBytes);  	break;  case FMT_STRING:  	Debug.Write ("Found a tag made of string");  	string lcStr = null;  	if (tagType == ExifDirectory.TAG_USER_COMMENT) {  		lcStr = ReadCommentString (tagValueOffset' componentCount' formatCode);  	} else {  		lcStr = ReadString (tagValueOffset' componentCount);  	}  	directory.SetObject (tagType' lcStr);  	break;  case FMT_SRATIONAL:  //goto case FMT_URATIONAL;  case FMT_URATIONAL:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of rational");  		Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  		directory.SetObject (tagType' rational);  	} else {  		Debug.Write ("Found a tag made of rationals");  		Rational[] rationals = new Rational[componentCount];  		for (int i = 0; i < componentCount; i++) {  			rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  		}  		directory.SetObject (tagType' rationals);  	}  	break;  case FMT_SBYTE:  //goto case FMT_BYTE;  case FMT_BYTE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of byte");  		// this may need to be a byte' but I think casting to int is fine  		int b = base.data [tagValueOffset];  		directory.SetObject (tagType' b);  	} else {  		Debug.Write ("Found a tag made of bytes but will use ints");  		int[] bytes = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			bytes [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' bytes);  	}  	break;  case FMT_SINGLE:  //goto case FMT_DOUBLE;  case FMT_DOUBLE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of double but will use int");  		int i = base.data [tagValueOffset];  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of doubles but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_USHORT:  //goto case FMT_SSHORT;  case FMT_SSHORT:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of short but will use int");  		int i = Get16Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of shorts but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get16Bits (tagValueOffset + (i * 2));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_SLONG:  //goto case FMT_ULONG;  case FMT_ULONG:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of long but will use int");  		int i = Get32Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of longs but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get32Bits (tagValueOffset + (i * 4));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  default:  	Trace.TraceWarning ("Unknown format code " + formatCode + " for tag " + tagType);  	break;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode) {  case FMT_UNDEFINED:  	Debug.Write ("Found a tag made of bytes");  	// this includes exif user comments  	byte[] tagBytes = new byte[componentCount];  	int byteCount = componentCount * BYTES_PER_FORMAT [formatCode];  	for (int i = 0; i < byteCount; i++) {  		tagBytes [i] = base.data [tagValueOffset + i];  	}  	directory.SetObject (tagType' tagBytes);  	break;  case FMT_STRING:  	Debug.Write ("Found a tag made of string");  	string lcStr = null;  	if (tagType == ExifDirectory.TAG_USER_COMMENT) {  		lcStr = ReadCommentString (tagValueOffset' componentCount' formatCode);  	} else {  		lcStr = ReadString (tagValueOffset' componentCount);  	}  	directory.SetObject (tagType' lcStr);  	break;  case FMT_SRATIONAL:  //goto case FMT_URATIONAL;  case FMT_URATIONAL:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of rational");  		Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  		directory.SetObject (tagType' rational);  	} else {  		Debug.Write ("Found a tag made of rationals");  		Rational[] rationals = new Rational[componentCount];  		for (int i = 0; i < componentCount; i++) {  			rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  		}  		directory.SetObject (tagType' rationals);  	}  	break;  case FMT_SBYTE:  //goto case FMT_BYTE;  case FMT_BYTE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of byte");  		// this may need to be a byte' but I think casting to int is fine  		int b = base.data [tagValueOffset];  		directory.SetObject (tagType' b);  	} else {  		Debug.Write ("Found a tag made of bytes but will use ints");  		int[] bytes = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			bytes [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' bytes);  	}  	break;  case FMT_SINGLE:  //goto case FMT_DOUBLE;  case FMT_DOUBLE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of double but will use int");  		int i = base.data [tagValueOffset];  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of doubles but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_USHORT:  //goto case FMT_SSHORT;  case FMT_SSHORT:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of short but will use int");  		int i = Get16Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of shorts but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get16Bits (tagValueOffset + (i * 2));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_SLONG:  //goto case FMT_ULONG;  case FMT_ULONG:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of long but will use int");  		int i = Get32Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of longs but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get32Bits (tagValueOffset + (i * 4));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  default:  	Trace.TraceWarning ("Unknown format code " + formatCode + " for tag " + tagType);  	break;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode) {  case FMT_UNDEFINED:  	Debug.Write ("Found a tag made of bytes");  	// this includes exif user comments  	byte[] tagBytes = new byte[componentCount];  	int byteCount = componentCount * BYTES_PER_FORMAT [formatCode];  	for (int i = 0; i < byteCount; i++) {  		tagBytes [i] = base.data [tagValueOffset + i];  	}  	directory.SetObject (tagType' tagBytes);  	break;  case FMT_STRING:  	Debug.Write ("Found a tag made of string");  	string lcStr = null;  	if (tagType == ExifDirectory.TAG_USER_COMMENT) {  		lcStr = ReadCommentString (tagValueOffset' componentCount' formatCode);  	} else {  		lcStr = ReadString (tagValueOffset' componentCount);  	}  	directory.SetObject (tagType' lcStr);  	break;  case FMT_SRATIONAL:  //goto case FMT_URATIONAL;  case FMT_URATIONAL:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of rational");  		Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  		directory.SetObject (tagType' rational);  	} else {  		Debug.Write ("Found a tag made of rationals");  		Rational[] rationals = new Rational[componentCount];  		for (int i = 0; i < componentCount; i++) {  			rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  		}  		directory.SetObject (tagType' rationals);  	}  	break;  case FMT_SBYTE:  //goto case FMT_BYTE;  case FMT_BYTE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of byte");  		// this may need to be a byte' but I think casting to int is fine  		int b = base.data [tagValueOffset];  		directory.SetObject (tagType' b);  	} else {  		Debug.Write ("Found a tag made of bytes but will use ints");  		int[] bytes = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			bytes [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' bytes);  	}  	break;  case FMT_SINGLE:  //goto case FMT_DOUBLE;  case FMT_DOUBLE:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of double but will use int");  		int i = base.data [tagValueOffset];  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of doubles but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = base.data [tagValueOffset + i];  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_USHORT:  //goto case FMT_SSHORT;  case FMT_SSHORT:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of short but will use int");  		int i = Get16Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of shorts but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get16Bits (tagValueOffset + (i * 2));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  case FMT_SLONG:  //goto case FMT_ULONG;  case FMT_ULONG:  	if (componentCount == 1) {  		Debug.Write ("Found a tag made of long but will use int");  		int i = Get32Bits (tagValueOffset);  		directory.SetObject (tagType' i);  	} else {  		Debug.Write ("Found a tag made of longs but will use ints");  		int[] ints = new int[componentCount];  		for (int i = 0; i < componentCount; i++) {  			ints [i] = Get32Bits (tagValueOffset + (i * 4));  		}  		directory.SetIntArray (tagType' ints);  	}  	break;  default:  	Trace.TraceWarning ("Unknown format code " + formatCode + " for tag " + tagType);  	break;  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: if (componentCount == 1) {  	Debug.Write ("Found a tag made of rational");  	Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  	directory.SetObject (tagType' rational);  } else {  	Debug.Write ("Found a tag made of rationals");  	Rational[] rationals = new Rational[componentCount];  	for (int i = 0; i < componentCount; i++) {  		rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  	}  	directory.SetObject (tagType' rationals);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: if (componentCount == 1) {  	Debug.Write ("Found a tag made of rational");  	Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  	directory.SetObject (tagType' rational);  } else {  	Debug.Write ("Found a tag made of rationals");  	Rational[] rationals = new Rational[componentCount];  	for (int i = 0; i < componentCount; i++) {  		rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  	}  	directory.SetObject (tagType' rationals);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: if (componentCount == 1) {  	Debug.Write ("Found a tag made of rational");  	Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  	directory.SetObject (tagType' rational);  } else {  	Debug.Write ("Found a tag made of rationals");  	Rational[] rationals = new Rational[componentCount];  	for (int i = 0; i < componentCount; i++) {  		rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  	}  	directory.SetObject (tagType' rationals);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: if (componentCount == 1) {  	Debug.Write ("Found a tag made of rational");  	Rational rational = new Rational (Get32Bits (tagValueOffset)' Get32Bits (tagValueOffset + 4));  	directory.SetObject (tagType' rational);  } else {  	Debug.Write ("Found a tag made of rationals");  	Rational[] rationals = new Rational[componentCount];  	for (int i = 0; i < componentCount; i++) {  		rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  	}  	directory.SetObject (tagType' rationals);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: for (int i = 0; i < componentCount; i++) {  	rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: for (int i = 0; i < componentCount; i++) {  	rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: for (int i = 0; i < componentCount; i++) {  	rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: rationals [i] = new Rational (Get32Bits (tagValueOffset + (8 * i))' Get32Bits (tagValueOffset + 4 + (8 * i)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: if (componentCount == 1) {  	Debug.Write ("Found a tag made of short but will use int");  	int i = Get16Bits (tagValueOffset);  	directory.SetObject (tagType' i);  } else {  	Debug.Write ("Found a tag made of shorts but will use ints");  	int[] ints = new int[componentCount];  	for (int i = 0; i < componentCount; i++) {  		ints [i] = Get16Bits (tagValueOffset + (i * 2));  	}  	directory.SetIntArray (tagType' ints);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: for (int i = 0; i < componentCount; i++) {  	ints [i] = Get16Bits (tagValueOffset + (i * 2));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: ints [i] = Get16Bits (tagValueOffset + (i * 2));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: if (componentCount == 1) {  	Debug.Write ("Found a tag made of long but will use int");  	int i = Get32Bits (tagValueOffset);  	directory.SetObject (tagType' i);  } else {  	Debug.Write ("Found a tag made of longs but will use ints");  	int[] ints = new int[componentCount];  	for (int i = 0; i < componentCount; i++) {  		ints [i] = Get32Bits (tagValueOffset + (i * 4));  	}  	directory.SetIntArray (tagType' ints);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: for (int i = 0; i < componentCount; i++) {  	ints [i] = Get32Bits (tagValueOffset + (i * 4));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ProcessTag,The following statement contains a magic number: ints [i] = Get32Bits (tagValueOffset + (i * 4));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("ASCII".Equals (Utils.Decode (base.data' tagValueOffSet' 5' false))) {  	for (int i = 5; i < 10; i++) {  		byte b = base.data [tagValueOffSet + i];  		if (b != '\0' && b != ' ') {  			return ReadString (tagValueOffSet + i' 1999);  		}  	}  } else if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("ASCII".Equals (Utils.Decode (base.data' tagValueOffSet' 5' false))) {  	for (int i = 5; i < 10; i++) {  		byte b = base.data [tagValueOffSet + i];  		if (b != '\0' && b != ' ') {  			return ReadString (tagValueOffSet + i' 1999);  		}  	}  } else if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("ASCII".Equals (Utils.Decode (base.data' tagValueOffSet' 5' false))) {  	for (int i = 5; i < 10; i++) {  		byte b = base.data [tagValueOffSet + i];  		if (b != '\0' && b != ' ') {  			return ReadString (tagValueOffSet + i' 1999);  		}  	}  } else if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("ASCII".Equals (Utils.Decode (base.data' tagValueOffSet' 5' false))) {  	for (int i = 5; i < 10; i++) {  		byte b = base.data [tagValueOffSet + i];  		if (b != '\0' && b != ' ') {  			return ReadString (tagValueOffSet + i' 1999);  		}  	}  } else if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("ASCII".Equals (Utils.Decode (base.data' tagValueOffSet' 5' false))) {  	for (int i = 5; i < 10; i++) {  		byte b = base.data [tagValueOffSet + i];  		if (b != '\0' && b != ' ') {  			return ReadString (tagValueOffSet + i' 1999);  		}  	}  } else if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("ASCII".Equals (Utils.Decode (base.data' tagValueOffSet' 5' false))) {  	for (int i = 5; i < 10; i++) {  		byte b = base.data [tagValueOffSet + i];  		if (b != '\0' && b != ' ') {  			return ReadString (tagValueOffSet + i' 1999);  		}  	}  } else if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("ASCII".Equals (Utils.Decode (base.data' tagValueOffSet' 5' false))) {  	for (int i = 5; i < 10; i++) {  		byte b = base.data [tagValueOffSet + i];  		if (b != '\0' && b != ' ') {  			return ReadString (tagValueOffSet + i' 1999);  		}  	}  } else if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: for (int i = 5; i < 10; i++) {  	byte b = base.data [tagValueOffSet + i];  	if (b != '\0' && b != ' ') {  		return ReadString (tagValueOffSet + i' 1999);  	}  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: for (int i = 5; i < 10; i++) {  	byte b = base.data [tagValueOffSet + i];  	if (b != '\0' && b != ' ') {  		return ReadString (tagValueOffSet + i' 1999);  	}  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: for (int i = 5; i < 10; i++) {  	byte b = base.data [tagValueOffSet + i];  	if (b != '\0' && b != ' ') {  		return ReadString (tagValueOffSet + i' 1999);  	}  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if (b != '\0' && b != ' ') {  	return ReadString (tagValueOffSet + i' 1999);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: return ReadString (tagValueOffSet + i' 1999);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: if ("UNICODE".Equals (Utils.Decode (base.data' tagValueOffSet' 7' false))) {  	int start = tagValueOffSet + 7;  	for (int i = start; i < 10 + start; i++) {  		byte b = base.data [i];  		if (b == 0 || (char)b == ' ') {  			continue;  		} else {  			start = i;  			break;  		}  	}  	int end = base.data.Length;  	// TODO find a way to cut the string properly				  	return Utils.Decode (base.data' start' end - start' true);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: for (int i = start; i < 10 + start; i++) {  	byte b = base.data [i];  	if (b == 0 || (char)b == ' ') {  		continue;  	} else {  		start = i;  		break;  	}  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,ReadCommentString,The following statement contains a magic number: return ReadString (tagValueOffSet' 1999);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,CalculateDirectoryEntryOffSet,The following statement contains a magic number: return (ifdStartOffSet + 2 + (12 * entryNumber));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,CalculateDirectoryEntryOffSet,The following statement contains a magic number: return (ifdStartOffSet + 2 + (12 * entryNumber));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get16Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (base.data [offSet] << 8 & 0xFF00) | (base.data [offSet + 1] & 0xFF);  } else {  	// Intel ordering  	return (base.data [offSet + 1] << 8 & 0xFF00) | (base.data [offSet] & 0xFF);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get16Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (base.data [offSet] << 8 & 0xFF00) | (base.data [offSet + 1] & 0xFF);  } else {  	// Intel ordering  	return (base.data [offSet + 1] << 8 & 0xFF00) | (base.data [offSet] & 0xFF);  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get16Bits,The following statement contains a magic number: return (base.data [offSet] << 8 & 0xFF00) | (base.data [offSet + 1] & 0xFF);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get16Bits,The following statement contains a magic number: return (base.data [offSet + 1] << 8 & 0xFF00) | (base.data [offSet] & 0xFF);  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: if (this.isMotorollaByteOrder) {  	// Motorola big first  	return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  } else {  	// Intel ordering  	return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  }  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 1] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 2] << 8 & 0xFF00)) | ((uint)(base.data [offSet + 3] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  
Magic Number,com.drew.metadata.exif,ExifReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\ExifReader.cs,Get32Bits,The following statement contains a magic number: return (int)(((uint)(base.data [offSet + 3] << 24 & 0xFF000000)) | ((uint)(base.data [offSet + 2] << 16 & 0xFF0000)) | ((uint)(base.data [offSet + 1] << 8 & 0xFF00)) | ((uint)(base.data [offSet] & 0xFF)));  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetPictureModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PORTRAIT_SCENE"];  case 2:  	return BUNDLE ["LANDSCAPE_SCENE"];  case 4:  	return BUNDLE ["SPORTS_SCENE"];  case 5:  	return BUNDLE ["NIGHT_SCENE"];  case 6:  	return BUNDLE ["PROGRAM_AE"];  case 256:  	return BUNDLE ["APERTURE_PRIORITY_AE"];  case 512:  	return BUNDLE ["SHUTTER_PRIORITY_AE"];  case 768:  	return BUNDLE ["MANUAL_EXPOSURE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetPictureModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PORTRAIT_SCENE"];  case 2:  	return BUNDLE ["LANDSCAPE_SCENE"];  case 4:  	return BUNDLE ["SPORTS_SCENE"];  case 5:  	return BUNDLE ["NIGHT_SCENE"];  case 6:  	return BUNDLE ["PROGRAM_AE"];  case 256:  	return BUNDLE ["APERTURE_PRIORITY_AE"];  case 512:  	return BUNDLE ["SHUTTER_PRIORITY_AE"];  case 768:  	return BUNDLE ["MANUAL_EXPOSURE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetPictureModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PORTRAIT_SCENE"];  case 2:  	return BUNDLE ["LANDSCAPE_SCENE"];  case 4:  	return BUNDLE ["SPORTS_SCENE"];  case 5:  	return BUNDLE ["NIGHT_SCENE"];  case 6:  	return BUNDLE ["PROGRAM_AE"];  case 256:  	return BUNDLE ["APERTURE_PRIORITY_AE"];  case 512:  	return BUNDLE ["SHUTTER_PRIORITY_AE"];  case 768:  	return BUNDLE ["MANUAL_EXPOSURE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetPictureModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PORTRAIT_SCENE"];  case 2:  	return BUNDLE ["LANDSCAPE_SCENE"];  case 4:  	return BUNDLE ["SPORTS_SCENE"];  case 5:  	return BUNDLE ["NIGHT_SCENE"];  case 6:  	return BUNDLE ["PROGRAM_AE"];  case 256:  	return BUNDLE ["APERTURE_PRIORITY_AE"];  case 512:  	return BUNDLE ["SHUTTER_PRIORITY_AE"];  case 768:  	return BUNDLE ["MANUAL_EXPOSURE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetPictureModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PORTRAIT_SCENE"];  case 2:  	return BUNDLE ["LANDSCAPE_SCENE"];  case 4:  	return BUNDLE ["SPORTS_SCENE"];  case 5:  	return BUNDLE ["NIGHT_SCENE"];  case 6:  	return BUNDLE ["PROGRAM_AE"];  case 256:  	return BUNDLE ["APERTURE_PRIORITY_AE"];  case 512:  	return BUNDLE ["SHUTTER_PRIORITY_AE"];  case 768:  	return BUNDLE ["MANUAL_EXPOSURE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetPictureModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PORTRAIT_SCENE"];  case 2:  	return BUNDLE ["LANDSCAPE_SCENE"];  case 4:  	return BUNDLE ["SPORTS_SCENE"];  case 5:  	return BUNDLE ["NIGHT_SCENE"];  case 6:  	return BUNDLE ["PROGRAM_AE"];  case 256:  	return BUNDLE ["APERTURE_PRIORITY_AE"];  case 512:  	return BUNDLE ["SHUTTER_PRIORITY_AE"];  case 768:  	return BUNDLE ["MANUAL_EXPOSURE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetPictureModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PORTRAIT_SCENE"];  case 2:  	return BUNDLE ["LANDSCAPE_SCENE"];  case 4:  	return BUNDLE ["SPORTS_SCENE"];  case 5:  	return BUNDLE ["NIGHT_SCENE"];  case 6:  	return BUNDLE ["PROGRAM_AE"];  case 256:  	return BUNDLE ["APERTURE_PRIORITY_AE"];  case 512:  	return BUNDLE ["SHUTTER_PRIORITY_AE"];  case 768:  	return BUNDLE ["MANUAL_EXPOSURE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["ON"];  case 2:  	return BUNDLE ["OFF"];  case 3:  	return BUNDLE ["RED_EYE_REDUCTION"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetFlashModeDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["ON"];  case 2:  	return BUNDLE ["OFF"];  case 3:  	return BUNDLE ["RED_EYE_REDUCTION"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetToneDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL_STD"];  case 256:  	return BUNDLE ["HIGH_HARD"];  case 512:  	return BUNDLE ["LOW_ORG"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetToneDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL_STD"];  case 256:  	return BUNDLE ["HIGH_HARD"];  case 512:  	return BUNDLE ["LOW_ORG"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetColorDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL_STD"];  case 256:  	return BUNDLE ["HIGH"];  case 512:  	return BUNDLE ["LOW_ORG"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetColorDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL_STD"];  case 256:  	return BUNDLE ["HIGH"];  case 512:  	return BUNDLE ["LOW_ORG"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 256:  	return BUNDLE ["DAYLIGHT"];  case 512:  	return BUNDLE ["CLOUDY"];  case 768:  	return BUNDLE ["DAYLIGHTCOLOR_FLUORESCENCE"];  case 769:  	return BUNDLE ["DAYWHITECOLOR_FLUORESCENCE"];  case 770:  	return BUNDLE ["WHITE_FLUORESCENCE"];  case 1024:  	return BUNDLE ["INCANDENSCENSE"];  case 3840:  	return BUNDLE ["CUSTOM_WHITE_BALANCE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 256:  	return BUNDLE ["DAYLIGHT"];  case 512:  	return BUNDLE ["CLOUDY"];  case 768:  	return BUNDLE ["DAYLIGHTCOLOR_FLUORESCENCE"];  case 769:  	return BUNDLE ["DAYWHITECOLOR_FLUORESCENCE"];  case 770:  	return BUNDLE ["WHITE_FLUORESCENCE"];  case 1024:  	return BUNDLE ["INCANDENSCENSE"];  case 3840:  	return BUNDLE ["CUSTOM_WHITE_BALANCE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 256:  	return BUNDLE ["DAYLIGHT"];  case 512:  	return BUNDLE ["CLOUDY"];  case 768:  	return BUNDLE ["DAYLIGHTCOLOR_FLUORESCENCE"];  case 769:  	return BUNDLE ["DAYWHITECOLOR_FLUORESCENCE"];  case 770:  	return BUNDLE ["WHITE_FLUORESCENCE"];  case 1024:  	return BUNDLE ["INCANDENSCENSE"];  case 3840:  	return BUNDLE ["CUSTOM_WHITE_BALANCE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 256:  	return BUNDLE ["DAYLIGHT"];  case 512:  	return BUNDLE ["CLOUDY"];  case 768:  	return BUNDLE ["DAYLIGHTCOLOR_FLUORESCENCE"];  case 769:  	return BUNDLE ["DAYWHITECOLOR_FLUORESCENCE"];  case 770:  	return BUNDLE ["WHITE_FLUORESCENCE"];  case 1024:  	return BUNDLE ["INCANDENSCENSE"];  case 3840:  	return BUNDLE ["CUSTOM_WHITE_BALANCE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 256:  	return BUNDLE ["DAYLIGHT"];  case 512:  	return BUNDLE ["CLOUDY"];  case 768:  	return BUNDLE ["DAYLIGHTCOLOR_FLUORESCENCE"];  case 769:  	return BUNDLE ["DAYWHITECOLOR_FLUORESCENCE"];  case 770:  	return BUNDLE ["WHITE_FLUORESCENCE"];  case 1024:  	return BUNDLE ["INCANDENSCENSE"];  case 3840:  	return BUNDLE ["CUSTOM_WHITE_BALANCE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 256:  	return BUNDLE ["DAYLIGHT"];  case 512:  	return BUNDLE ["CLOUDY"];  case 768:  	return BUNDLE ["DAYLIGHTCOLOR_FLUORESCENCE"];  case 769:  	return BUNDLE ["DAYWHITECOLOR_FLUORESCENCE"];  case 770:  	return BUNDLE ["WHITE_FLUORESCENCE"];  case 1024:  	return BUNDLE ["INCANDENSCENSE"];  case 3840:  	return BUNDLE ["CUSTOM_WHITE_BALANCE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 256:  	return BUNDLE ["DAYLIGHT"];  case 512:  	return BUNDLE ["CLOUDY"];  case 768:  	return BUNDLE ["DAYLIGHTCOLOR_FLUORESCENCE"];  case 769:  	return BUNDLE ["DAYWHITECOLOR_FLUORESCENCE"];  case 770:  	return BUNDLE ["WHITE_FLUORESCENCE"];  case 1024:  	return BUNDLE ["INCANDENSCENSE"];  case 3840:  	return BUNDLE ["CUSTOM_WHITE_BALANCE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetSharpnessDescription,The following statement contains a magic number: switch (aValue) {  case 1:  case 2:  	return BUNDLE ["SOFT"];  case 3:  	return BUNDLE ["NORMAL"];  case 4:  case 5:  	return BUNDLE ["HARD"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetSharpnessDescription,The following statement contains a magic number: switch (aValue) {  case 1:  case 2:  	return BUNDLE ["SOFT"];  case 3:  	return BUNDLE ["NORMAL"];  case 4:  case 5:  	return BUNDLE ["HARD"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetSharpnessDescription,The following statement contains a magic number: switch (aValue) {  case 1:  case 2:  	return BUNDLE ["SOFT"];  case 3:  	return BUNDLE ["NORMAL"];  case 4:  case 5:  	return BUNDLE ["HARD"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,FujifilmDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\FujifilmDescriptor.cs,GetSharpnessDescription,The following statement contains a magic number: switch (aValue) {  case 1:  case 2:  	return BUNDLE ["SOFT"];  case 3:  	return BUNDLE ["NORMAL"];  case 4:  case 5:  	return BUNDLE ["HARD"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,GpsDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\GpsDescriptor.cs,GetHoursMinutesSecondsDescription,The following statement contains a magic number: sec += (min % 1) * 60;  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PRESET"];  case 2:  	return BUNDLE ["DAYLIGHT"];  case 3:  	return BUNDLE ["INCANDESCENSE"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["CLOUDY"];  case 6:  	return BUNDLE ["SPEEDLIGHT"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PRESET"];  case 2:  	return BUNDLE ["DAYLIGHT"];  case 3:  	return BUNDLE ["INCANDESCENSE"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["CLOUDY"];  case 6:  	return BUNDLE ["SPEEDLIGHT"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PRESET"];  case 2:  	return BUNDLE ["DAYLIGHT"];  case 3:  	return BUNDLE ["INCANDESCENSE"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["CLOUDY"];  case 6:  	return BUNDLE ["SPEEDLIGHT"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PRESET"];  case 2:  	return BUNDLE ["DAYLIGHT"];  case 3:  	return BUNDLE ["INCANDESCENSE"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["CLOUDY"];  case 6:  	return BUNDLE ["SPEEDLIGHT"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetWhiteBalanceDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["AUTO"];  case 1:  	return BUNDLE ["PRESET"];  case 2:  	return BUNDLE ["DAYLIGHT"];  case 3:  	return BUNDLE ["INCANDESCENSE"];  case 4:  	return BUNDLE ["FLUORESCENT"];  case 5:  	return BUNDLE ["CLOUDY"];  case 6:  	return BUNDLE ["SPEEDLIGHT"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["ISO"' "80"];  case 2:  	return BUNDLE ["ISO"' "160"];  case 4:  	return BUNDLE ["ISO"' "320"];  case 5:  	return BUNDLE ["ISO"' "100"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["ISO"' "80"];  case 2:  	return BUNDLE ["ISO"' "160"];  case 4:  	return BUNDLE ["ISO"' "320"];  case 5:  	return BUNDLE ["ISO"' "100"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetCcdSensitivityDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["ISO"' "80"];  case 2:  	return BUNDLE ["ISO"' "160"];  case 4:  	return BUNDLE ["ISO"' "320"];  case 5:  	return BUNDLE ["ISO"' "100"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetImageAdjustmentDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["BRIGHT_P"];  case 2:  	return BUNDLE ["BRIGHT_M"];  case 3:  	return BUNDLE ["CONTRAST_P"];  case 4:  	return BUNDLE ["CONTRAST_M"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetImageAdjustmentDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["BRIGHT_P"];  case 2:  	return BUNDLE ["BRIGHT_M"];  case 3:  	return BUNDLE ["CONTRAST_P"];  case 4:  	return BUNDLE ["CONTRAST_M"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetImageAdjustmentDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["BRIGHT_P"];  case 2:  	return BUNDLE ["BRIGHT_M"];  case 3:  	return BUNDLE ["CONTRAST_P"];  case 4:  	return BUNDLE ["CONTRAST_M"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetColorModeDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["COLOR"];  case 2:  	return BUNDLE ["MONOCHROME"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["VGA_BASIC"];  case 2:  	return BUNDLE ["VGA_NORMAL"];  case 3:  	return BUNDLE ["VGA_FINE"];  case 4:  	return BUNDLE ["SXGA_BASIC"];  case 5:  	return BUNDLE ["SXGA_NORMAL"];  case 6:  	return BUNDLE ["SXGA_FINE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["VGA_BASIC"];  case 2:  	return BUNDLE ["VGA_NORMAL"];  case 3:  	return BUNDLE ["VGA_FINE"];  case 4:  	return BUNDLE ["SXGA_BASIC"];  case 5:  	return BUNDLE ["SXGA_NORMAL"];  case 6:  	return BUNDLE ["SXGA_FINE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["VGA_BASIC"];  case 2:  	return BUNDLE ["VGA_NORMAL"];  case 3:  	return BUNDLE ["VGA_FINE"];  case 4:  	return BUNDLE ["SXGA_BASIC"];  case 5:  	return BUNDLE ["SXGA_NORMAL"];  case 6:  	return BUNDLE ["SXGA_FINE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["VGA_BASIC"];  case 2:  	return BUNDLE ["VGA_NORMAL"];  case 3:  	return BUNDLE ["VGA_FINE"];  case 4:  	return BUNDLE ["SXGA_BASIC"];  case 5:  	return BUNDLE ["SXGA_NORMAL"];  case 6:  	return BUNDLE ["SXGA_FINE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType1Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType1Descriptor.cs,GetQualityDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["VGA_BASIC"];  case 2:  	return BUNDLE ["VGA_NORMAL"];  case 3:  	return BUNDLE ["VGA_FINE"];  case 4:  	return BUNDLE ["SXGA_BASIC"];  case 5:  	return BUNDLE ["SXGA_NORMAL"];  case 6:  	return BUNDLE ["SXGA_FINE"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFocusPositionDescription,The following statement contains a magic number: if (values.Length != 4 || values [0] != 0 || values [2] != 0 || values [3] != 0) {  	return BUNDLE ["UNKNOWN"' base.directory.GetString (NikonType2Directory.TAG_NIKON_TYPE2_AF_FOCUS_POSITION)];  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFocusPositionDescription,The following statement contains a magic number: if (values.Length != 4 || values [0] != 0 || values [2] != 0 || values [3] != 0) {  	return BUNDLE ["UNKNOWN"' base.directory.GetString (NikonType2Directory.TAG_NIKON_TYPE2_AF_FOCUS_POSITION)];  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFocusPositionDescription,The following statement contains a magic number: if (values.Length != 4 || values [0] != 0 || values [2] != 0 || values [3] != 0) {  	return BUNDLE ["UNKNOWN"' base.directory.GetString (NikonType2Directory.TAG_NIKON_TYPE2_AF_FOCUS_POSITION)];  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFocusPositionDescription,The following statement contains a magic number: switch (values [1]) {  case 0:  	return BUNDLE ["CENTER"];  case 1:  	return BUNDLE ["TOP"];  case 2:  	return BUNDLE ["BOTTOM"];  case 3:  	return BUNDLE ["LEFT"];  case 4:  	return BUNDLE ["RIGHT"];  default:  	return BUNDLE ["UNKNOWN"' values [1].ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFocusPositionDescription,The following statement contains a magic number: switch (values [1]) {  case 0:  	return BUNDLE ["CENTER"];  case 1:  	return BUNDLE ["TOP"];  case 2:  	return BUNDLE ["BOTTOM"];  case 3:  	return BUNDLE ["LEFT"];  case 4:  	return BUNDLE ["RIGHT"];  default:  	return BUNDLE ["UNKNOWN"' values [1].ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFocusPositionDescription,The following statement contains a magic number: switch (values [1]) {  case 0:  	return BUNDLE ["CENTER"];  case 1:  	return BUNDLE ["TOP"];  case 2:  	return BUNDLE ["BOTTOM"];  case 3:  	return BUNDLE ["LEFT"];  case 4:  	return BUNDLE ["RIGHT"];  default:  	return BUNDLE ["UNKNOWN"' values [1].ToString ()];  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFlashCompensation,The following statement contains a magic number: if (bytes.Length == 3) {  	byte denominator = bytes [2];  	int numerator = (int)bytes [0] * bytes [1];  	return new Rational (numerator' denominator);  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetAutoFlashCompensation,The following statement contains a magic number: if (bytes.Length == 3) {  	byte denominator = bytes [2];  	int numerator = (int)bytes [0] * bytes [1];  	return new Rational (numerator' denominator);  }  
Magic Number,com.drew.metadata.exif,NikonType2Descriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\NikonType2Descriptor.cs,GetLensDescription,The following statement contains a magic number: if (lensValues.Length != 4) {  	return base.directory.GetString (NikonType2Directory.TAG_NIKON_TYPE2_LENS);  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetDigiZoomRatioDescription,The following statement contains a magic number: switch (aValue) {  case 0:  	return BUNDLE ["NORMAL"];  case 1:  	return BUNDLE ["DIGITAL_ZOOM"' "1"];  case 2:  	return BUNDLE ["DIGITAL_ZOOM"' "2"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetJpegQualityDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["SQ"];  case 2:  	return BUNDLE ["HQ"];  case 3:  	return BUNDLE ["SHQ"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetJpegQualityDescription,The following statement contains a magic number: switch (aValue) {  case 1:  	return BUNDLE ["SQ"];  case 2:  	return BUNDLE ["HQ"];  case 3:  	return BUNDLE ["SHQ"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetSpecialModeDescription,The following statement contains a magic number: switch (values [0]) {  case 0:  	desc.Append (BUNDLE ["NORMAL_PICTURE_TAKING_MODE"]);  	break;  case 1:  	desc.Append (BUNDLE ["UNKNOWN_PICTURE_TAKING_MODE"]);  	break;  case 2:  	desc.Append (BUNDLE ["FAST_PICTURE_TAKING_MODE"]);  	break;  case 3:  	desc.Append (BUNDLE ["PANORAMA_PICTURE_TAKING_MODE"]);  	break;  default:  	desc.Append (BUNDLE ["UNKNOWN_PICTURE_TAKING_MODE"]);  	break;  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetSpecialModeDescription,The following statement contains a magic number: switch (values [0]) {  case 0:  	desc.Append (BUNDLE ["NORMAL_PICTURE_TAKING_MODE"]);  	break;  case 1:  	desc.Append (BUNDLE ["UNKNOWN_PICTURE_TAKING_MODE"]);  	break;  case 2:  	desc.Append (BUNDLE ["FAST_PICTURE_TAKING_MODE"]);  	break;  case 3:  	desc.Append (BUNDLE ["PANORAMA_PICTURE_TAKING_MODE"]);  	break;  default:  	desc.Append (BUNDLE ["UNKNOWN_PICTURE_TAKING_MODE"]);  	break;  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetSpecialModeDescription,The following statement contains a magic number: switch (values [2]) {  case 1:  	desc.Append (BUNDLE ["LEFT_TO_RIGHT_PAN_DIR"]);  	break;  case 2:  	desc.Append (BUNDLE ["RIGHT_TO_LEFT_PAN_DIR"]);  	break;  case 3:  	desc.Append (BUNDLE ["BOTTOM_TO_TOP_PAN_DIR"]);  	break;  case 4:  	desc.Append (BUNDLE ["TOP_TO_BOTTOM_PAN_DIR"]);  	break;  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetSpecialModeDescription,The following statement contains a magic number: switch (values [2]) {  case 1:  	desc.Append (BUNDLE ["LEFT_TO_RIGHT_PAN_DIR"]);  	break;  case 2:  	desc.Append (BUNDLE ["RIGHT_TO_LEFT_PAN_DIR"]);  	break;  case 3:  	desc.Append (BUNDLE ["BOTTOM_TO_TOP_PAN_DIR"]);  	break;  case 4:  	desc.Append (BUNDLE ["TOP_TO_BOTTOM_PAN_DIR"]);  	break;  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetSpecialModeDescription,The following statement contains a magic number: switch (values [2]) {  case 1:  	desc.Append (BUNDLE ["LEFT_TO_RIGHT_PAN_DIR"]);  	break;  case 2:  	desc.Append (BUNDLE ["RIGHT_TO_LEFT_PAN_DIR"]);  	break;  case 3:  	desc.Append (BUNDLE ["BOTTOM_TO_TOP_PAN_DIR"]);  	break;  case 4:  	desc.Append (BUNDLE ["TOP_TO_BOTTOM_PAN_DIR"]);  	break;  }  
Magic Number,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetSpecialModeDescription,The following statement contains a magic number: switch (values [2]) {  case 1:  	desc.Append (BUNDLE ["LEFT_TO_RIGHT_PAN_DIR"]);  	break;  case 2:  	desc.Append (BUNDLE ["RIGHT_TO_LEFT_PAN_DIR"]);  	break;  case 3:  	desc.Append (BUNDLE ["BOTTOM_TO_TOP_PAN_DIR"]);  	break;  case 4:  	desc.Append (BUNDLE ["TOP_TO_BOTTOM_PAN_DIR"]);  	break;  }  
Magic Number,com.drew.metadata.iptc,IptcDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcDescriptor.cs,GetUrgencyDescription,The following statement contains a magic number: switch (aValue) {  case 49:  	return BUNDLE ["HIGH"];  case 54:  	return BUNDLE ["NORMAL"];  case 56:  	return BUNDLE ["LOW"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.iptc,IptcDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcDescriptor.cs,GetUrgencyDescription,The following statement contains a magic number: switch (aValue) {  case 49:  	return BUNDLE ["HIGH"];  case 54:  	return BUNDLE ["NORMAL"];  case 56:  	return BUNDLE ["LOW"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.iptc,IptcDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcDescriptor.cs,GetUrgencyDescription,The following statement contains a magic number: switch (aValue) {  case 49:  	return BUNDLE ["HIGH"];  case 54:  	return BUNDLE ["NORMAL"];  case 56:  	return BUNDLE ["LOW"];  default:  	return BUNDLE ["UNKNOWN"' aValue.ToString ()];  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,Extract,The following statement contains a magic number: while (offset < base.data.Length) {  	// identifies start of a tag  	if (base.data [offset] != 0x1c) {  		break;  	}  	// we need at least five bytes left to read a tag  	if ((offset + 5) >= base.data.Length) {  		break;  	}  	offset++;  	int directoryType;  	int tagType;  	int tagByteCount;  	try {  		directoryType = base.data [offset++];  		tagType = base.data [offset++];  		tagByteCount = Get32Bits (offset);  	} catch (MetadataException e) {  		lcDirectory.HasError = true;  		Trace.TraceError ("Iptc data segment ended mid-way through tag descriptor (" + e.Message + ")");  		return aMetadata;  	}  	offset += 2;  	if ((offset + tagByteCount) > base.data.Length) {  		lcDirectory.HasError = true;  		Trace.TraceError ("Data for tag extends beyond end of IPTC segment");  		break;  	}  	ProcessTag (lcDirectory' directoryType' tagType' offset' tagByteCount);  	offset += tagByteCount;  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,Extract,The following statement contains a magic number: while (offset < base.data.Length) {  	// identifies start of a tag  	if (base.data [offset] != 0x1c) {  		break;  	}  	// we need at least five bytes left to read a tag  	if ((offset + 5) >= base.data.Length) {  		break;  	}  	offset++;  	int directoryType;  	int tagType;  	int tagByteCount;  	try {  		directoryType = base.data [offset++];  		tagType = base.data [offset++];  		tagByteCount = Get32Bits (offset);  	} catch (MetadataException e) {  		lcDirectory.HasError = true;  		Trace.TraceError ("Iptc data segment ended mid-way through tag descriptor (" + e.Message + ")");  		return aMetadata;  	}  	offset += 2;  	if ((offset + tagByteCount) > base.data.Length) {  		lcDirectory.HasError = true;  		Trace.TraceError ("Data for tag extends beyond end of IPTC segment");  		break;  	}  	ProcessTag (lcDirectory' directoryType' tagType' offset' tagByteCount);  	offset += tagByteCount;  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,Extract,The following statement contains a magic number: if ((offset + 5) >= base.data.Length) {  	break;  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,Extract,The following statement contains a magic number: offset += 2;  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: switch (tagIdentifier) {  case IptcDirectory.TAG_RECORD_VERSION:  	// short  	short shortValue = (short)((base.data [anOffset] << 8) | base.data [anOffset + 1]);  	aDirectory.SetObject (tagIdentifier' shortValue);  	return;  case IptcDirectory.TAG_URGENCY:  	// byte  	aDirectory.SetObject (tagIdentifier' base.data [anOffset]);  	return;  case IptcDirectory.TAG_RELEASE_DATE:  case IptcDirectory.TAG_DATE_CREATED:  	// Date object  	if (aTagByteCount >= 8) {  		string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  		try {  			int year = Convert.ToInt32 (dateStr.Substring (0' 4));  			int month = Convert.ToInt32 (dateStr.Substring (4' 2));  			//No -1 here;  			int day = Convert.ToInt32 (dateStr.Substring (6' 2));  			DateTime date = new DateTime (year' month' day);  			aDirectory.SetObject (tagIdentifier' date);  			return;  		} catch (Exception) {  			// fall through and we'll store whatever was there as a String  		}  	}  	break;  // Added for .Net compiler  //case IptcDirectory.TAG_RELEASE_TIME:  //case IptcDirectory.TAG_TIME_CREATED:   }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: switch (tagIdentifier) {  case IptcDirectory.TAG_RECORD_VERSION:  	// short  	short shortValue = (short)((base.data [anOffset] << 8) | base.data [anOffset + 1]);  	aDirectory.SetObject (tagIdentifier' shortValue);  	return;  case IptcDirectory.TAG_URGENCY:  	// byte  	aDirectory.SetObject (tagIdentifier' base.data [anOffset]);  	return;  case IptcDirectory.TAG_RELEASE_DATE:  case IptcDirectory.TAG_DATE_CREATED:  	// Date object  	if (aTagByteCount >= 8) {  		string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  		try {  			int year = Convert.ToInt32 (dateStr.Substring (0' 4));  			int month = Convert.ToInt32 (dateStr.Substring (4' 2));  			//No -1 here;  			int day = Convert.ToInt32 (dateStr.Substring (6' 2));  			DateTime date = new DateTime (year' month' day);  			aDirectory.SetObject (tagIdentifier' date);  			return;  		} catch (Exception) {  			// fall through and we'll store whatever was there as a String  		}  	}  	break;  // Added for .Net compiler  //case IptcDirectory.TAG_RELEASE_TIME:  //case IptcDirectory.TAG_TIME_CREATED:   }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: switch (tagIdentifier) {  case IptcDirectory.TAG_RECORD_VERSION:  	// short  	short shortValue = (short)((base.data [anOffset] << 8) | base.data [anOffset + 1]);  	aDirectory.SetObject (tagIdentifier' shortValue);  	return;  case IptcDirectory.TAG_URGENCY:  	// byte  	aDirectory.SetObject (tagIdentifier' base.data [anOffset]);  	return;  case IptcDirectory.TAG_RELEASE_DATE:  case IptcDirectory.TAG_DATE_CREATED:  	// Date object  	if (aTagByteCount >= 8) {  		string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  		try {  			int year = Convert.ToInt32 (dateStr.Substring (0' 4));  			int month = Convert.ToInt32 (dateStr.Substring (4' 2));  			//No -1 here;  			int day = Convert.ToInt32 (dateStr.Substring (6' 2));  			DateTime date = new DateTime (year' month' day);  			aDirectory.SetObject (tagIdentifier' date);  			return;  		} catch (Exception) {  			// fall through and we'll store whatever was there as a String  		}  	}  	break;  // Added for .Net compiler  //case IptcDirectory.TAG_RELEASE_TIME:  //case IptcDirectory.TAG_TIME_CREATED:   }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: switch (tagIdentifier) {  case IptcDirectory.TAG_RECORD_VERSION:  	// short  	short shortValue = (short)((base.data [anOffset] << 8) | base.data [anOffset + 1]);  	aDirectory.SetObject (tagIdentifier' shortValue);  	return;  case IptcDirectory.TAG_URGENCY:  	// byte  	aDirectory.SetObject (tagIdentifier' base.data [anOffset]);  	return;  case IptcDirectory.TAG_RELEASE_DATE:  case IptcDirectory.TAG_DATE_CREATED:  	// Date object  	if (aTagByteCount >= 8) {  		string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  		try {  			int year = Convert.ToInt32 (dateStr.Substring (0' 4));  			int month = Convert.ToInt32 (dateStr.Substring (4' 2));  			//No -1 here;  			int day = Convert.ToInt32 (dateStr.Substring (6' 2));  			DateTime date = new DateTime (year' month' day);  			aDirectory.SetObject (tagIdentifier' date);  			return;  		} catch (Exception) {  			// fall through and we'll store whatever was there as a String  		}  	}  	break;  // Added for .Net compiler  //case IptcDirectory.TAG_RELEASE_TIME:  //case IptcDirectory.TAG_TIME_CREATED:   }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: switch (tagIdentifier) {  case IptcDirectory.TAG_RECORD_VERSION:  	// short  	short shortValue = (short)((base.data [anOffset] << 8) | base.data [anOffset + 1]);  	aDirectory.SetObject (tagIdentifier' shortValue);  	return;  case IptcDirectory.TAG_URGENCY:  	// byte  	aDirectory.SetObject (tagIdentifier' base.data [anOffset]);  	return;  case IptcDirectory.TAG_RELEASE_DATE:  case IptcDirectory.TAG_DATE_CREATED:  	// Date object  	if (aTagByteCount >= 8) {  		string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  		try {  			int year = Convert.ToInt32 (dateStr.Substring (0' 4));  			int month = Convert.ToInt32 (dateStr.Substring (4' 2));  			//No -1 here;  			int day = Convert.ToInt32 (dateStr.Substring (6' 2));  			DateTime date = new DateTime (year' month' day);  			aDirectory.SetObject (tagIdentifier' date);  			return;  		} catch (Exception) {  			// fall through and we'll store whatever was there as a String  		}  	}  	break;  // Added for .Net compiler  //case IptcDirectory.TAG_RELEASE_TIME:  //case IptcDirectory.TAG_TIME_CREATED:   }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: switch (tagIdentifier) {  case IptcDirectory.TAG_RECORD_VERSION:  	// short  	short shortValue = (short)((base.data [anOffset] << 8) | base.data [anOffset + 1]);  	aDirectory.SetObject (tagIdentifier' shortValue);  	return;  case IptcDirectory.TAG_URGENCY:  	// byte  	aDirectory.SetObject (tagIdentifier' base.data [anOffset]);  	return;  case IptcDirectory.TAG_RELEASE_DATE:  case IptcDirectory.TAG_DATE_CREATED:  	// Date object  	if (aTagByteCount >= 8) {  		string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  		try {  			int year = Convert.ToInt32 (dateStr.Substring (0' 4));  			int month = Convert.ToInt32 (dateStr.Substring (4' 2));  			//No -1 here;  			int day = Convert.ToInt32 (dateStr.Substring (6' 2));  			DateTime date = new DateTime (year' month' day);  			aDirectory.SetObject (tagIdentifier' date);  			return;  		} catch (Exception) {  			// fall through and we'll store whatever was there as a String  		}  	}  	break;  // Added for .Net compiler  //case IptcDirectory.TAG_RELEASE_TIME:  //case IptcDirectory.TAG_TIME_CREATED:   }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: switch (tagIdentifier) {  case IptcDirectory.TAG_RECORD_VERSION:  	// short  	short shortValue = (short)((base.data [anOffset] << 8) | base.data [anOffset + 1]);  	aDirectory.SetObject (tagIdentifier' shortValue);  	return;  case IptcDirectory.TAG_URGENCY:  	// byte  	aDirectory.SetObject (tagIdentifier' base.data [anOffset]);  	return;  case IptcDirectory.TAG_RELEASE_DATE:  case IptcDirectory.TAG_DATE_CREATED:  	// Date object  	if (aTagByteCount >= 8) {  		string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  		try {  			int year = Convert.ToInt32 (dateStr.Substring (0' 4));  			int month = Convert.ToInt32 (dateStr.Substring (4' 2));  			//No -1 here;  			int day = Convert.ToInt32 (dateStr.Substring (6' 2));  			DateTime date = new DateTime (year' month' day);  			aDirectory.SetObject (tagIdentifier' date);  			return;  		} catch (Exception) {  			// fall through and we'll store whatever was there as a String  		}  	}  	break;  // Added for .Net compiler  //case IptcDirectory.TAG_RELEASE_TIME:  //case IptcDirectory.TAG_TIME_CREATED:   }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: if (aTagByteCount >= 8) {  	string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  	try {  		int year = Convert.ToInt32 (dateStr.Substring (0' 4));  		int month = Convert.ToInt32 (dateStr.Substring (4' 2));  		//No -1 here;  		int day = Convert.ToInt32 (dateStr.Substring (6' 2));  		DateTime date = new DateTime (year' month' day);  		aDirectory.SetObject (tagIdentifier' date);  		return;  	} catch (Exception) {  		// fall through and we'll store whatever was there as a String  	}  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: if (aTagByteCount >= 8) {  	string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  	try {  		int year = Convert.ToInt32 (dateStr.Substring (0' 4));  		int month = Convert.ToInt32 (dateStr.Substring (4' 2));  		//No -1 here;  		int day = Convert.ToInt32 (dateStr.Substring (6' 2));  		DateTime date = new DateTime (year' month' day);  		aDirectory.SetObject (tagIdentifier' date);  		return;  	} catch (Exception) {  		// fall through and we'll store whatever was there as a String  	}  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: if (aTagByteCount >= 8) {  	string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  	try {  		int year = Convert.ToInt32 (dateStr.Substring (0' 4));  		int month = Convert.ToInt32 (dateStr.Substring (4' 2));  		//No -1 here;  		int day = Convert.ToInt32 (dateStr.Substring (6' 2));  		DateTime date = new DateTime (year' month' day);  		aDirectory.SetObject (tagIdentifier' date);  		return;  	} catch (Exception) {  		// fall through and we'll store whatever was there as a String  	}  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: if (aTagByteCount >= 8) {  	string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  	try {  		int year = Convert.ToInt32 (dateStr.Substring (0' 4));  		int month = Convert.ToInt32 (dateStr.Substring (4' 2));  		//No -1 here;  		int day = Convert.ToInt32 (dateStr.Substring (6' 2));  		DateTime date = new DateTime (year' month' day);  		aDirectory.SetObject (tagIdentifier' date);  		return;  	} catch (Exception) {  		// fall through and we'll store whatever was there as a String  	}  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: if (aTagByteCount >= 8) {  	string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  	try {  		int year = Convert.ToInt32 (dateStr.Substring (0' 4));  		int month = Convert.ToInt32 (dateStr.Substring (4' 2));  		//No -1 here;  		int day = Convert.ToInt32 (dateStr.Substring (6' 2));  		DateTime date = new DateTime (year' month' day);  		aDirectory.SetObject (tagIdentifier' date);  		return;  	} catch (Exception) {  		// fall through and we'll store whatever was there as a String  	}  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: if (aTagByteCount >= 8) {  	string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  	try {  		int year = Convert.ToInt32 (dateStr.Substring (0' 4));  		int month = Convert.ToInt32 (dateStr.Substring (4' 2));  		//No -1 here;  		int day = Convert.ToInt32 (dateStr.Substring (6' 2));  		DateTime date = new DateTime (year' month' day);  		aDirectory.SetObject (tagIdentifier' date);  		return;  	} catch (Exception) {  		// fall through and we'll store whatever was there as a String  	}  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: try {  	int year = Convert.ToInt32 (dateStr.Substring (0' 4));  	int month = Convert.ToInt32 (dateStr.Substring (4' 2));  	//No -1 here;  	int day = Convert.ToInt32 (dateStr.Substring (6' 2));  	DateTime date = new DateTime (year' month' day);  	aDirectory.SetObject (tagIdentifier' date);  	return;  } catch (Exception) {  	// fall through and we'll store whatever was there as a String  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: try {  	int year = Convert.ToInt32 (dateStr.Substring (0' 4));  	int month = Convert.ToInt32 (dateStr.Substring (4' 2));  	//No -1 here;  	int day = Convert.ToInt32 (dateStr.Substring (6' 2));  	DateTime date = new DateTime (year' month' day);  	aDirectory.SetObject (tagIdentifier' date);  	return;  } catch (Exception) {  	// fall through and we'll store whatever was there as a String  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: try {  	int year = Convert.ToInt32 (dateStr.Substring (0' 4));  	int month = Convert.ToInt32 (dateStr.Substring (4' 2));  	//No -1 here;  	int day = Convert.ToInt32 (dateStr.Substring (6' 2));  	DateTime date = new DateTime (year' month' day);  	aDirectory.SetObject (tagIdentifier' date);  	return;  } catch (Exception) {  	// fall through and we'll store whatever was there as a String  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: try {  	int year = Convert.ToInt32 (dateStr.Substring (0' 4));  	int month = Convert.ToInt32 (dateStr.Substring (4' 2));  	//No -1 here;  	int day = Convert.ToInt32 (dateStr.Substring (6' 2));  	DateTime date = new DateTime (year' month' day);  	aDirectory.SetObject (tagIdentifier' date);  	return;  } catch (Exception) {  	// fall through and we'll store whatever was there as a String  }  
Magic Number,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following statement contains a magic number: try {  	int year = Convert.ToInt32 (dateStr.Substring (0' 4));  	int month = Convert.ToInt32 (dateStr.Substring (4' 2));  	//No -1 here;  	int day = Convert.ToInt32 (dateStr.Substring (6' 2));  	DateTime date = new DateTime (year' month' day);  	aDirectory.SetObject (tagIdentifier' date);  	return;  } catch (Exception) {  	// fall through and we'll store whatever was there as a String  }  
Magic Number,com.drew.metadata.jpeg,JpegComponent,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegComponent.cs,GetComponentName,The following statement contains a magic number: switch (this.componentId) {  case 1:  	return "Y";  case 2:  	return "Cb";  case 3:  	return "Cr";  case 4:  	return "I";  case 5:  	return "Q";  default:  	throw new MetadataException ("Unsupported component id: " + this.componentId);  }  
Magic Number,com.drew.metadata.jpeg,JpegComponent,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegComponent.cs,GetComponentName,The following statement contains a magic number: switch (this.componentId) {  case 1:  	return "Y";  case 2:  	return "Cb";  case 3:  	return "Cr";  case 4:  	return "I";  case 5:  	return "Q";  default:  	throw new MetadataException ("Unsupported component id: " + this.componentId);  }  
Magic Number,com.drew.metadata.jpeg,JpegComponent,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegComponent.cs,GetComponentName,The following statement contains a magic number: switch (this.componentId) {  case 1:  	return "Y";  case 2:  	return "Cb";  case 3:  	return "Cr";  case 4:  	return "I";  case 5:  	return "Q";  default:  	throw new MetadataException ("Unsupported component id: " + this.componentId);  }  
Magic Number,com.drew.metadata.jpeg,JpegComponent,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegComponent.cs,GetComponentName,The following statement contains a magic number: switch (this.componentId) {  case 1:  	return "Y";  case 2:  	return "Cb";  case 3:  	return "Cr";  case 4:  	return "I";  case 5:  	return "Q";  default:  	throw new MetadataException ("Unsupported component id: " + this.componentId);  }  
Magic Number,com.drew.metadata.jpeg,JpegDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegDescriptor.cs,GetDescription,The following statement contains a magic number: switch (tagType) {  case JpegDirectory.TAG_JPEG_COMPONENT_DATA_1:  	return GetComponentDataDescription (0);  case JpegDirectory.TAG_JPEG_COMPONENT_DATA_2:  	return GetComponentDataDescription (1);  case JpegDirectory.TAG_JPEG_COMPONENT_DATA_3:  	return GetComponentDataDescription (2);  case JpegDirectory.TAG_JPEG_COMPONENT_DATA_4:  	return GetComponentDataDescription (3);  case JpegDirectory.TAG_JPEG_DATA_PRECISION:  	return GetDataPrecisionDescription ();  case JpegDirectory.TAG_JPEG_IMAGE_HEIGHT:  	return GetImageHeightDescription ();  case JpegDirectory.TAG_JPEG_IMAGE_WIDTH:  	return GetImageWidthDescription ();  default:  	return base.directory.GetString (tagType);  }  
Magic Number,com.drew.metadata.jpeg,JpegDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegDescriptor.cs,GetDescription,The following statement contains a magic number: switch (tagType) {  case JpegDirectory.TAG_JPEG_COMPONENT_DATA_1:  	return GetComponentDataDescription (0);  case JpegDirectory.TAG_JPEG_COMPONENT_DATA_2:  	return GetComponentDataDescription (1);  case JpegDirectory.TAG_JPEG_COMPONENT_DATA_3:  	return GetComponentDataDescription (2);  case JpegDirectory.TAG_JPEG_COMPONENT_DATA_4:  	return GetComponentDataDescription (3);  case JpegDirectory.TAG_JPEG_DATA_PRECISION:  	return GetDataPrecisionDescription ();  case JpegDirectory.TAG_JPEG_IMAGE_HEIGHT:  	return GetImageHeightDescription ();  case JpegDirectory.TAG_JPEG_IMAGE_WIDTH:  	return GetImageWidthDescription ();  default:  	return base.directory.GetString (tagType);  }  
Magic Number,com.drew.metadata.jpeg,JpegDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegDescriptor.cs,GetDescription,The following statement contains a magic number: return GetComponentDataDescription (2);  
Magic Number,com.drew.metadata.jpeg,JpegDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegDescriptor.cs,GetDescription,The following statement contains a magic number: return GetComponentDataDescription (3);  
Magic Number,com.drew.metadata.jpeg,JpegReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\jpeg\JpegReader.cs,Extract,The following statement contains a magic number: try {  	// data precision  	int dataPrecision = base.Get16Bits (JpegDirectory.TAG_JPEG_DATA_PRECISION);  	lcDirectory.SetObject (JpegDirectory.TAG_JPEG_DATA_PRECISION' dataPrecision);  	// process height  	int height = base.Get32Bits (JpegDirectory.TAG_JPEG_IMAGE_HEIGHT);  	lcDirectory.SetObject (JpegDirectory.TAG_JPEG_IMAGE_HEIGHT' height);  	// process width  	int width = base.Get32Bits (JpegDirectory.TAG_JPEG_IMAGE_WIDTH);  	lcDirectory.SetObject (JpegDirectory.TAG_JPEG_IMAGE_WIDTH' width);  	// number of components  	int numberOfComponents = base.Get16Bits (JpegDirectory.TAG_JPEG_NUMBER_OF_COMPONENTS);  	lcDirectory.SetObject (JpegDirectory.TAG_JPEG_NUMBER_OF_COMPONENTS' numberOfComponents);  	// for each component' there are three bytes of data:  	// 1 - Component ID: 1 = Y' 2 = Cb' 3 = Cr' 4 = I' 5 = Q  	// 2 - Sampling factors: bit 0-3 vertical' 4-7 horizontal  	// 3 - Quantization table number  	int offset = 6;  	for (int i = 0; i < numberOfComponents; i++) {  		int componentId = base.Get16Bits (offset++);  		int samplingFactorByte = base.Get16Bits (offset++);  		int quantizationTableNumber = base.Get16Bits (offset++);  		JpegComponent lcJpegComponent = new JpegComponent (componentId' samplingFactorByte' quantizationTableNumber);  		lcDirectory.SetObject (JpegDirectory.TAG_JPEG_COMPONENT_DATA_1 + i' lcJpegComponent);  	}  } catch (MetadataException me) {  	lcDirectory.HasError = true;  	Trace.TraceError ("MetadataException: " + me.Message);  }  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,FindAsXml,The following statement contains a magic number: for (int i = 0; i < someArgs.Length; i++) {  	if (AS_XML2.Equals (someArgs [i]' StringComparison.OrdinalIgnoreCase)) {  		Run.asXml = (byte)2;  		break;  	}  	if (AS_XML.Equals (someArgs [i]' StringComparison.OrdinalIgnoreCase)) {  		Run.asXml = (byte)1;  		break;  	}  }  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,FindAsXml,The following statement contains a magic number: if (AS_XML2.Equals (someArgs [i]' StringComparison.OrdinalIgnoreCase)) {  	Run.asXml = (byte)2;  	break;  }  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,FindAsXml,The following statement contains a magic number: Run.asXml = (byte)2;  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The following statement contains a magic number: if (someArgs.Length == 0) {  	Console.Error.WriteLine ("Use: MetaDataExtractor [FilePaths|DirectoryPaths] [noUnknown|asXml|asXml2|doSub]");  	Console.Error.WriteLine ("     - noUnknown: will hide unknown metadata tag");  	Console.Error.WriteLine ("     - asXml    : will generate an XML stream");  	Console.Error.WriteLine ("     - asXml2   : will generate an XML stream with more information than asXml");  	Console.Error.WriteLine ("     - doSub    : will search subdirectories for *.jpg' *.raw' *.cr2' *.crw");  	Console.Error.WriteLine ("Examples:");  	Console.Error.WriteLine ("     - Will show you MyImage.jpg info as text:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\MyImage.jpg");  	Console.Error.WriteLine (" or ");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ and img1.jpg and img2.jpg info as text:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ d:\\img1.jpg e:\\img2.jpg");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as text but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ noUnknown");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as XML:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ asXml");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as XML2 but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ noUnknown asXml2");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\Temp\\ and all its subdirectories as XML but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\Temp noUnknown asXml doSub");  	Console.Error.WriteLine ("     - Will put in a file called sample.xml all c:\\Temp\\ *.jpg|*.raw|*.cr2|*.crw and all its subdirectories as XML but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\Temp noUnknown asXml doSub > sample.xml");  	Console.Error.WriteLine ("Cautions:");  	Console.Error.WriteLine (" + Pointing on c:\\ with doSub option is a very bad idea ;-)");  	Console.ReadLine ();  } else {  	Run.FindAsXml (someArgs);  	Run.FindNoUnknown (someArgs);  	Run.FindDoSub (someArgs);  	StringBuilder lcGlobalBuff = new StringBuilder (1024);  	IOutPutTextStreamHandler lcXmlHandler = null;  	string dtdFile = null;  	if (Run.asXml == (byte)1) {  		lcXmlHandler = new XmlOutPutStreamHandler ();  		dtdFile = "MetadataExtractor.dtd";  	} else if (Run.asXml == (byte)2) {  		lcXmlHandler = new XmlNewOutPutStreamHandler ();  		dtdFile = "MetadataExtractorNew.dtd";  	} else {  		lcXmlHandler = new TxtOutPutStreamHandler ();  	}  	lcXmlHandler.DoUnknown = !Run.noUnknown;  	List<string> lcFileNameLst = Run.FindFileNames (someArgs);  	// Args for OutPutTextStream objects  	// Indicate your Xsl here  	string lcXslFileName = null;  	// For example: ="exif.xslt";  	// Indicate if you want to use CDDATA in your XML stream  	string useCDDATA = "false";  	string[] lcOutputParams = new string[] {  		"ISO-8859-1"'  		lcXslFileName'  		lcFileNameLst.Count.ToString ()'  		dtdFile'  		useCDDATA  	};  	lcXmlHandler.StartTextStream (lcGlobalBuff' lcOutputParams);  	foreach (string lcFileName in lcFileNameLst) {  		StringBuilder lcBuff = new StringBuilder (2048);  		//Metadata lcMetadata = null;  		try {  			FileInfo lcImgFileInfo = new FileInfo (lcFileName);  			if (lcFileName.ToLower ().EndsWith (".raw") || lcFileName.ToLower ().EndsWith (".cr2") || lcFileName.ToLower ().EndsWith (".crw")) {  				lcMetadata = TiffMetadataReader.ReadMetadata (lcImgFileInfo);  			} else {  				lcMetadata = JpegMetadataReader.ReadMetadata (lcImgFileInfo);  			}  			lcXmlHandler.Metadata = lcMetadata;  		} catch (JpegProcessingException e) {  			Console.Error.WriteLine ("Could note analyse the file '" + lcFileName + "' error message is:" + e.Message);  			break;  		}  		if (Run.asXml != (byte)0) {  			// First open file name tag  			lcBuff.Append ("<file name=\"");  			lcXmlHandler.Normalize (lcBuff' lcFileName' false);  			lcBuff.Append ("\">").AppendLine ();  			// Then create all directory tag  			lcBuff.Append (lcXmlHandler.AsText ());  			// Then close file tag  			lcBuff.Append ("</file>").AppendLine ().AppendLine ();  		} else {  			lcBuff.Append ("-> ");  			lcXmlHandler.Normalize (lcBuff' lcFileName' false);  			lcBuff.Append (" <-").AppendLine ();  			// Then create all directory tag  			lcBuff.Append (lcXmlHandler.AsText ()).AppendLine ();  		}  		lcMetadata = null;  		// Adds result for this file to big buffer  		lcGlobalBuff.Append (lcBuff);  		lcGlobalBuff.AppendLine ();  	}  	lcXmlHandler.EndTextStream (lcGlobalBuff' lcOutputParams);  	Console.Out.WriteLine (lcGlobalBuff.ToString ());  }  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The following statement contains a magic number: if (someArgs.Length == 0) {  	Console.Error.WriteLine ("Use: MetaDataExtractor [FilePaths|DirectoryPaths] [noUnknown|asXml|asXml2|doSub]");  	Console.Error.WriteLine ("     - noUnknown: will hide unknown metadata tag");  	Console.Error.WriteLine ("     - asXml    : will generate an XML stream");  	Console.Error.WriteLine ("     - asXml2   : will generate an XML stream with more information than asXml");  	Console.Error.WriteLine ("     - doSub    : will search subdirectories for *.jpg' *.raw' *.cr2' *.crw");  	Console.Error.WriteLine ("Examples:");  	Console.Error.WriteLine ("     - Will show you MyImage.jpg info as text:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\MyImage.jpg");  	Console.Error.WriteLine (" or ");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ and img1.jpg and img2.jpg info as text:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ d:\\img1.jpg e:\\img2.jpg");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as text but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ noUnknown");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as XML:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ asXml");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as XML2 but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ noUnknown asXml2");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\Temp\\ and all its subdirectories as XML but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\Temp noUnknown asXml doSub");  	Console.Error.WriteLine ("     - Will put in a file called sample.xml all c:\\Temp\\ *.jpg|*.raw|*.cr2|*.crw and all its subdirectories as XML but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\Temp noUnknown asXml doSub > sample.xml");  	Console.Error.WriteLine ("Cautions:");  	Console.Error.WriteLine (" + Pointing on c:\\ with doSub option is a very bad idea ;-)");  	Console.ReadLine ();  } else {  	Run.FindAsXml (someArgs);  	Run.FindNoUnknown (someArgs);  	Run.FindDoSub (someArgs);  	StringBuilder lcGlobalBuff = new StringBuilder (1024);  	IOutPutTextStreamHandler lcXmlHandler = null;  	string dtdFile = null;  	if (Run.asXml == (byte)1) {  		lcXmlHandler = new XmlOutPutStreamHandler ();  		dtdFile = "MetadataExtractor.dtd";  	} else if (Run.asXml == (byte)2) {  		lcXmlHandler = new XmlNewOutPutStreamHandler ();  		dtdFile = "MetadataExtractorNew.dtd";  	} else {  		lcXmlHandler = new TxtOutPutStreamHandler ();  	}  	lcXmlHandler.DoUnknown = !Run.noUnknown;  	List<string> lcFileNameLst = Run.FindFileNames (someArgs);  	// Args for OutPutTextStream objects  	// Indicate your Xsl here  	string lcXslFileName = null;  	// For example: ="exif.xslt";  	// Indicate if you want to use CDDATA in your XML stream  	string useCDDATA = "false";  	string[] lcOutputParams = new string[] {  		"ISO-8859-1"'  		lcXslFileName'  		lcFileNameLst.Count.ToString ()'  		dtdFile'  		useCDDATA  	};  	lcXmlHandler.StartTextStream (lcGlobalBuff' lcOutputParams);  	foreach (string lcFileName in lcFileNameLst) {  		StringBuilder lcBuff = new StringBuilder (2048);  		//Metadata lcMetadata = null;  		try {  			FileInfo lcImgFileInfo = new FileInfo (lcFileName);  			if (lcFileName.ToLower ().EndsWith (".raw") || lcFileName.ToLower ().EndsWith (".cr2") || lcFileName.ToLower ().EndsWith (".crw")) {  				lcMetadata = TiffMetadataReader.ReadMetadata (lcImgFileInfo);  			} else {  				lcMetadata = JpegMetadataReader.ReadMetadata (lcImgFileInfo);  			}  			lcXmlHandler.Metadata = lcMetadata;  		} catch (JpegProcessingException e) {  			Console.Error.WriteLine ("Could note analyse the file '" + lcFileName + "' error message is:" + e.Message);  			break;  		}  		if (Run.asXml != (byte)0) {  			// First open file name tag  			lcBuff.Append ("<file name=\"");  			lcXmlHandler.Normalize (lcBuff' lcFileName' false);  			lcBuff.Append ("\">").AppendLine ();  			// Then create all directory tag  			lcBuff.Append (lcXmlHandler.AsText ());  			// Then close file tag  			lcBuff.Append ("</file>").AppendLine ().AppendLine ();  		} else {  			lcBuff.Append ("-> ");  			lcXmlHandler.Normalize (lcBuff' lcFileName' false);  			lcBuff.Append (" <-").AppendLine ();  			// Then create all directory tag  			lcBuff.Append (lcXmlHandler.AsText ()).AppendLine ();  		}  		lcMetadata = null;  		// Adds result for this file to big buffer  		lcGlobalBuff.Append (lcBuff);  		lcGlobalBuff.AppendLine ();  	}  	lcXmlHandler.EndTextStream (lcGlobalBuff' lcOutputParams);  	Console.Out.WriteLine (lcGlobalBuff.ToString ());  }  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The following statement contains a magic number: if (someArgs.Length == 0) {  	Console.Error.WriteLine ("Use: MetaDataExtractor [FilePaths|DirectoryPaths] [noUnknown|asXml|asXml2|doSub]");  	Console.Error.WriteLine ("     - noUnknown: will hide unknown metadata tag");  	Console.Error.WriteLine ("     - asXml    : will generate an XML stream");  	Console.Error.WriteLine ("     - asXml2   : will generate an XML stream with more information than asXml");  	Console.Error.WriteLine ("     - doSub    : will search subdirectories for *.jpg' *.raw' *.cr2' *.crw");  	Console.Error.WriteLine ("Examples:");  	Console.Error.WriteLine ("     - Will show you MyImage.jpg info as text:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\MyImage.jpg");  	Console.Error.WriteLine (" or ");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ and img1.jpg and img2.jpg info as text:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ d:\\img1.jpg e:\\img2.jpg");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as text but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ noUnknown");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as XML:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ asXml");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\ as XML2 but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\ noUnknown asXml2");  	Console.Error.WriteLine ("     - Will show you all *.jpg|*.raw|*.cr2|*.crw in c:\\Temp\\ and all its subdirectories as XML but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\Temp noUnknown asXml doSub");  	Console.Error.WriteLine ("     - Will put in a file called sample.xml all c:\\Temp\\ *.jpg|*.raw|*.cr2|*.crw and all its subdirectories as XML but with no unkown tags:");  	Console.Error.WriteLine ("       MetaDataExtractor c:\\Temp noUnknown asXml doSub > sample.xml");  	Console.Error.WriteLine ("Cautions:");  	Console.Error.WriteLine (" + Pointing on c:\\ with doSub option is a very bad idea ;-)");  	Console.ReadLine ();  } else {  	Run.FindAsXml (someArgs);  	Run.FindNoUnknown (someArgs);  	Run.FindDoSub (someArgs);  	StringBuilder lcGlobalBuff = new StringBuilder (1024);  	IOutPutTextStreamHandler lcXmlHandler = null;  	string dtdFile = null;  	if (Run.asXml == (byte)1) {  		lcXmlHandler = new XmlOutPutStreamHandler ();  		dtdFile = "MetadataExtractor.dtd";  	} else if (Run.asXml == (byte)2) {  		lcXmlHandler = new XmlNewOutPutStreamHandler ();  		dtdFile = "MetadataExtractorNew.dtd";  	} else {  		lcXmlHandler = new TxtOutPutStreamHandler ();  	}  	lcXmlHandler.DoUnknown = !Run.noUnknown;  	List<string> lcFileNameLst = Run.FindFileNames (someArgs);  	// Args for OutPutTextStream objects  	// Indicate your Xsl here  	string lcXslFileName = null;  	// For example: ="exif.xslt";  	// Indicate if you want to use CDDATA in your XML stream  	string useCDDATA = "false";  	string[] lcOutputParams = new string[] {  		"ISO-8859-1"'  		lcXslFileName'  		lcFileNameLst.Count.ToString ()'  		dtdFile'  		useCDDATA  	};  	lcXmlHandler.StartTextStream (lcGlobalBuff' lcOutputParams);  	foreach (string lcFileName in lcFileNameLst) {  		StringBuilder lcBuff = new StringBuilder (2048);  		//Metadata lcMetadata = null;  		try {  			FileInfo lcImgFileInfo = new FileInfo (lcFileName);  			if (lcFileName.ToLower ().EndsWith (".raw") || lcFileName.ToLower ().EndsWith (".cr2") || lcFileName.ToLower ().EndsWith (".crw")) {  				lcMetadata = TiffMetadataReader.ReadMetadata (lcImgFileInfo);  			} else {  				lcMetadata = JpegMetadataReader.ReadMetadata (lcImgFileInfo);  			}  			lcXmlHandler.Metadata = lcMetadata;  		} catch (JpegProcessingException e) {  			Console.Error.WriteLine ("Could note analyse the file '" + lcFileName + "' error message is:" + e.Message);  			break;  		}  		if (Run.asXml != (byte)0) {  			// First open file name tag  			lcBuff.Append ("<file name=\"");  			lcXmlHandler.Normalize (lcBuff' lcFileName' false);  			lcBuff.Append ("\">").AppendLine ();  			// Then create all directory tag  			lcBuff.Append (lcXmlHandler.AsText ());  			// Then close file tag  			lcBuff.Append ("</file>").AppendLine ().AppendLine ();  		} else {  			lcBuff.Append ("-> ");  			lcXmlHandler.Normalize (lcBuff' lcFileName' false);  			lcBuff.Append (" <-").AppendLine ();  			// Then create all directory tag  			lcBuff.Append (lcXmlHandler.AsText ()).AppendLine ();  		}  		lcMetadata = null;  		// Adds result for this file to big buffer  		lcGlobalBuff.Append (lcBuff);  		lcGlobalBuff.AppendLine ();  	}  	lcXmlHandler.EndTextStream (lcGlobalBuff' lcOutputParams);  	Console.Out.WriteLine (lcGlobalBuff.ToString ());  }  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The following statement contains a magic number: if (Run.asXml == (byte)1) {  	lcXmlHandler = new XmlOutPutStreamHandler ();  	dtdFile = "MetadataExtractor.dtd";  } else if (Run.asXml == (byte)2) {  	lcXmlHandler = new XmlNewOutPutStreamHandler ();  	dtdFile = "MetadataExtractorNew.dtd";  } else {  	lcXmlHandler = new TxtOutPutStreamHandler ();  }  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The following statement contains a magic number: if (Run.asXml == (byte)2) {  	lcXmlHandler = new XmlNewOutPutStreamHandler ();  	dtdFile = "MetadataExtractorNew.dtd";  } else {  	lcXmlHandler = new TxtOutPutStreamHandler ();  }  
Magic Number,com,Run,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\Run.cs,Main,The following statement contains a magic number: foreach (string lcFileName in lcFileNameLst) {  	StringBuilder lcBuff = new StringBuilder (2048);  	//Metadata lcMetadata = null;  	try {  		FileInfo lcImgFileInfo = new FileInfo (lcFileName);  		if (lcFileName.ToLower ().EndsWith (".raw") || lcFileName.ToLower ().EndsWith (".cr2") || lcFileName.ToLower ().EndsWith (".crw")) {  			lcMetadata = TiffMetadataReader.ReadMetadata (lcImgFileInfo);  		} else {  			lcMetadata = JpegMetadataReader.ReadMetadata (lcImgFileInfo);  		}  		lcXmlHandler.Metadata = lcMetadata;  	} catch (JpegProcessingException e) {  		Console.Error.WriteLine ("Could note analyse the file '" + lcFileName + "' error message is:" + e.Message);  		break;  	}  	if (Run.asXml != (byte)0) {  		// First open file name tag  		lcBuff.Append ("<file name=\"");  		lcXmlHandler.Normalize (lcBuff' lcFileName' false);  		lcBuff.Append ("\">").AppendLine ();  		// Then create all directory tag  		lcBuff.Append (lcXmlHandler.AsText ());  		// Then close file tag  		lcBuff.Append ("</file>").AppendLine ().AppendLine ();  	} else {  		lcBuff.Append ("-> ");  		lcXmlHandler.Normalize (lcBuff' lcFileName' false);  		lcBuff.Append (" <-").AppendLine ();  		// Then create all directory tag  		lcBuff.Append (lcXmlHandler.AsText ()).AppendLine ();  	}  	lcMetadata = null;  	// Adds result for this file to big buffer  	lcGlobalBuff.Append (lcBuff);  	lcGlobalBuff.AppendLine ();  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 4) {  	// We want to use CDDATA  	this.UseCDData = "true".Equals (someParam [4]' StringComparison.OrdinalIgnoreCase);  } else {  	this.UseCDData = false;  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 4) {  	// We want to use CDDATA  	this.UseCDData = "true".Equals (someParam [4]' StringComparison.OrdinalIgnoreCase);  } else {  	this.UseCDData = false;  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: this.UseCDData = "true".Equals (someParam [4]' StringComparison.OrdinalIgnoreCase);  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 3) {  	// We've got a DTD  	this.DtdFileName = someParam [3];  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 3) {  	// We've got a DTD  	this.DtdFileName = someParam [3];  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: this.DtdFileName = someParam [3];  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 2) {  	int lcNbFile = 0;  	try {  		lcNbFile = Convert.ToInt16 (someParam [2]);  		// Finally will Open tag  	} catch (FormatException e) {  		// An error occured  		aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  		lcNbFile = -1;  	} finally {  		// Then we deal with more than one file  		Open (aBuff' "metadataExtractor"' "nbFile"' lcNbFile.ToString ()' true);  	}  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 2) {  	int lcNbFile = 0;  	try {  		lcNbFile = Convert.ToInt16 (someParam [2]);  		// Finally will Open tag  	} catch (FormatException e) {  		// An error occured  		aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  		lcNbFile = -1;  	} finally {  		// Then we deal with more than one file  		Open (aBuff' "metadataExtractor"' "nbFile"' lcNbFile.ToString ()' true);  	}  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: try {  	lcNbFile = Convert.ToInt16 (someParam [2]);  	// Finally will Open tag  } catch (FormatException e) {  	// An error occured  	aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  	lcNbFile = -1;  } finally {  	// Then we deal with more than one file  	Open (aBuff' "metadataExtractor"' "nbFile"' lcNbFile.ToString ()' true);  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: lcNbFile = Convert.ToInt16 (someParam [2]);  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,EndTextStream,The following statement contains a magic number: if (someParam.Length >= 2) {  	int lcNbFile = 0;  	try {  		lcNbFile = Convert.ToInt16 (someParam [2]);  		// Finally will close files tag  	} catch (FormatException e) {  		// An error occured  		aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  	} finally {  		Close (aBuff' "metadataExtractor"' true);  	}  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,EndTextStream,The following statement contains a magic number: if (someParam.Length >= 2) {  	int lcNbFile = 0;  	try {  		lcNbFile = Convert.ToInt16 (someParam [2]);  		// Finally will close files tag  	} catch (FormatException e) {  		// An error occured  		aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  	} finally {  		Close (aBuff' "metadataExtractor"' true);  	}  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,EndTextStream,The following statement contains a magic number: try {  	lcNbFile = Convert.ToInt16 (someParam [2]);  	// Finally will close files tag  } catch (FormatException e) {  	// An error occured  	aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  } finally {  	Close (aBuff' "metadataExtractor"' true);  }  
Magic Number,com.utils.xml,XmlNewOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlNewOutPutStreamHandler.cs,EndTextStream,The following statement contains a magic number: lcNbFile = Convert.ToInt16 (someParam [2]);  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 3) {  	// We've got a DTD  	this.DtdFileName = someParam [3];  }  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 3) {  	// We've got a DTD  	this.DtdFileName = someParam [3];  }  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: this.DtdFileName = someParam [3];  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 2) {  	int lcNbFile = 0;  	try {  		lcNbFile = Convert.ToInt16 (someParam [2]);  		// Finally will open tag  	} catch (FormatException e) {  		// An error occured  		aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  		lcNbFile = -1;  	} finally {  		// Then we deal with more than one file  		Open (aBuff' "metadataExtractor"' "nbFile"' lcNbFile.ToString ()' true);  	}  }  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: if (someParam.Length > 2) {  	int lcNbFile = 0;  	try {  		lcNbFile = Convert.ToInt16 (someParam [2]);  		// Finally will open tag  	} catch (FormatException e) {  		// An error occured  		aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  		lcNbFile = -1;  	} finally {  		// Then we deal with more than one file  		Open (aBuff' "metadataExtractor"' "nbFile"' lcNbFile.ToString ()' true);  	}  }  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: try {  	lcNbFile = Convert.ToInt16 (someParam [2]);  	// Finally will open tag  } catch (FormatException e) {  	// An error occured  	aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  	lcNbFile = -1;  } finally {  	// Then we deal with more than one file  	Open (aBuff' "metadataExtractor"' "nbFile"' lcNbFile.ToString ()' true);  }  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,StartTextStream,The following statement contains a magic number: lcNbFile = Convert.ToInt16 (someParam [2]);  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,EndTextStream,The following statement contains a magic number: if (someParam.Length >= 2) {  	int lcNbFile = 0;  	try {  		lcNbFile = Convert.ToInt16 (someParam [2]);  		// Finally will close files tag  	} catch (FormatException e) {  		// An error occured  		aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  	} finally {  		Close (aBuff' "metadataExtractor"' true);  	}  }  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,EndTextStream,The following statement contains a magic number: if (someParam.Length >= 2) {  	int lcNbFile = 0;  	try {  		lcNbFile = Convert.ToInt16 (someParam [2]);  		// Finally will close files tag  	} catch (FormatException e) {  		// An error occured  		aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  	} finally {  		Close (aBuff' "metadataExtractor"' true);  	}  }  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,EndTextStream,The following statement contains a magic number: try {  	lcNbFile = Convert.ToInt16 (someParam [2]);  	// Finally will close files tag  } catch (FormatException e) {  	// An error occured  	aBuff.Append ("<!-- ").Append (e.Message).Append (" -->");  } finally {  	Close (aBuff' "metadataExtractor"' true);  }  
Magic Number,com.utils.xml,XmlOutPutStreamHandler,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\utils\xml\XmlOutPutStreamHandler.cs,EndTextStream,The following statement contains a magic number: lcNbFile = Convert.ToInt16 (someParam [2]);  
Duplicate Code,com.codec.jpeg,JPEGQTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGQTable.cs,InitStdChrominance,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 36)' (18' 37)' (19' 38)' (20' 39)' (21' 40)' (22' 41)' (23' 42)' (24' 43)' (25' 44)' (26' 45)' (27' 46)' (28' 47)' (29' 48)' (30' 49)' (31' 50)' (32' 51)' (33' 52)' (34' 53)' (35' 54)' (36' 55)' (37' 56)' (38' 57)' (39' 58)' (40' 59)' (41' 60)' (42' 61)' (43' 62)' (44' 63)' (45' 64)' (46' 65))
Duplicate Code,com.codec.jpeg,JPEGQTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGQTable.cs,InitStdChrominance,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 64)' (18' 65))
Duplicate Code,com.codec.jpeg,JPEGQTable,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\codec\jpeg\JPEGQTable.cs,InitStdChrominance,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 36)' (19' 38)' (20' 39)' (21' 40)' (22' 41)' (23' 42)' (24' 43)' (25' 44)' (26' 45)' (27' 46)' (28' 47)' (29' 48)' (30' 49)' (31' 50)' (32' 51)' (33' 52)' (34' 53)' (35' 54)' (36' 55)' (37' 56)' (38' 57)' (39' 58)' (40' 59)' (41' 60)' (42' 61)' (43' 62)' (44' 63)' (45' 64)' (46' 65))
Missing Default,com.drew.metadata.exif,OlympusDescriptor,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\exif\OlympusDescriptor.cs,GetSpecialModeDescription,The following switch statement is missing a default case: switch (values [2]) {  case 1:  	desc.Append (BUNDLE ["LEFT_TO_RIGHT_PAN_DIR"]);  	break;  case 2:  	desc.Append (BUNDLE ["RIGHT_TO_LEFT_PAN_DIR"]);  	break;  case 3:  	desc.Append (BUNDLE ["BOTTOM_TO_TOP_PAN_DIR"]);  	break;  case 4:  	desc.Append (BUNDLE ["TOP_TO_BOTTOM_PAN_DIR"]);  	break;  }  
Missing Default,com.drew.metadata.iptc,IptcReader,F:\newReposMay17\diydrones_MissionPlanner\ExtLibs\MetaDataExtractorCSharp240d\com\drew\metadata\iptc\IptcReader.cs,ProcessTag,The following switch statement is missing a default case: switch (tagIdentifier) {  case IptcDirectory.TAG_RECORD_VERSION:  	// short  	short shortValue = (short)((base.data [anOffset] << 8) | base.data [anOffset + 1]);  	aDirectory.SetObject (tagIdentifier' shortValue);  	return;  case IptcDirectory.TAG_URGENCY:  	// byte  	aDirectory.SetObject (tagIdentifier' base.data [anOffset]);  	return;  case IptcDirectory.TAG_RELEASE_DATE:  case IptcDirectory.TAG_DATE_CREATED:  	// Date object  	if (aTagByteCount >= 8) {  		string dateStr = Utils.Decode (base.data' anOffset' aTagByteCount' false);  		try {  			int year = Convert.ToInt32 (dateStr.Substring (0' 4));  			int month = Convert.ToInt32 (dateStr.Substring (4' 2));  			//No -1 here;  			int day = Convert.ToInt32 (dateStr.Substring (6' 2));  			DateTime date = new DateTime (year' month' day);  			aDirectory.SetObject (tagIdentifier' date);  			return;  		} catch (Exception) {  			// fall through and we'll store whatever was there as a String  		}  	}  	break;  // Added for .Net compiler  //case IptcDirectory.TAG_RELEASE_TIME:  //case IptcDirectory.TAG_TIME_CREATED:   }  
