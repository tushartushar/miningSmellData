Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The method has 551 lines of code.
Long Method,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The method has 437 lines of code.
Long Method,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The method has 878 lines of code.
Long Method,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,OnTouch,The method has 114 lines of code.
Long Method,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The method has 200 lines of code.
Long Method,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,UploadPX4,The method has 122 lines of code.
Long Method,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,AttemptRebootToBootloader,The method has 101 lines of code.
Long Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The method has 183 lines of code.
Long Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The method has 101 lines of code.
Long Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseMove,The method has 223 lines of code.
Long Method,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The method has 706 lines of code.
Long Method,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The method has 382 lines of code.
Long Method,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,CreateOverlay,The method has 204 lines of code.
Long Method,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,RegenerateWPRoute,The method has 106 lines of code.
Complex Method,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,Cyclomatic complexity of the method is 13
Complex Method,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,Cyclomatic complexity of the method is 71
Complex Method,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,Cyclomatic complexity of the method is 45
Complex Method,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,Cyclomatic complexity of the method is 93
Complex Method,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,Cyclomatic complexity of the method is 10
Complex Method,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,OnTouch,Cyclomatic complexity of the method is 12
Complex Method,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,Cyclomatic complexity of the method is 10
Complex Method,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,Cyclomatic complexity of the method is 13
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,Cyclomatic complexity of the method is 20
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,GetRectOfAllMarkers,Cyclomatic complexity of the method is 11
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,GetRectOfAllRoutes,Cyclomatic complexity of the method is 12
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,Cyclomatic complexity of the method is 16
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnSizeChanged,Cyclomatic complexity of the method is 10
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseUp,Cyclomatic complexity of the method is 10
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseClick,Cyclomatic complexity of the method is 17
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseMove,Cyclomatic complexity of the method is 35
Complex Method,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseWheel,Cyclomatic complexity of the method is 12
Complex Method,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,Polygons_CollectionChanged,Cyclomatic complexity of the method is 9
Complex Method,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,Routes_CollectionChanged,Cyclomatic complexity of the method is 9
Complex Method,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,Markers_CollectionChanged,Cyclomatic complexity of the method is 9
Complex Method,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,ForceUpdate,Cyclomatic complexity of the method is 8
Complex Method,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,Cyclomatic complexity of the method is 16
Complex Method,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,Cyclomatic complexity of the method is 11
Complex Method,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,LoadBitmap,Cyclomatic complexity of the method is 10
Complex Method,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,Cyclomatic complexity of the method is 57
Complex Method,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,Cyclomatic complexity of the method is 55
Complex Method,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,CreateOverlay,Cyclomatic complexity of the method is 26
Complex Method,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,addpolygonmarker,Cyclomatic complexity of the method is 8
Complex Method,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,RegenerateWPRoute,Cyclomatic complexity of the method is 12
Complex Method,MissionPlanner.test,FirmwareSelection,D:\research\architectureSmells\repos\diydrones_MissionPlanner\test\FirmwareSelection.xaml.cs,OnSelectedIndexChanged,Cyclomatic complexity of the method is 12
Long Parameter List,Xamarin,App,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\App.xaml.cs,CustomMessageBox_ShowEvent,The method has 6 parameters. Parameters: text' caption' buttons' icon' YesText' NoText
Long Parameter List,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,addpolygonmarker,The method has 6 parameters. Parameters: tag' lng' lat' alt' color' overlay
Long Parameter List,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,addpolygonmarkerred,The method has 6 parameters. Parameters: tag' lng' lat' alt' color' overlay
Long Parameter List,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,The method has 6 parameters. Parameters: text' font' fontsize' brush' x' y
Long Parameter List,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,GMapMarkerBoat,The method has 5 parameters. Parameters: p' heading' cog' nav_bearing' target
Long Parameter List,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,GMapMarkerPlane,The method has 7 parameters. Parameters: which' p' heading' cog' nav_bearing' target' radius
Long Parameter List,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,GMapMarkerQuad,The method has 5 parameters. Parameters: p' heading' cog' target' sysid
Long Parameter List,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,GMapMarkerRover,The method has 5 parameters. Parameters: p' heading' cog' nav_bearing' target
Long Parameter List,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,GMapMarkerSingle,The method has 5 parameters. Parameters: p' heading' cog' target' sysid
Long Parameter List,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,GMapMarkerSub,The method has 5 parameters. Parameters: p' heading' cog' nav_bearing' target
Long Parameter List,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,CreateOverlay,The method has 5 parameters. Parameters: altmode' home' missionitems' wpradius' loiterradius
Long Parameter List,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,addpolygonmarker,The method has 8 parameters. Parameters: tag' lng' lat' alt' color' wpradius' type' fillcolor
Long Identifier,Xamarin,InputBox,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,Show,The length of the parameter enterTheUrlToTheMjpegSourceUrl is 30.
Long Identifier,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,,The length of the parameter _graphicsContextGraphicsContext is 31.
Long Statement,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The length of the statement  "                if ((MAV.sysid >= 1) && (MAV.sysid <= 6)) { which = MAV.sysid - 1; }  //1=black' 2=blue' 3=green'4=yellow'5=orange'6=red " is 120.
Long Statement,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The length of the statement  "                if ((MAV.sysid >= 11) && (MAV.sysid <= 16)) { which = MAV.sysid - 11; }  //1=black' 2=blue' 3=green'4=yellow'5=orange'6=red " is 123.
Long Statement,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The length of the statement  "                if ((MAV.sysid >= 101) && (MAV.sysid <= 106)) { which = MAV.sysid - 101; }  //1=black' 2=blue' 3=green'4=yellow'5=orange'6=red " is 126.
Long Statement,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The length of the statement  "                        //Console.WriteLine(MainV2.comPort.lastlogread.Second + " " + DateTime.Now.Second + " " + (MainV2.comPort.lastlogread.Second - DateTime.Now.Second)); " is 149.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        /*ggr.TranslateTransform((Single)(Center.X + m_ScaleNumbersRadius * Math.Cos((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))' " is 173.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                           (Single)(Center.Y + m_ScaleNumbersRadius * Math.Sin((m_BaseArcStart + countValue * m_BaseArcSweep / (m_MaxValue - m_MinValue)) * Math.PI / 180.0f))'  " is 148.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                Single brushAngle = (Int32)(m_BaseArcStart + (m_value[m_NeedIdx] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue)) % 360; " is 131.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 209.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255)); " is 130.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255)); " is 133.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 177.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 176.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 178.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 177.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 180.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 179.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 179.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2)); " is 158.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2)); " is 158.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2)); " is 158.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2)); " is 158.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2)); " is 158.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2)); " is 158.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2)); " is 158.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2)); " is 158.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                        pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6); " is 209.
Long Statement,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The length of the statement  "                                pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y); " is 120.
Long Statement,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The length of the statement  "                                //drawstring(e'a.ToString()' new Font("Arial"' 10)' whiteBrush' this.Width / 2 - lengthshort - 20 - halfwidth' this.Height / 2 + pitchoffset + a * every5deg - 8); " is 162.
Long Statement,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The length of the statement  "                //                Console.WriteLine("HUD 0 " + (DateTime.Now - starttime).TotalMilliseconds + " " + DateTime.Now.Millisecond); " is 126.
Long Statement,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The length of the statement  "                            //Console.WriteLine(a + " " + scrollbg.Right + " " + (scrollbg.Top - space * (a - start)) + " " + (scrollbg.Right - 20) + " " + (scrollbg.Top - space * (a - start))); " is 166.
Long Statement,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The length of the statement  "                            //Console.WriteLine(a + " " + scrollbg.Left + " " + (scrollbg.Top - space * (a - start)) + " " + (scrollbg.Left + 20) + " " + (scrollbg.Top - space * (a - start))); " is 164.
Long Statement,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The length of the statement  "                //                Console.WriteLine("HUD 1 " + (DateTime.Now - starttime).TotalMilliseconds + " " + DateTime.Now.Millisecond); " is 126.
Long Statement,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,The length of the statement  "                    graphicsObject.DrawImage(charDict[charid].bitmap' (int)x' (int)y' charDict[charid].bitmap.Width' charDict[charid].bitmap.Height); " is 129.
Long Statement,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The length of the statement  "            //g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length' (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length); " is 184.
Long Statement,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The length of the statement  "            //g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length' (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length); " is 184.
Long Statement,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The length of the statement  "            //g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length' (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length); " is 184.
Long Statement,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,Update,The length of the statement  "                GMapMarkerDistance home_kmleft_marker = new GMapMarkerDistance(HomeLocation' battery_kmleft * 1000.0' Settings.Instance.GetFloat("Propagation_Tolerance")); " is 155.
Long Statement,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,Update,The length of the statement  "                GMapMarkerDistance drone_kmleft_marker = new GMapMarkerDistance(Location' battery_kmleft * 1000.0' Settings.Instance.GetFloat("Propagation_Tolerance")); " is 152.
Long Statement,MissionPlanner.Maps,WMSProvider,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WMSProvider.cs,MakeTileImageUrl,The length of the statement  "                    "VERSION=1.1.1&REQUEST=GetMap&SERVICE=WMS&styles=&bbox={0}'{1}'{2}'{3}&width={4}&height={5}&srs=EPSG:4326&format=image/png"' " is 124.
Long Statement,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The length of the statement  "                              g.FillRectangle(EmptytileBrush' new System.Drawing.Rectangle((int) Core.tileRect.X' (int) Core.tileRect.Y' (int) Core.tileRect.Width' (int) Core.tileRect.Height)); " is 163.
Long Statement,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The length of the statement  "                              g.DrawString("Exception: " + ex.Message' MissingDataFont' TileGridMissingTextBrush' new RectangleF(Core.tileRect.X + 11' Core.tileRect.Y + 11' Core.tileRect.Width - 11' Core.tileRect.Height - 11)); " is 197.
Long Statement,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The length of the statement  "                              g.DrawString(EmptyTileText' MissingDataFont' TileGridMissingTextBrush' new RectangleF(Core.tileRect.X' Core.tileRect.Y + Core.tileRect.Width / 2 + (ShowTileGridLines ? 11 : -22)' Core.tileRect.Width' Core.tileRect.Height)' BottomFormat); " is 237.
Long Statement,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The length of the statement  "                           g.DrawString((tilePoint.PosXY == Core.centerTileXYLocation ? "" : "TILE: ") + tilePoint' MissingDataFont' TileGridLinesTextBrush' new RectangleF(Core.tileRect.X' Core.tileRect.Y' Core.tileRect.Width' Core.tileRect.Height)' CenterFormat); " is 237.
Long Statement,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,ToImage,The length of the statement  "                 //    g.CopyFromScreen(PointToScreen(new System.Drawing.Point()).X' PointToScreen(new System.Drawing.Point()).Y' 0' 0' new System.Drawing.Size(Width' Height)); " is 159.
Long Statement,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseMove,The length of the statement  "            if(isSelected && !selectionStart.IsEmpty && (Form.ModifierKeys == Keys.Alt || Form.ModifierKeys == Keys.Shift || DisableAltForSelection)) " is 137.
Long Statement,GMap.NET.WindowsForms,GMapImageProxy,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapImage.cs,ApplyColorMatrix,The length of the statement  "                  g.DrawImage(original' new Rectangle(0' 0' original.Width' original.Height)' 0' 0' original.Width' original.Height' GraphicsUnit.Pixel' attributes); " is 147.
Long Statement,GMap.NET.WindowsForms,GMapMarker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapMarker.cs,DrawImageUnscaled,The length of the statement  "         g.DrawImage(inBmp' new Rectangle(x' y' inBmp.Width' inBmp.Height)' 0' 0' inBmp.Width' inBmp.Height' GraphicsUnit.Pixel' attr);" is 126.
Long Statement,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,The length of the statement  "                  //if(m.IsVisible && (m.DisableRegionCheck || Control.Core.currentRegion.Contains(m.LocalPosition.X' m.LocalPosition.Y))) " is 120.
Long Statement,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,The length of the statement  "                     if(!string.IsNullOrEmpty(m.ToolTipText) && (m.ToolTipMode == MarkerTooltipMode.Always || (m.ToolTipMode == MarkerTooltipMode.OnMouseOver && m.IsMouseOver))) " is 156.
Long Statement,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The length of the statement  "                           g.DrawLine(Stroke' midxstart' midystart' midxstart + length * (float)Math.Cos(leftangle)' midystart + length * (float)Math.Sin(leftangle)); " is 139.
Long Statement,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The length of the statement  "                           g.DrawLine(Stroke' midxstart' midystart' midxstart + length * (float)Math.Cos(rightangle)' midystart + length * (float)Math.Sin(rightangle)); " is 141.
Long Statement,GMap.NET.WindowsForms,GMapToolTip,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapToolTip.cs,OnRender,The length of the statement  "         System.Drawing.Rectangle rect = new System.Drawing.Rectangle(Marker.ToolTipPosition.X' Marker.ToolTipPosition.Y - st.Height' st.Width + TextPadding.Width' st.Height + TextPadding.Height); " is 187.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "                            "HTTP/1.1 200 OK\r\nServer: here\r\nKeep-Alive: timeout=15' max=100\r\nConnection: Keep-Alive\r\nCache-Control: no-cache\r\nContent-Type: application/vnd.google-earth.kml+xml\r\nX-Pad: avoid browser bug\r\nContent-Length: " + " is 225.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "<kml xmlns=""http://www.opengis.net/kml/2.2"" xmlns:gx=""http://www.google.com/kml/ext/2.2"" xmlns:kml=""http://www.opengis.net/kml/2.2"" xmlns:atom=""http://www.w3.org/2005/Atom""> " is 181.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "                        string header = "HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\nContent-Length: " + file.Length + "\r\n\r\n"; " is 129.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        GET /mavlink/ATTITUDE+VFR_HUD+NAV_CONTROLLER_OUTPUT+META_WAYPOINT+GPS_RAW_INT+HEARTBEAT+META_LINKQUALITY+GPS_STATUS+STATUSTEXT+SYS_STATUS?_=1355828718540 HTTP/1.1 " is 162.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML' like Gecko) Chrome/23.0.1271.97 Safari/537.11 " is 120.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "VFR_HUD": {"msg": {"throttle": 0' "groundspeed": 0.0' "airspeed": 0.0' "climb": 0.0' "mavpackettype": "VFR_HUD"' "alt": -0.47999998927116394' "heading": 108}' "index": 687' "time_usec": 0}' " is 190.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "STATUSTEXT": {"msg": {"mavpackettype": "STATUSTEXT"' "severity": 1' "text": "Initialising APM..."}' "index": 2' "time_usec": 0}'  " is 129.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "SYS_STATUS": {"msg": {"onboard_control_sensors_present": 4294966287' "load": 0' "battery_remaining": -1' "errors_count4": 0' "drop_rate_comm": 0' "errors_count2": 0' "errors_count3": 0' "errors_comm": 0' "current_battery": -1' "errors_count1": 0' "onboard_control_sensors_health": 4294966287' "mavpackettype": "SYS_STATUS"' "onboard_control_sensors_enabled": 4294945807' "voltage_battery": 10080}' "index": 693' "time_usec": 0}'  " is 429.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "META_LINKQUALITY": {"msg": {"master_in": 11110' "mav_loss": 0' "mavpackettype": "META_LINKQUALITY"' "master_out": 194' "packet_loss": 0.0}' "index": 194' "time_usec": 0}' " is 171.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "ATTITUDE": {"msg": {"pitchspeed": -0.000976863200776279' "yaw": 1.8878594636917114' "rollspeed": -0.0030046366155147552' "time_boot_ms": 194676' "pitch": -0.09986469894647598' "mavpackettype": "ATTITUDE"' "yawspeed": -0.0015030358918011189' "roll": -0.029391441494226456}' "index": 687' "time_usec": 0}'  " is 304.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "GPS_RAW_INT": {"msg": {"fix_type": 1' "cog": 0' "epv": 65535' "lon": 0' "time_usec": 0' "eph": 9999' "satellites_visible": 0' "lat": 0' "mavpackettype": "GPS_RAW_INT"' "alt": 137000' "vel": 0}' "index": 687' "time_usec": 0}'  " is 225.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "HEARTBEAT": {"msg": {"custom_mode": 0' "system_status": 4' "base_mode": 81' "autopilot": 3' "mavpackettype": "HEARTBEAT"' "type": 2' "mavlink_version": 3}' "index": 190' "time_usec": 0}' " is 187.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "GPS_STATUS": {"msg": {"satellite_snr": ""' "satellite_azimuth": ""' "satellite_prn": ""' "satellite_elevation": ""' "satellites_visible": 0' "satellite_used": ""' "mavpackettype": "GPS_STATUS"}' "index": 2' "time_usec": 0}'  " is 224.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "        "NAV_CONTROLLER_OUTPUT": {"msg": {"wp_dist": 0' "nav_pitch": 0.0' "target_bearing": 0' "nav_roll": 0.0' "aspd_error": 0.0' "alt_error": 0.0' "mavpackettype": "NAV_CONTROLLER_OUTPUT"' "xtrack_error": 0.0' "nav_bearing": 0}' "index": 687' "time_usec": 0}} " is 253.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "                                header += "Connection: keep-alive\r\nLast-Modified: " + filetime + "\r\nContent-Length: " + fileinfo.Length + "\r\n\r\n"; " is 121.
Long Statement,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The length of the statement  "                            string header = "HTTP/1.1 404 not found\r\nConnection: Keep-Alive\r\nContent-Length: 0\r\nContent -Type: text/plain\r\n\r\n"; " is 125.
Long Statement,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The length of the statement  "                                MainV2.speechEngine.SpeakAsync(ArduPilot.Common.speechConversion(comPort.MAV' "" + Settings.Instance["speechbattery"])); " is 120.
Long Statement,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,addpolygonmarker,The length of the statement  "                //MissionPlanner.GMapMarkerRectWPRad mBorders = new MissionPlanner.GMapMarkerRectWPRad(point' (int)float.Parse(TXT_WPRad.Text)' MainMap); " is 137.
Complex Conditional,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The conditional expression  "MainV2.comPort.MAV.param.ContainsKey("MNT_STAB_PAN") &&                                      // (float)MainV2.comPort.MAV.param["MNT_STAB_PAN"] == 1 &&                                      ((float) MainV2.comPort.MAV.param["MNT_STAB_TILT"] == 1 &&                                       (float) MainV2.comPort.MAV.param["MNT_STAB_ROLL"] == 0) ||                                      (float) MainV2.comPort.MAV.param["MNT_TYPE"] == 4"  is complex.
Complex Conditional,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The conditional expression  "route.Points.Count == 0 || route.Points[route.Points.Count - 1].Lat != 0 &&                                  (mapupdate.AddSeconds(3) < DateTime.Now) && CHK_autopan.IsToggled"  is complex.
Complex Conditional,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The conditional expression  "p.X < screenRect.Left || p.X > screenRect.Right ||                      p.Y < screenRect.Top || p.Y > screenRect.Bottom"  is complex.
Complex Conditional,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The conditional expression  "elevationoverlay.Markers.Count == 0 || center != prev_position || alt != prev_alt ||                              height != prev_height || width != prev_width ||                              zoom != prev_zoom"  is complex.
Complex Conditional,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The conditional expression  "prev_home != HomeLocation || need_rf_redraw ||                              prev_range != Settings.Instance.GetFloat("Propagation_Range") || prev_alt2 != alt"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,GetRectOfAllMarkers,The conditional expression  "left != double.MaxValue && right != double.MinValue && top != double.MinValue && bottom != double.MaxValue"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,GetRectOfAllRoutes,The conditional expression  "left != double.MaxValue && right != double.MinValue && top != double.MinValue && bottom != double.MaxValue"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseClick,The conditional expression  "(MobileMode && m.LocalArea.Contains(e.X' e.Y)) || (!MobileMode && m.LocalAreaInControlSpace.Contains(e.X' e.Y))"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseMove,The conditional expression  "isSelected && !selectionStart.IsEmpty && (Form.ModifierKeys == Keys.Alt || Form.ModifierKeys == Keys.Shift || DisableAltForSelection)"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseMove,The conditional expression  "(MobileMode && m.LocalArea.Contains(e.X' e.Y)) || (!MobileMode && m.LocalAreaInControlSpace.Contains(e.X' e.Y))"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseWheel,The conditional expression  "mouseIn && (!IsMouseOverMarker || IgnoreMarkerOnMouseWheel) && !Core.IsDragging"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,The conditional expression  "r.IsInside(Control.Position) ||                           viewarea.Contains(r.Points[0]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.2)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.4)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.6)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.8)])"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,The conditional expression  "!string.IsNullOrEmpty(m.ToolTipText) && (m.ToolTipMode == MarkerTooltipMode.Always || (m.ToolTipMode == MarkerTooltipMode.OnMouseOver && m.IsMouseOver))"  is complex.
Complex Conditional,GMap.NET.WindowsForms,GMapPolygon,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapPolygon.cs,IsInside,The conditional expression  "p1.Lat < p.Lat && p2.Lat >= p.Lat || p2.Lat < p.Lat && p1.Lat >= p.Lat"  is complex.
Complex Conditional,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The conditional expression  "speechEnable && speechEngine != null && (DateTime.Now - speechcustomtime).TotalSeconds > 30 &&                          (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)"  is complex.
Complex Conditional,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The conditional expression  "Settings.Instance.GetBoolean("speechbatteryenabled") == true &&                                   (MainV2.comPort.MAV.cs.battery_remaining) < warnpercent &&                                   MainV2.comPort.MAV.cs.battery_voltage >= 5.0 &&                                   MainV2.comPort.MAV.cs.battery_remaining != 0.0"  is complex.
Complex Conditional,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The conditional expression  "speechEnable && speechEngine != null && (DateTime.Now - speechlowspeedtime).TotalSeconds > 10 &&                          (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)"  is complex.
Complex Conditional,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The conditional expression  "speechEnable && speechEngine != null &&                          (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)"  is complex.
Complex Conditional,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The conditional expression  "Settings.Instance.GetBoolean("speechaltenabled") == true && MainV2.comPort.MAV.cs.alt != 0.00 &&                                  (MainV2.comPort.MAV.cs.alt <= warnalt) && MainV2.comPort.MAV.cs.armed"  is complex.
Complex Conditional,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The conditional expression  "(DateTime.Now - MainV2.comPort.MAV.lastvalidpacket).TotalSeconds > 10                          && (DateTime.Now - connecttime).TotalSeconds > 30                          && (DateTime.Now - nodatawarning).TotalSeconds > 5                          && (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)                          && MainV2.comPort.MAV.cs.armed"  is complex.
Complex Conditional,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The conditional expression  "!port.giveComport && !MAV.cs.armed && (DateTime.Now.Second % 20) == 0 && MAV.cs.version < new Version(0' 1)"  is complex.
Complex Conditional,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The conditional expression  "port.BaseStream.IsOpen && port.BaseStream.BytesToRead > minbytes &&                                 port.giveComport == false && serialThread && startread.AddSeconds(1) > DateTime.Now"  is complex.
Complex Conditional,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,CreateOverlay,The conditional expression  "command < (ushort)MAVLink.MAV_CMD.LAST &&                      command != (ushort)MAVLink.MAV_CMD.TAKEOFF && // doesnt have a position                      command != (ushort)MAVLink.MAV_CMD.VTOL_TAKEOFF && // doesnt have a position                      command != (ushort)MAVLink.MAV_CMD.RETURN_TO_LAUNCH &&                      command != (ushort)MAVLink.MAV_CMD.CONTINUE_AND_CHANGE_ALT &&                      command != (ushort)MAVLink.MAV_CMD.DELAY &&                      command != (ushort)MAVLink.MAV_CMD.GUIDED_ENABLE                      || command == (ushort)MAVLink.MAV_CMD.DO_SET_ROI"  is complex.
Virtual Method Call from Constructor,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,MySKCanvasView,The constructor "MySKCanvasView" calls a virtual method "OnLoad".
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,Activate,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,addpolygonmarker,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,addpolygonmarker,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,addpolygonmarkerred,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,BUT_loadtelem_Click,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,gMapControl1_MouseLeave,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,gMapControl1_OnMapZoomChanged,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,tracklog_Scroll,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,TRK_zoom_Scroll,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updateLogPlayPosition,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updateMapPosition,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updateMapZoom,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updatePlayPauseButton,The method has an empty catch block.
Empty Catch Block,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updatePlayPauseButton,The method has an empty catch block.
Empty Catch Block,Xamarin,MainPage,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\MainPage.xaml.cs,ListView_ItemSelected,The method has an empty catch block.
Empty Catch Block,Xamarin,MainPage,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\MainPage.xaml.cs,ListView_ItemSelected,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnResize,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnResize,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnResize,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The method has an empty catch block.
Empty Catch Block,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,MySKGLView_SizeChanged,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerADSBPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerADSBPlane.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,MyImageCache,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\MyImageCache.cs,DeleteOlderThan,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,MyImageCache,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\MyImageCache.cs,DeleteOlderThan,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The method has an empty catch block.
Empty Catch Block,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,DownloadAndUpload,The method has an empty catch block.
Empty Catch Block,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,UpdatePolygonLocalPosition,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The method has an empty catch block.
Empty Catch Block,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,addpolygonmarker,The method has an empty catch block.
Empty Catch Block,MissionPlanner.test,FirmwareSelection,D:\research\architectureSmells\repos\diydrones_MissionPlanner\test\FirmwareSelection.xaml.cs,PopulatePicker,The method has an empty catch block.
Magic Number,Xamarin,App,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\App.xaml.cs,OnStart,The following statement contains a magic number: Task.Run(async () =>              {                  try                  {                      var client = new UdpClient(14551' AddressFamily.InterNetwork);                      client.BeginReceive(clientdata' client);                  }                  catch (Exception ex)                  {                      Log.Warning(""' ex.ToString());                  }              });
Magic Number,Xamarin,App,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\App.xaml.cs,OnStart,The following statement contains a magic number: Task.Run(async () =>              {                  try                  {                      var client = new UdpClient(14550' AddressFamily.InterNetwork);                      client.BeginReceive(clientdata' client);                  }                  catch (Exception ex)                  {                      Log.Warning(""' ex.ToString());                  }              });
Magic Number,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The following statement contains a magic number: (MAV.sysid >= 1) && (MAV.sysid <= 6)
Magic Number,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The following statement contains a magic number: which = MAV.sysid - 11;
Magic Number,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The following statement contains a magic number: (MAV.sysid >= 11) && (MAV.sysid <= 16)
Magic Number,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The following statement contains a magic number: (MAV.sysid >= 11) && (MAV.sysid <= 16)
Magic Number,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The following statement contains a magic number: which = MAV.sysid - 101;
Magic Number,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The following statement contains a magic number: (MAV.sysid >= 101) && (MAV.sysid <= 106)
Magic Number,Xamarin,Common,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\shim.cs,getMAVMarker,The following statement contains a magic number: (MAV.sysid >= 101) && (MAV.sysid <= 106)
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,FlightData,The following statement contains a magic number: gMapControl1.LevelsKeepInMemmory = 10;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,FlightData,The following statement contains a magic number: gMapControl1.MaxZoom = 24;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,FlightData,The following statement contains a magic number: gMapControl1.Zoom = 3;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,FlightData,The following statement contains a magic number: gMapControl1.LevelsKeepInMemmory = 5;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,FlightData,The following statement contains a magic number: TRK_zoom.Maximum = 24;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,FlightData,The following statement contains a magic number: TRK_zoom.Value = 3;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,Activate,The following statement contains a magic number: TRK_zoom.Value = 3;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,LoadLogFile,The following statement contains a magic number: tracklog.Maximum = 100;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,FlightData_Load,The following statement contains a magic number: TRK_zoom.Maximum = 24;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: updatescreen.AddMilliseconds(300) < DateTime.Now
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: act > 9999 || act < 0
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: LogPlayBackSpeed = 0.01;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: ts = Math.Min((act / LogPlayBackSpeed)' 1000);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: LogPlayBackSpeed >= 4 && MainV2.speechEnable
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: ts = 1000;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: Math.Abs(ts) > 1000
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: ts > 0 && ts < 1000
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: int numTrackLength = Settings.Instance.GetInt32("NUM_tracklength"' 200);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: waypoints.AddSeconds(5) < DateTime.Now
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: MainV2.comPort.MAV.param.ContainsKey("MNT_STAB_PAN") &&                                      // (float)MainV2.comPort.MAV.param["MNT_STAB_PAN"] == 1 &&                                      ((float) MainV2.comPort.MAV.param["MNT_STAB_TILT"] == 1 &&                                       (float) MainV2.comPort.MAV.param["MNT_STAB_ROLL"] == 0) ||                                      (float) MainV2.comPort.MAV.param["MNT_TYPE"] == 4
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: min_interval = MainV2.comPort.MAV.param["CAM_MIN_INTERVAL"].Value / 1000.0;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: var timesincelastshot = (mark.time_usec / 1000.0) / 1000.0 - oldtime;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: var timesincelastshot = (mark.time_usec / 1000.0) / 1000.0 - oldtime;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: oldtime = (mark.time_usec / 1000.0) / 1000.0;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: oldtime = (mark.time_usec / 1000.0) / 1000.0;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: Math.Abs(marker.Roll) < 25
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: a < (camcount - 4)
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: ((DateTime) plla.Time) > DateTime.Now.AddSeconds(-30)
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: addpolygonmarker("Guided Mode"' MainV2.comPort.MAV.GuidedMode.y / 1e7'                                      MainV2.comPort.MAV.GuidedMode.x / 1e7' (int) MainV2.comPort.MAV.GuidedMode.z'                                      Color.Blue'                                      routes);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: addpolygonmarker("Guided Mode"' MainV2.comPort.MAV.GuidedMode.y / 1e7'                                      MainV2.comPort.MAV.GuidedMode.x / 1e7' (int) MainV2.comPort.MAV.GuidedMode.z'                                      Color.Blue'                                      routes);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: route.Points.Count == 0 || route.Points[route.Points.Count - 1].Lat != 0 &&                                  (mapupdate.AddSeconds(3) < DateTime.Now) && CHK_autopan.IsToggled
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: updateMapZoom(17);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: route.Points.Count == 1 && gMapControl1.Zoom == 3
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following statement contains a magic number: tracklast.AddSeconds(Settings.Instance.GetDouble("FD_MapUpdateDelay"' 1.2)) < DateTime.Now
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,RegeneratePolygon,The following statement contains a magic number: polygonPoints.Count < 2
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,RegeneratePolygon,The following statement contains a magic number: homeroute.Stroke = new Pen(Color.Yellow' 2);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,RegeneratePolygon,The following statement contains a magic number: wppath.Stroke = new Pen(Color.Yellow' 4);
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,setMapBearing,The following statement contains a magic number: Invoke((Action) delegate { gMapControl1.Bearing = (int) ((MainV2.comPort.MAV.cs.yaw + 360) % 360); });
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,setMapBearing,The following statement contains a magic number: Invoke((Action) delegate { gMapControl1.Bearing = (int) ((MainV2.comPort.MAV.cs.yaw + 360) % 360); });
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,tfr_GotTFRs,The following statement contains a magic number: Invoke((Action) delegate              {                  foreach (var item in tfr.tfrs)                  {                      List<List<PointLatLng>> points = item.GetPaths();                        foreach (var list in points)                      {                          GMapPolygon poly = new GMapPolygon(list' item.NAME);                            poly.Fill = new SolidBrush(Color.FromArgb(30' Color.Blue));                            tfrpolygons.Polygons.Add(poly);                      }                  }                    tfrpolygons.IsVisibile = MainV2.ShowTFR;              });
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,tracklog_Scroll,The following statement contains a magic number: MainV2.comPort.logplaybackfile.BaseStream.Position =                          (long) (MainV2.comPort.logplaybackfile.BaseStream.Length * (tracklog.Value / 100.0));
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,TRK_zoom_Scroll,The following statement contains a magic number: gMapControl1.Zoom = TRK_zoom.Value - .1;
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updateBindingSource,The following statement contains a magic number: lastscreenupdate < DateTime.Now.AddSeconds(-5)
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updateBindingSource,The following statement contains a magic number: lastscreenupdate.AddMilliseconds(40) < DateTime.Now
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updateLogPlayPosition,The following statement contains a magic number: BeginInvoke((Action) delegate              {                  try                  {                      if (updatetracklog && tracklog.IsVisible)                      {                          // prevent event fire                          tracklog.ValueChanged -= tracklog_Scroll;                          tracklog.Value = (int) (MainV2.comPort.logplaybackfile.BaseStream.Position /                                                  (double) MainV2.comPort.logplaybackfile.BaseStream.Length * 100);                          tracklog.ValueChanged += tracklog_Scroll;                      }                        if (lbl_logpercent.IsVisible)                          lbl_logpercent.Text =                              (MainV2.comPort.logplaybackfile.BaseStream.Position /                               (double) MainV2.comPort.logplaybackfile.BaseStream.Length).ToString("0.00%");                        if (lbl_playbackspeed.IsVisible)                          lbl_playbackspeed.Text = "x " + LogPlayBackSpeed;                  }                  catch                  {                  }              });
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updateMapPosition,The following statement contains a magic number: Invoke((Action) delegate              {                  try                  {                      if (lastmapposchange.Second != DateTime.Now.Second)                      {                          if (Math.Abs(currentloc.Lat - gMapControl1.Position.Lat) > 0.0001 ||                              Math.Abs(currentloc.Lng - gMapControl1.Position.Lng) > 0.0001)                          {                              gMapControl1.Position = currentloc;                          }                            lastmapposchange = DateTime.Now;                      }                        //hud1.Refresh();                  }                  catch                  {                  }              });
Magic Number,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,updateMapPosition,The following statement contains a magic number: Invoke((Action) delegate              {                  try                  {                      if (lastmapposchange.Second != DateTime.Now.Second)                      {                          if (Math.Abs(currentloc.Lat - gMapControl1.Position.Lat) > 0.0001 ||                              Math.Abs(currentloc.Lng - gMapControl1.Position.Lng) > 0.0001)                          {                              gMapControl1.Position = currentloc;                          }                            lastmapposchange = DateTime.Now;                      }                        //hud1.Refresh();                  }                  catch                  {                  }              });
Magic Number,Xamarin,InputBox,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,InputBox1,The following statement contains a magic number: var btnOk = new Button              {                  Text = "Ok"'                  WidthRequest = 100'                  //BackgroundColor = Color.FromRgb(0.8' 0.8' 0.8)'              };
Magic Number,Xamarin,InputBox,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,InputBox1,The following statement contains a magic number: var btnCancel = new Button              {                  Text = "Cancel"'                  WidthRequest = 100'                  //BackgroundColor = Color.FromRgb(0.8' 0.8' 0.8)              };
Magic Number,Xamarin,InputBox,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,InputBox1,The following statement contains a magic number: var layout = new StackLayout              {                  Padding = new Thickness(0' 40' 0' 0)'                  VerticalOptions = LayoutOptions.StartAndExpand'                  HorizontalOptions = LayoutOptions.CenterAndExpand'                  Orientation = StackOrientation.Vertical'                  Children = {lblTitle' lblMessage' txtInput' slButtons}'              };
Magic Number,Xamarin,MasterDetailPage1MasterViewModel,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\MasterDetailPage1Master.xaml.cs,MasterDetailPage1MasterViewModel,The following statement contains a magic number: MenuItems = new ObservableCollection<MasterDetailPage1MenuItem>(new[]                  {                      new MasterDetailPage1MenuItem { Id = 0' Title = "FlightData"' TargetType = typeof(FlightData) }'                      new MasterDetailPage1MenuItem { Id = 1' Title = "FlightPlanner"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 2' Title = "Initial Setup"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 3' Title = "Configuration"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 4' Title = "Simulation"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 4' Title = "Firmware"' TargetType = typeof(Firmware)  }'                  });
Magic Number,Xamarin,MasterDetailPage1MasterViewModel,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\MasterDetailPage1Master.xaml.cs,MasterDetailPage1MasterViewModel,The following statement contains a magic number: MenuItems = new ObservableCollection<MasterDetailPage1MenuItem>(new[]                  {                      new MasterDetailPage1MenuItem { Id = 0' Title = "FlightData"' TargetType = typeof(FlightData) }'                      new MasterDetailPage1MenuItem { Id = 1' Title = "FlightPlanner"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 2' Title = "Initial Setup"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 3' Title = "Configuration"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 4' Title = "Simulation"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 4' Title = "Firmware"' TargetType = typeof(Firmware)  }'                  });
Magic Number,Xamarin,MasterDetailPage1MasterViewModel,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\MasterDetailPage1Master.xaml.cs,MasterDetailPage1MasterViewModel,The following statement contains a magic number: MenuItems = new ObservableCollection<MasterDetailPage1MenuItem>(new[]                  {                      new MasterDetailPage1MenuItem { Id = 0' Title = "FlightData"' TargetType = typeof(FlightData) }'                      new MasterDetailPage1MenuItem { Id = 1' Title = "FlightPlanner"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 2' Title = "Initial Setup"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 3' Title = "Configuration"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 4' Title = "Simulation"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 4' Title = "Firmware"' TargetType = typeof(Firmware)  }'                  });
Magic Number,Xamarin,MasterDetailPage1MasterViewModel,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\MasterDetailPage1Master.xaml.cs,MasterDetailPage1MasterViewModel,The following statement contains a magic number: MenuItems = new ObservableCollection<MasterDetailPage1MenuItem>(new[]                  {                      new MasterDetailPage1MenuItem { Id = 0' Title = "FlightData"' TargetType = typeof(FlightData) }'                      new MasterDetailPage1MenuItem { Id = 1' Title = "FlightPlanner"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 2' Title = "Initial Setup"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 3' Title = "Configuration"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 4' Title = "Simulation"' TargetType = typeof(MasterDetailPage1Detail)  }'                      new MasterDetailPage1MenuItem { Id = 4' Title = "Firmware"' TargetType = typeof(Firmware)  }'                  });
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,FindFontBounds,The following statement contains a magic number: b = new Bitmap(5' 5);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,FindFontBounds,The following statement contains a magic number: b = new Bitmap(5' 5);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: (Width < 10) || (Height < 10)
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: (Width < 10) || (Height < 10)
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (BackgroundImageLayout)                          {                              case ImageLayout.Center:                                  ggr.DrawImageUnscaled(BackgroundImage' Width/2 - BackgroundImage.Width/2'                                      Height/2 - BackgroundImage.Height/2);                                  break;                              case ImageLayout.None:                                  ggr.DrawImageUnscaled(BackgroundImage' 0' 0);                                  break;                              case ImageLayout.Stretch:                                  ggr.DrawImage(BackgroundImage' 0' 0' Width' Height);                                  break;                              case ImageLayout.Tile:                                  Int32 pixelOffsetX = 0;                                  Int32 pixelOffsetY = 0;                                  while (pixelOffsetX < Width)                                  {                                      pixelOffsetY = 0;                                      while (pixelOffsetY < Height)                                      {                                          ggr.DrawImageUnscaled(BackgroundImage' pixelOffsetX' pixelOffsetY);                                          pixelOffsetY += BackgroundImage.Height;                                      }                                      pixelOffsetX += BackgroundImage.Width;                                  }                                  break;                              case ImageLayout.Zoom:                                  if ((BackgroundImage.Width/Width) < (BackgroundImage.Height/Height))                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Height' Height);                                  }                                  else                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Width' Width);                                  }                                  break;                          }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (BackgroundImageLayout)                          {                              case ImageLayout.Center:                                  ggr.DrawImageUnscaled(BackgroundImage' Width/2 - BackgroundImage.Width/2'                                      Height/2 - BackgroundImage.Height/2);                                  break;                              case ImageLayout.None:                                  ggr.DrawImageUnscaled(BackgroundImage' 0' 0);                                  break;                              case ImageLayout.Stretch:                                  ggr.DrawImage(BackgroundImage' 0' 0' Width' Height);                                  break;                              case ImageLayout.Tile:                                  Int32 pixelOffsetX = 0;                                  Int32 pixelOffsetY = 0;                                  while (pixelOffsetX < Width)                                  {                                      pixelOffsetY = 0;                                      while (pixelOffsetY < Height)                                      {                                          ggr.DrawImageUnscaled(BackgroundImage' pixelOffsetX' pixelOffsetY);                                          pixelOffsetY += BackgroundImage.Height;                                      }                                      pixelOffsetX += BackgroundImage.Width;                                  }                                  break;                              case ImageLayout.Zoom:                                  if ((BackgroundImage.Width/Width) < (BackgroundImage.Height/Height))                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Height' Height);                                  }                                  else                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Width' Width);                                  }                                  break;                          }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (BackgroundImageLayout)                          {                              case ImageLayout.Center:                                  ggr.DrawImageUnscaled(BackgroundImage' Width/2 - BackgroundImage.Width/2'                                      Height/2 - BackgroundImage.Height/2);                                  break;                              case ImageLayout.None:                                  ggr.DrawImageUnscaled(BackgroundImage' 0' 0);                                  break;                              case ImageLayout.Stretch:                                  ggr.DrawImage(BackgroundImage' 0' 0' Width' Height);                                  break;                              case ImageLayout.Tile:                                  Int32 pixelOffsetX = 0;                                  Int32 pixelOffsetY = 0;                                  while (pixelOffsetX < Width)                                  {                                      pixelOffsetY = 0;                                      while (pixelOffsetY < Height)                                      {                                          ggr.DrawImageUnscaled(BackgroundImage' pixelOffsetX' pixelOffsetY);                                          pixelOffsetY += BackgroundImage.Height;                                      }                                      pixelOffsetX += BackgroundImage.Width;                                  }                                  break;                              case ImageLayout.Zoom:                                  if ((BackgroundImage.Width/Width) < (BackgroundImage.Height/Height))                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Height' Height);                                  }                                  else                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Width' Width);                                  }                                  break;                          }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (BackgroundImageLayout)                          {                              case ImageLayout.Center:                                  ggr.DrawImageUnscaled(BackgroundImage' Width/2 - BackgroundImage.Width/2'                                      Height/2 - BackgroundImage.Height/2);                                  break;                              case ImageLayout.None:                                  ggr.DrawImageUnscaled(BackgroundImage' 0' 0);                                  break;                              case ImageLayout.Stretch:                                  ggr.DrawImage(BackgroundImage' 0' 0' Width' Height);                                  break;                              case ImageLayout.Tile:                                  Int32 pixelOffsetX = 0;                                  Int32 pixelOffsetY = 0;                                  while (pixelOffsetX < Width)                                  {                                      pixelOffsetY = 0;                                      while (pixelOffsetY < Height)                                      {                                          ggr.DrawImageUnscaled(BackgroundImage' pixelOffsetX' pixelOffsetY);                                          pixelOffsetY += BackgroundImage.Height;                                      }                                      pixelOffsetX += BackgroundImage.Width;                                  }                                  break;                              case ImageLayout.Zoom:                                  if ((BackgroundImage.Width/Width) < (BackgroundImage.Height/Height))                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Height' Height);                                  }                                  else                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Width' Width);                                  }                                  break;                          }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddPie(                                  new Rectangle(m_Center.X - m_RangeOuterRadius[counter]'                                      m_Center.Y - m_RangeOuterRadius[counter]' 2*m_RangeOuterRadius[counter]'                                      2*m_RangeOuterRadius[counter])' rangeStartAngle' rangeSweepAngle);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddPie(                                  new Rectangle(m_Center.X - m_RangeOuterRadius[counter]'                                      m_Center.Y - m_RangeOuterRadius[counter]' 2*m_RangeOuterRadius[counter]'                                      2*m_RangeOuterRadius[counter])' rangeStartAngle' rangeSweepAngle);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddPie(                                  new Rectangle(m_Center.X - m_RangeInnerRadius[counter]'                                      m_Center.Y - m_RangeInnerRadius[counter]' 2*m_RangeInnerRadius[counter]'                                      2*m_RangeInnerRadius[counter])' rangeStartAngle' rangeSweepAngle);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddPie(                                  new Rectangle(m_Center.X - m_RangeInnerRadius[counter]'                                      m_Center.Y - m_RangeInnerRadius[counter]' 2*m_RangeInnerRadius[counter]'                                      2*m_RangeInnerRadius[counter])' rangeStartAngle' rangeSweepAngle);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.FillPie(new SolidBrush(m_RangeColor[counter])'                                  new Rectangle(m_Center.X - m_RangeOuterRadius[counter]'                                      m_Center.Y - m_RangeOuterRadius[counter]' 2*m_RangeOuterRadius[counter]'                                      2*m_RangeOuterRadius[counter])' rangeStartAngle' rangeSweepAngle);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.FillPie(new SolidBrush(m_RangeColor[counter])'                                  new Rectangle(m_Center.X - m_RangeOuterRadius[counter]'                                      m_Center.Y - m_RangeOuterRadius[counter]' 2*m_RangeOuterRadius[counter]'                                      2*m_RangeOuterRadius[counter])' rangeStartAngle' rangeSweepAngle);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawArc(new Pen(m_BaseArcColor' m_BaseArcWidth)'                              new Rectangle(m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2*m_BaseArcRadius'                                  2*m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawArc(new Pen(m_BaseArcColor' m_BaseArcWidth)'                              new Rectangle(m_Center.X - m_BaseArcRadius' m_Center.Y - m_BaseArcRadius' 2*m_BaseArcRadius'                                  2*m_BaseArcRadius)' m_BaseArcStart' m_BaseArcSweep);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMajorOuterRadius'                              m_Center.Y - m_ScaleLinesMajorOuterRadius' 2*m_ScaleLinesMajorOuterRadius'                              2*m_ScaleLinesMajorOuterRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMajorOuterRadius'                              m_Center.Y - m_ScaleLinesMajorOuterRadius' 2*m_ScaleLinesMajorOuterRadius'                              2*m_ScaleLinesMajorOuterRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMajorInnerRadius'                              m_Center.Y - m_ScaleLinesMajorInnerRadius' 2*m_ScaleLinesMajorInnerRadius'                              2*m_ScaleLinesMajorInnerRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMajorInnerRadius'                              m_Center.Y - m_ScaleLinesMajorInnerRadius' 2*m_ScaleLinesMajorInnerRadius'                              2*m_ScaleLinesMajorInnerRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine(new Pen(m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)'                              (Single) (Center.X)'                              (Single) (Center.Y)'                              (Single)                                  (Center.X +                                   2*m_ScaleLinesMajorOuterRadius*                                   Math.Cos((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0))'                              (Single)                                  (Center.Y +                                   2*m_ScaleLinesMajorOuterRadius*                                   Math.Sin((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0)));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine(new Pen(m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)'                              (Single) (Center.X)'                              (Single) (Center.Y)'                              (Single)                                  (Center.X +                                   2*m_ScaleLinesMajorOuterRadius*                                   Math.Cos((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0))'                              (Single)                                  (Center.Y +                                   2*m_ScaleLinesMajorOuterRadius*                                   Math.Sin((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0)));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine(new Pen(m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)'                              (Single) (Center.X)'                              (Single) (Center.Y)'                              (Single)                                  (Center.X +                                   2*m_ScaleLinesMajorOuterRadius*                                   Math.Cos((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0))'                              (Single)                                  (Center.Y +                                   2*m_ScaleLinesMajorOuterRadius*                                   Math.Sin((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0)));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine(new Pen(m_ScaleLinesMajorColor' m_ScaleLinesMajorWidth)'                              (Single) (Center.X)'                              (Single) (Center.Y)'                              (Single)                                  (Center.X +                                   2*m_ScaleLinesMajorOuterRadius*                                   Math.Cos((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0))'                              (Single)                                  (Center.Y +                                   2*m_ScaleLinesMajorOuterRadius*                                   Math.Sin((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0)));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMinorOuterRadius'                              m_Center.Y - m_ScaleLinesMinorOuterRadius' 2*m_ScaleLinesMinorOuterRadius'                              2*m_ScaleLinesMinorOuterRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMinorOuterRadius'                              m_Center.Y - m_ScaleLinesMinorOuterRadius' 2*m_ScaleLinesMinorOuterRadius'                              2*m_ScaleLinesMinorOuterRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMinorInnerRadius'                              m_Center.Y - m_ScaleLinesMinorInnerRadius' 2*m_ScaleLinesMinorInnerRadius'                              2*m_ScaleLinesMinorInnerRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMinorInnerRadius'                              m_Center.Y - m_ScaleLinesMinorInnerRadius' 2*m_ScaleLinesMinorInnerRadius'                              2*m_ScaleLinesMinorInnerRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesInterOuterRadius'                                          m_Center.Y - m_ScaleLinesInterOuterRadius' 2*m_ScaleLinesInterOuterRadius'                                          2*m_ScaleLinesInterOuterRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesInterOuterRadius'                                          m_Center.Y - m_ScaleLinesInterOuterRadius' 2*m_ScaleLinesInterOuterRadius'                                          2*m_ScaleLinesInterOuterRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesInterInnerRadius'                                          m_Center.Y - m_ScaleLinesInterInnerRadius' 2*m_ScaleLinesInterInnerRadius'                                          2*m_ScaleLinesInterInnerRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesInterInnerRadius'                                          m_Center.Y - m_ScaleLinesInterInnerRadius' 2*m_ScaleLinesInterInnerRadius'                                          2*m_ScaleLinesInterInnerRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine(new Pen(m_ScaleLinesInterColor' m_ScaleLinesInterWidth)'                                          (Single) (Center.X)'                                          (Single) (Center.Y)'                                          (Single)                                              (Center.X +                                               2*m_ScaleLinesInterOuterRadius*                                               Math.Cos((m_BaseArcStart +                                                         countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue) +                                                         counter2*m_BaseArcSweep/                                                         (((Single) ((m_MaxValue - m_MinValue)/m_ScaleLinesMajorStepValue))*                                                          (m_ScaleLinesMinorNumOf + 1)))*Math.PI/180.0))'                                          (Single)                                              (Center.Y +                                               2*m_ScaleLinesInterOuterRadius*                                               Math.Sin((m_BaseArcStart +                                                         countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue) +                                                         counter2*m_BaseArcSweep/                                                         (((Single) ((m_MaxValue - m_MinValue)/m_ScaleLinesMajorStepValue))*                                                          (m_ScaleLinesMinorNumOf + 1)))*Math.PI/180.0)));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine(new Pen(m_ScaleLinesInterColor' m_ScaleLinesInterWidth)'                                          (Single) (Center.X)'                                          (Single) (Center.Y)'                                          (Single)                                              (Center.X +                                               2*m_ScaleLinesInterOuterRadius*                                               Math.Cos((m_BaseArcStart +                                                         countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue) +                                                         counter2*m_BaseArcSweep/                                                         (((Single) ((m_MaxValue - m_MinValue)/m_ScaleLinesMajorStepValue))*                                                          (m_ScaleLinesMinorNumOf + 1)))*Math.PI/180.0))'                                          (Single)                                              (Center.Y +                                               2*m_ScaleLinesInterOuterRadius*                                               Math.Sin((m_BaseArcStart +                                                         countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue) +                                                         counter2*m_BaseArcSweep/                                                         (((Single) ((m_MaxValue - m_MinValue)/m_ScaleLinesMajorStepValue))*                                                          (m_ScaleLinesMinorNumOf + 1)))*Math.PI/180.0)));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine(new Pen(m_ScaleLinesInterColor' m_ScaleLinesInterWidth)'                                          (Single) (Center.X)'                                          (Single) (Center.Y)'                                          (Single)                                              (Center.X +                                               2*m_ScaleLinesInterOuterRadius*                                               Math.Cos((m_BaseArcStart +                                                         countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue) +                                                         counter2*m_BaseArcSweep/                                                         (((Single) ((m_MaxValue - m_MinValue)/m_ScaleLinesMajorStepValue))*                                                          (m_ScaleLinesMinorNumOf + 1)))*Math.PI/180.0))'                                          (Single)                                              (Center.Y +                                               2*m_ScaleLinesInterOuterRadius*                                               Math.Sin((m_BaseArcStart +                                                         countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue) +                                                         counter2*m_BaseArcSweep/                                                         (((Single) ((m_MaxValue - m_MinValue)/m_ScaleLinesMajorStepValue))*                                                          (m_ScaleLinesMinorNumOf + 1)))*Math.PI/180.0)));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawLine(new Pen(m_ScaleLinesInterColor' m_ScaleLinesInterWidth)'                                          (Single) (Center.X)'                                          (Single) (Center.Y)'                                          (Single)                                              (Center.X +                                               2*m_ScaleLinesInterOuterRadius*                                               Math.Cos((m_BaseArcStart +                                                         countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue) +                                                         counter2*m_BaseArcSweep/                                                         (((Single) ((m_MaxValue - m_MinValue)/m_ScaleLinesMajorStepValue))*                                                          (m_ScaleLinesMinorNumOf + 1)))*Math.PI/180.0))'                                          (Single)                                              (Center.Y +                                               2*m_ScaleLinesInterOuterRadius*                                               Math.Sin((m_BaseArcStart +                                                         countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue) +                                                         counter2*m_BaseArcSweep/                                                         (((Single) ((m_MaxValue - m_MinValue)/m_ScaleLinesMajorStepValue))*                                                          (m_ScaleLinesMinorNumOf + 1)))*Math.PI/180.0)));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMinorOuterRadius'                                          m_Center.Y - m_ScaleLinesMinorOuterRadius' 2*m_ScaleLinesMinorOuterRadius'                                          2*m_ScaleLinesMinorOuterRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMinorOuterRadius'                                          m_Center.Y - m_ScaleLinesMinorOuterRadius' 2*m_ScaleLinesMinorOuterRadius'                                          2*m_ScaleLinesMinorOuterRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMinorInnerRadius'                                          m_Center.Y - m_ScaleLinesMinorInnerRadius' 2*m_ScaleLinesMinorInnerRadius'                                          2*m_ScaleLinesMinorInnerRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: gp.AddEllipse(new Rectangle(m_Center.X - m_ScaleLinesMinorInnerRadius'                                          m_Center.Y - m_ScaleLinesMinorInnerRadius' 2*m_ScaleLinesMinorInnerRadius'                                          2*m_ScaleLinesMinorInnerRadius));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ((m_ScaleLinesMinorNumOf%2) == 1) &&                                      ((Int32) (m_ScaleLinesMinorNumOf/2) + 1 == counter2)
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ((m_ScaleLinesMinorNumOf%2) == 1) &&                                      ((Int32) (m_ScaleLinesMinorNumOf/2) + 1 == counter2)
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.RotateTransform(90.0F + m_BaseArcStart +                                                  countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue));
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.TranslateTransform(                              (Single)                                  (Center.X*scale +                                   m_ScaleNumbersRadius*scale*                                   Math.Cos((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0f))'                              (Single)                                  (Center.Y*scale +                                   m_ScaleNumbersRadius*scale*                                   Math.Sin((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0f))'                              MatrixOrder.Append);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.TranslateTransform(                              (Single)                                  (Center.X*scale +                                   m_ScaleNumbersRadius*scale*                                   Math.Cos((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0f))'                              (Single)                                  (Center.Y*scale +                                   m_ScaleNumbersRadius*scale*                                   Math.Sin((m_BaseArcStart + countValue*m_BaseArcSweep/(m_MaxValue - m_MinValue))*Math.PI/                                            180.0f))'                              MatrixOrder.Append);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawString(valueText' Font' new SolidBrush(m_ScaleNumbersColor)' -boundingBox.Width/2'                                  -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1)/2' StringFormat.GenericTypographic);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: ggr.DrawString(valueText' Font' new SolidBrush(m_ScaleNumbersColor)' -boundingBox.Width/2'                                  -fontBoundY1 - (fontBoundY2 - fontBoundY1 + 1)/2' StringFormat.GenericTypographic);
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: Single brushAngle = (Int32)(m_BaseArcStart + (m_value[m_NeedIdx] - m_MinValue) * m_BaseArcSweep / (m_MaxValue - m_MinValue)) % 360;
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: Double needleAngle = brushAngle * Math.PI / 180;
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following statement contains a magic number: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnMouseClick,The following statement contains a magic number: ekfhitzone.IntersectsWith(new Rectangle(e.X' e.Y' 5' 5))
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnMouseClick,The following statement contains a magic number: ekfhitzone.IntersectsWith(new Rectangle(e.X' e.Y' 5' 5))
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnMouseClick,The following statement contains a magic number: vibehitzone.IntersectsWith(new Rectangle(e.X' e.Y' 5' 5))
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnMouseClick,The following statement contains a magic number: vibehitzone.IntersectsWith(new Rectangle(e.X' e.Y' 5' 5))
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnMouseMove,The following statement contains a magic number: ekfhitzone.IntersectsWith(new Rectangle(e.X' e.Y' 5' 5))
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnMouseMove,The following statement contains a magic number: ekfhitzone.IntersectsWith(new Rectangle(e.X' e.Y' 5' 5))
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnPaint,The following statement contains a magic number: (DateTime.Now - starttime).TotalMilliseconds < 30 && (_bgimage == null)
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnPaint,The following statement contains a magic number: (huddrawtime / count) > 1000
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnResize,The following statement contains a magic number: int ht = (int)(this.Width / 1.777f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnResize,The following statement contains a magic number: ht >= this.Height + 5 || ht <= this.Height - 5
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,OnResize,The following statement contains a magic number: ht >= this.Height + 5 || ht <= this.Height - 5
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int fontsize = this.Height / 30;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int fontoffset = fontsize - 10;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float every5deg = -this.Height / 65;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int halfwidth = this.Width / 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int halfheight = this.Height / 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._blackPen.Width = 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._redPen.Width = 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF bg = new RectangleF(-halfwidth * 2' -halfheight * 2' this.Width * 2'                          halfheight * 2 + pitchoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF bg = new RectangleF(-halfwidth * 2' -halfheight * 2' this.Width * 2'                          halfheight * 2 + pitchoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF bg = new RectangleF(-halfwidth * 2' -halfheight * 2' this.Width * 2'                          halfheight * 2 + pitchoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF bg = new RectangleF(-halfwidth * 2' -halfheight * 2' this.Width * 2'                          halfheight * 2 + pitchoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: bg = new RectangleF(-halfwidth * 2' pitchoffset' this.Width * 2' halfheight * 2 - pitchoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: bg = new RectangleF(-halfwidth * 2' pitchoffset' this.Width * 2' halfheight * 2 - pitchoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: bg = new RectangleF(-halfwidth * 2' pitchoffset' this.Width * 2' halfheight * 2 - pitchoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' -halfwidth * 2' pitchoffset + 0' halfwidth * 2'                          pitchoffset + 0);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' -halfwidth * 2' pitchoffset + 0' halfwidth * 2'                          pitchoffset + 0);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.SetClip(new Rectangle(0' this.Height / 14' this.Width'                          this.Height - this.Height / 14));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.SetClip(new Rectangle(0' this.Height / 14' this.Width'                          this.Height - this.Height / 14));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int lengthshort = this.Width / 14;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int lengthlong = this.Width / 10;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 2 - lengthlong - halfwidth'                                          pitchoffset + a * every5deg' this.Width / 2 + lengthlong - halfwidth'                                          pitchoffset + a * every5deg);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 2 - lengthlong - halfwidth'                                          pitchoffset + a * every5deg' this.Width / 2 + lengthlong - halfwidth'                                          pitchoffset + a * every5deg);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(a.ToString()' font' fontsize + 2' _whiteBrush'                                      this.Width / 2 - lengthlong - 30 - halfwidth - (int)(fontoffset * 1.7)'                                      pitchoffset + a * every5deg - 8 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(a.ToString()' font' fontsize + 2' _whiteBrush'                                      this.Width / 2 - lengthlong - 30 - halfwidth - (int)(fontoffset * 1.7)'                                      pitchoffset + a * every5deg - 8 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(a.ToString()' font' fontsize + 2' _whiteBrush'                                      this.Width / 2 - lengthlong - 30 - halfwidth - (int)(fontoffset * 1.7)'                                      pitchoffset + a * every5deg - 8 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(a.ToString()' font' fontsize + 2' _whiteBrush'                                      this.Width / 2 - lengthlong - 30 - halfwidth - (int)(fontoffset * 1.7)'                                      pitchoffset + a * every5deg - 8 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(a.ToString()' font' fontsize + 2' _whiteBrush'                                      this.Width / 2 - lengthlong - 30 - halfwidth - (int)(fontoffset * 1.7)'                                      pitchoffset + a * every5deg - 8 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: a % 10 == 0
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: a >= _pitch - 29 && a <= _pitch + 20
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: a >= _pitch - 29 && a <= _pitch + 20
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: a <= 90
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: lengthlong = this.Height / 66;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int extra = (int)(this.Height / 15.0 * 4.9f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int extra = (int)(this.Height / 15.0 * 4.9f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int lengthlongex = lengthlong + 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Point[] pointlist = new Point[3];
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: pointlist[0] = new Point(0' -lengthlongex * 2 - extra);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: pointlist[2] = new Point(lengthlongex' -lengthlongex - extra);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._redPen.Width = 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._redPen.Width = 4;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Math.Abs(_roll) > 45
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._redPen.Width = 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int[] array = new int[] { -60' -45' -30' -20' -10' 0' 10' 20' 30' 45' 60 };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(String.Format("{0'2}"' Math.Abs(a))' font' fontsize' _whiteBrush'                              0 - 6 - fontoffset' -lengthlong * 8 - extra);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(String.Format("{0'2}"' Math.Abs(a))' font' fontsize' _whiteBrush'                              0 - 6 - fontoffset' -lengthlong * 8 - extra);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' 0' -lengthlong * 3 - extra' 0'                              -lengthlong * 3 - extra - lengthlong);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' 0' -lengthlong * 3 - extra' 0'                              -lengthlong * 3 - extra - lengthlong);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF arcrect = new RectangleF(-lengthlong * 3 - extra' -lengthlong * 3 - extra'                          (extra + lengthlong * 3) * 2f' (extra + lengthlong * 3) * 2f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF arcrect = new RectangleF(-lengthlong * 3 - extra' -lengthlong * 3 - extra'                          (extra + lengthlong * 3) * 2f' (extra + lengthlong * 3) * 2f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF arcrect = new RectangleF(-lengthlong * 3 - extra' -lengthlong * 3 - extra'                          (extra + lengthlong * 3) * 2f' (extra + lengthlong * 3) * 2f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF arcrect = new RectangleF(-lengthlong * 3 - extra' -lengthlong * 3 - extra'                          (extra + lengthlong * 3) * 2f' (extra + lengthlong * 3) * 2f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF arcrect = new RectangleF(-lengthlong * 3 - extra' -lengthlong * 3 - extra'                          (extra + lengthlong * 3) * 2f' (extra + lengthlong * 3) * 2f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF arcrect = new RectangleF(-lengthlong * 3 - extra' -lengthlong * 3 - extra'                          (extra + lengthlong * 3) * 2f' (extra + lengthlong * 3) * 2f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawArc(this._whitePen' arcrect' 180 + 30 + -_roll' 120);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawArc(this._whitePen' arcrect' 180 + 30 + -_roll' 120);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawArc(this._whitePen' arcrect' 180 + 30 + -_roll' 120);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Rectangle centercircle = new Rectangle(-halfwidth / 2' -halfwidth / 2' halfwidth' halfwidth);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Rectangle centercircle = new Rectangle(-halfwidth / 2' -halfwidth / 2' halfwidth' halfwidth);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(redtemp' centercircle.Left - halfwidth / 5' 0' centercircle.Left' 0);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(redtemp' centercircle.Right' 0' centercircle.Right + halfwidth / 5' 0);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(redtemp' 0 - 1' 0' centercircle.Right - halfwidth / 3'                              0 + halfheight / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(redtemp' 0 - 1' 0' centercircle.Right - halfwidth / 3'                              0 + halfheight / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(redtemp' 0 + 1' 0' centercircle.Left + halfwidth / 3'                              0 + halfheight / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(redtemp' 0 + 1' 0' centercircle.Left + halfwidth / 3'                              0 + halfheight / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawEllipse(this._redPen'                          new Rectangle((int)(-halfwidth / 40 - _SSA * every5deg)'                              (int)(-halfwidth / 40 - _AOA * every5deg)' halfwidth / 20' halfwidth / 20));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawEllipse(this._redPen'                          new Rectangle((int)(-halfwidth / 40 - _SSA * every5deg)'                              (int)(-halfwidth / 40 - _AOA * every5deg)' halfwidth / 20' halfwidth / 20));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawEllipse(this._redPen'                          new Rectangle((int)(-halfwidth / 40 - _SSA * every5deg)'                              (int)(-halfwidth / 40 - _AOA * every5deg)' halfwidth / 20' halfwidth / 20));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawEllipse(this._redPen'                          new Rectangle((int)(-halfwidth / 40 - _SSA * every5deg)'                              (int)(-halfwidth / 40 - _AOA * every5deg)' halfwidth / 20' halfwidth / 20));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' -halfwidth / 20 - _SSA * every5deg' 0 - _AOA * every5deg'                          -halfwidth / 40 - _SSA * every5deg' 0 - _AOA * every5deg);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' -halfwidth / 20 - _SSA * every5deg' 0 - _AOA * every5deg'                          -halfwidth / 40 - _SSA * every5deg' 0 - _AOA * every5deg);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' halfwidth / 20 - _SSA * every5deg' 0 - _AOA * every5deg'                          halfwidth / 40 - _SSA * every5deg' 0 - _AOA * every5deg);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' halfwidth / 20 - _SSA * every5deg' 0 - _AOA * every5deg'                          halfwidth / 40 - _SSA * every5deg' 0 - _AOA * every5deg);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' 0 - _SSA * every5deg' -halfwidth / 20 - _AOA * every5deg'                          0 - _SSA * every5deg' -halfwidth / 40 - _AOA * every5deg);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' 0 - _SSA * every5deg' -halfwidth / 20 - _AOA * every5deg'                          0 - _SSA * every5deg' -halfwidth / 40 - _AOA * every5deg);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Rectangle headbg = new Rectangle(0' 0' this.Width - 0' this.Height / 14);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' headbg.Left + 5' headbg.Bottom - 5' headbg.Width - 5'                          headbg.Bottom - 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' headbg.Left + 5' headbg.Bottom - 5' headbg.Width - 5'                          headbg.Bottom - 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' headbg.Left + 5' headbg.Bottom - 5' headbg.Width - 5'                          headbg.Bottom - 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' headbg.Left + 5' headbg.Bottom - 5' headbg.Width - 5'                          headbg.Bottom - 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float space = (headbg.Width - 10) / 120.0f;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float space = (headbg.Width - 10) / 120.0f;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int start = (int)Math.Round((_heading - 60)' 1);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' headbg.Left + 5 + space * 0' headbg.Bottom'                              headbg.Left + 5 + space * (0)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' headbg.Left + 5 + space * 0' headbg.Bottom'                              headbg.Left + 5 + space * (0)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' headbg.Left + 5 + space * 60' headbg.Bottom'                              headbg.Left + 5 + space * (60)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' headbg.Left + 5 + space * 60' headbg.Bottom'                              headbg.Left + 5 + space * (60)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' headbg.Left + 5 + space * 60' headbg.Bottom'                              headbg.Left + 5 + space * (60)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' headbg.Left + 5 + space * 60' headbg.Bottom'                              headbg.Left + 5 + space * (60)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: _targetheading > _heading + 60
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' headbg.Left + 5 + space * (a - start)'                                  headbg.Bottom' headbg.Left + 5 + space * (a - start)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' headbg.Left + 5 + space * (a - start)'                                  headbg.Bottom' headbg.Left + 5 + space * (a - start)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ((int)(a + 360) % 360) == (int)_targetheading
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ((int)(a + 360) % 360) == (int)_targetheading
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._blackPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._blackPen' headbg.Left + 5 + space * (a - start)'                                  headbg.Bottom' headbg.Left + 5 + space * (a - start)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._blackPen' headbg.Left + 5 + space * (a - start)'                                  headbg.Bottom' headbg.Left + 5 + space * (a - start)' headbg.Top);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._blackPen.Width = 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ((int)(a + 360) % 360) == (int)_groundcourse
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ((int)(a + 360) % 360) == (int)_groundcourse
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' headbg.Left + 5 + space * (a - start)'                                  headbg.Bottom - 5' headbg.Left + 5 + space * (a - start)' headbg.Bottom - 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' headbg.Left + 5 + space * (a - start)'                                  headbg.Bottom - 5' headbg.Left + 5 + space * (a - start)' headbg.Bottom - 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' headbg.Left + 5 + space * (a - start)'                                  headbg.Bottom - 5' headbg.Left + 5 + space * (a - start)' headbg.Bottom - 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' headbg.Left + 5 + space * (a - start)'                                  headbg.Bottom - 5' headbg.Left + 5 + space * (a - start)' headbg.Bottom - 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: disp += 360;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: disp = disp % 360;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.N.PadLeft(2)' font' fontsize + 4' _whiteBrush'                                      headbg.Left - 5 + space * (a - start) - fontoffset'                                      headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.N.PadLeft(2)' font' fontsize + 4' _whiteBrush'                                      headbg.Left - 5 + space * (a - start) - fontoffset'                                      headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.N.PadLeft(2)' font' fontsize + 4' _whiteBrush'                                      headbg.Left - 5 + space * (a - start) - fontoffset'                                      headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.N.PadLeft(2)' font' fontsize + 4' _whiteBrush'                                      headbg.Left - 5 + space * (a - start) - fontoffset'                                      headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.N.PadLeft(2)' font' fontsize + 4' _whiteBrush'                                      headbg.Left - 5 + space * (a - start) - fontoffset'                                      headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: (int)a % 15 == 0
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: a <= _heading + 60
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF rect = new RectangleF(headbg.Width / 2 - (fontsize * 2.4f) / 2' 0' (fontsize * 2.4f)'                          headbg.Height);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF rect = new RectangleF(headbg.Width / 2 - (fontsize * 2.4f) / 2' 0' (fontsize * 2.4f)'                          headbg.Height);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF rect = new RectangleF(headbg.Width / 2 - (fontsize * 2.4f) / 2' 0' (fontsize * 2.4f)'                          headbg.Height);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: RectangleF rect = new RectangleF(headbg.Width / 2 - (fontsize * 2.4f) / 2' 0' (fontsize * 2.4f)'                          headbg.Height);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(String.Format("{0'3}"' (int)(heading % 360))' font' fontsize'                              _whiteBrush' headbg.Width / 2 - (fontsize * 1f)'                              headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(String.Format("{0'3}"' (int)(heading % 360))' font' fontsize'                              _whiteBrush' headbg.Width / 2 - (fontsize * 1f)'                              headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(String.Format("{0'3}"' (int)(heading % 360))' font' fontsize'                              _whiteBrush' headbg.Width / 2 - (fontsize * 1f)'                              headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(String.Format("{0'3}"' (int)(heading % 360))' font' fontsize'                              _whiteBrush' headbg.Width / 2 - (fontsize * 1f)'                              headbg.Bottom - 24 - (int)(fontoffset * 1.7));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Math.Abs(_heading - _targetheading) < 4
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float xtspace = this.Width / 10.0f / 3.0f;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float xtspace = this.Width / 10.0f / 3.0f;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int pad = 10;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: myxtrack_error = Math.Min(myxtrack_error' 40);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: myxtrack_error = Math.Max(myxtrack_error' -40);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float loc = myxtrack_error / 20.0f * xtspace;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(128' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Math.Abs(myxtrack_error) == 40
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc' headbg.Bottom + 5'                          this.Width / 10 + loc' headbg.Bottom + this.Height / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc' headbg.Bottom + 5'                          this.Width / 10 + loc' headbg.Bottom + this.Height / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc' headbg.Bottom + 5'                          this.Width / 10 + loc' headbg.Bottom + this.Height / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc' headbg.Bottom + 5'                          this.Width / 10 + loc' headbg.Bottom + this.Height / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(255' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10' headbg.Bottom + 5' this.Width / 10'                          headbg.Bottom + this.Height / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10' headbg.Bottom + 5' this.Width / 10'                          headbg.Bottom + this.Height / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10' headbg.Bottom + 5' this.Width / 10'                          headbg.Bottom + this.Height / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10' headbg.Bottom + 5' this.Width / 10'                          headbg.Bottom + this.Height / 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 - xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2' headbg.Bottom + 5 + pad'                          this.Width / 10 + xtspace * 2' headbg.Bottom + this.Height / 10 - pad);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._whitePen.Width = 4;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 0 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 0 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 0 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 0 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 0 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 0 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 0 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 0 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 0 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 0 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 0 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 0 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 0 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 0 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 - xtspace * 0 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 - xtspace * 0 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' this.Width / 10 + xtspace * 2 - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10' this.Width / 10 + xtspace * 2 - xtspace / 2 + xtspace'                          headbg.Bottom + this.Height / 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float trwidth = (this.Width / 10 + xtspace * 2 - xtspace / 2) -                                      (this.Width / 10 - xtspace * 2 - xtspace / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float trwidth = (this.Width / 10 + xtspace * 2 - xtspace / 2) -                                      (this.Width / 10 - xtspace * 2 - xtspace / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float trwidth = (this.Width / 10 + xtspace * 2 - xtspace / 2) -                                      (this.Width / 10 - xtspace * 2 - xtspace / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float trwidth = (this.Width / 10 + xtspace * 2 - xtspace / 2) -                                      (this.Width / 10 - xtspace * 2 - xtspace / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float trwidth = (this.Width / 10 + xtspace * 2 - xtspace / 2) -                                      (this.Width / 10 - xtspace * 2 - xtspace / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float trwidth = (this.Width / 10 + xtspace * 2 - xtspace / 2) -                                      (this.Width / 10 - xtspace * 2 - xtspace / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float range = 12;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: myturnrate = Math.Min(myturnrate' range / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: myturnrate = Math.Max(myturnrate' (range / 2) * -1.0f);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 4;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(128' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Math.Abs(myturnrate) == (range / 2)
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc - xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc + xtspace / 2'                          headbg.Bottom + this.Height / 10 + 10 + 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 3' this.Width / 10 + loc'                          headbg.Bottom + this.Height / 10 + 10 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(255' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._whitePen.Width = 2;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Rectangle scrollbg = new Rectangle(0' halfheight - halfheight / 2' this.Width / 10' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Rectangle scrollbg = new Rectangle(0' halfheight - halfheight / 2' this.Width / 10' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Rectangle scrollbg = new Rectangle(0' halfheight - halfheight / 2' this.Width / 10' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Point[] arrow = new Point[5];
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[0] = new Point(0' -10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[1] = new Point(scrollbg.Width - 10' -10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[1] = new Point(scrollbg.Width - 10' -10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[2] = new Point(scrollbg.Width - 5' 0);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[2] = new Point(scrollbg.Width - 5' 0);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[3] = new Point(scrollbg.Width - 10' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[3] = new Point(scrollbg.Width - 10' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[3] = new Point(scrollbg.Width - 10' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[4] = new Point(0' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[4] = new Point(0' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(0' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float viewrange = 26;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float start = (long)(speed - viewrange / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(128' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(255' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(128' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(255' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: (speed + viewrange / 2) < _targetspeed
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: long end = (long)(speed + viewrange / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' scrollbg.Right' scrollbg.Top - space * (a - start)'                                  scrollbg.Right - 10' scrollbg.Top - space * (a - start));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(String.Format("{0'5}"' a)' font' fontsize' _whiteBrush' 0'                                  (float)(scrollbg.Top - space * (a - start) - 6 - fontoffset));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: a % 5 == 0
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring((speed).ToString("0") + speedunit' font' 10' (SolidBrush)Brushes.AliceBlue' 0' -9);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring((speed).ToString("0") + speedunit' font' 10' (SolidBrush)Brushes.AliceBlue' 0' -9);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.AS + _airspeed.ToString("0.0") + speedunit' font' fontsize'                              (SolidBrush)Brushes.Red' 1' scrollbg.Bottom + 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.GS + _groundspeed.ToString("0.0") + speedunit' font' fontsize'                              (SolidBrush)Brushes.Red' 1' scrollbg.Bottom + fontsize + 2 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.GS + _groundspeed.ToString("0.0") + speedunit' font' fontsize'                              (SolidBrush)Brushes.Red' 1' scrollbg.Bottom + fontsize + 2 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg = new Rectangle(this.Width - this.Width / 10' halfheight - halfheight / 2' this.Width / 10'                      this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg = new Rectangle(this.Width - this.Width / 10' halfheight - halfheight / 2' this.Width / 10'                      this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg = new Rectangle(this.Width - this.Width / 10' halfheight - halfheight / 2' this.Width / 10'                      this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg = new Rectangle(this.Width - this.Width / 10' halfheight - halfheight / 2' this.Width / 10'                      this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: Point[] arrow = new Point[5];
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[0] = new Point(0' -10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[1] = new Point(scrollbg.Width - 10' -10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[1] = new Point(scrollbg.Width - 10' -10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[2] = new Point(scrollbg.Width - 5' 0);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[2] = new Point(scrollbg.Width - 5' 0);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[3] = new Point(scrollbg.Width - 10' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[3] = new Point(scrollbg.Width - 10' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[3] = new Point(scrollbg.Width - 10' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[4] = new Point(0' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: arrow[4] = new Point(0' 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(0' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int viewrange = 26;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: long start = ((int)_alt - viewrange / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(128' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(255' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(128' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Color = Color.FromArgb(255' this._greenPen.Color);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: (_alt + viewrange / 2) < _targetalt
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 6;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' scrollbg.Left' scrollbg.Top - space * (a - start)'                                  scrollbg.Left + 10' scrollbg.Top - space * (a - start));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(String.Format("{0'5}"' a)' font' fontsize' _whiteBrush'                                  scrollbg.Left + 0 + (int)(0 * fontoffset)'                                  scrollbg.Top - space * (a - start) - 6 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: a % 5 == 0
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: a <= (_alt + viewrange / 2)
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: this._greenPen.Width = 4;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: PointF[] poly = new PointF[4];
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: poly[1] = new PointF(scrollbg.Left - scrollbg.Width / 4' scrollbg.Top + scrollbg.Width / 4);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: poly[1] = new PointF(scrollbg.Left - scrollbg.Width / 4' scrollbg.Top + scrollbg.Width / 4);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: poly[2] = new PointF(scrollbg.Left - scrollbg.Width / 4' scrollbg.Bottom - scrollbg.Width / 4);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: poly[2] = new PointF(scrollbg.Left - scrollbg.Width / 4' scrollbg.Bottom - scrollbg.Width / 4);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: poly[2] = new PointF(scrollbg.Left - scrollbg.Width / 4' scrollbg.Bottom - scrollbg.Width / 4);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: poly[3] = new PointF(scrollbg.Left' scrollbg.Bottom);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: viewrange = 12;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: _verticalspeed = Math.Min(viewrange / 2' _verticalspeed);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: _verticalspeed = Math.Max(viewrange / -2' _verticalspeed);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: PointF[] polyn = new PointF[4];
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[0] = new PointF(scrollbg.Left' scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[1] = new PointF(scrollbg.Left - scrollbg.Width / 4'                          scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[1] = new PointF(scrollbg.Left - scrollbg.Width / 4'                          scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[2] = polyn[1];
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: peak = -scrollbg.Width / 4;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2 + scaledvalue + peak <                              scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2 + scaledvalue + peak <                              scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[2] = new PointF(scrollbg.Left - scrollbg.Width / 4'                          scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2 + scaledvalue + peak);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[2] = new PointF(scrollbg.Left - scrollbg.Width / 4'                          scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2 + scaledvalue + peak);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[2] = new PointF(scrollbg.Left - scrollbg.Width / 4'                          scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2 + scaledvalue + peak);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[3] = new PointF(scrollbg.Left'                          scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2 + scaledvalue);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: polyn[3] = new PointF(scrollbg.Left'                          scrollbg.Top + (scrollbg.Bottom - scrollbg.Top) / 2 + scaledvalue);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' scrollbg.Left - scrollbg.Width / 4'                              scrollbg.Top - linespace * a' scrollbg.Left - scrollbg.Width / 8'                              scrollbg.Top - linespace * a);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._whitePen' scrollbg.Left - scrollbg.Width / 4'                              scrollbg.Top - linespace * a' scrollbg.Left - scrollbg.Width / 8'                              scrollbg.Top - linespace * a);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.RotateTransform(180);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(0' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(((int)_alt).ToString("0 ") + altunit' font' 10' (SolidBrush)Brushes.AliceBlue'                          scrollbg.Left + 10' -9);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(((int)_alt).ToString("0 ") + altunit' font' 10' (SolidBrush)Brushes.AliceBlue'                          scrollbg.Left + 10' -9);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(((int)_alt).ToString("0 ") + altunit' font' 10' (SolidBrush)Brushes.AliceBlue'                          scrollbg.Left + 10' -9);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(_mode' font' fontsize' _whiteBrush' scrollbg.Left - 30'                          scrollbg.Bottom + 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(_mode' font' fontsize' _whiteBrush' scrollbg.Left - 30'                          scrollbg.Bottom + 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring((int)_disttowp + distunit + ">" + _wpno' font' fontsize' _whiteBrush'                          scrollbg.Left - 30' scrollbg.Bottom + fontsize + 2 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring((int)_disttowp + distunit + ">" + _wpno' font' fontsize' _whiteBrush'                          scrollbg.Left - 30' scrollbg.Bottom + fontsize + 2 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring((int)_disttowp + distunit + ">" + _wpno' font' fontsize' _whiteBrush'                          scrollbg.Left - 30' scrollbg.Bottom + fontsize + 2 + 10);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left - 5'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 15' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 15' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 15' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 15' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 15' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 15' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 15' scrollbg.Left - 10'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 10' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 10' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 10' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 10' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 10' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 10' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._greenPen' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize * 2.2) - 2 - 10' scrollbg.Left - 15'                          scrollbg.Top - (int)(fontsize) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(_linkqualitygcs.ToString("0") + "%"' font' fontsize' _whiteBrush'                          scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(_linkqualitygcs.ToString("0") + "%"' font' fontsize' _whiteBrush'                          scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(_linkqualitygcs.ToString("0") + "%"' font' fontsize' _whiteBrush'                          scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left'                              scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left + 50'                              scrollbg.Top - (int)(fontsize * 2.2) - 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left'                              scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left + 50'                              scrollbg.Top - (int)(fontsize * 2.2) - 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left'                              scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left + 50'                              scrollbg.Top - (int)(fontsize * 2.2) - 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left'                              scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left + 50'                              scrollbg.Top - (int)(fontsize * 2.2) - 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left'                              scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left + 50'                              scrollbg.Top - (int)(fontsize * 2.2) - 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left'                              scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20' scrollbg.Left + 50'                              scrollbg.Top - (int)(fontsize * 2.2) - 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2'                              scrollbg.Left + 50' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2'                              scrollbg.Left + 50' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2'                              scrollbg.Left + 50' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2'                              scrollbg.Left + 50' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2'                              scrollbg.Left + 50' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.DrawLine(this._redPen' scrollbg.Left' scrollbg.Top - (int)(fontsize * 2.2) - 2'                              scrollbg.Left + 50' scrollbg.Top - (int)(fontsize * 2.2) - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(_datetime.ToString("HH:mm:ss")' font' fontsize' _whiteBrush'                          scrollbg.Left - 30' scrollbg.Top - fontsize - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(_datetime.ToString("HH:mm:ss")' font' fontsize' _whiteBrush'                          scrollbg.Left - 30' scrollbg.Top - fontsize - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(_datetime.ToString("HH:mm:ss")' font' fontsize' _whiteBrush'                          scrollbg.Left - 30' scrollbg.Top - fontsize - 2 - 20);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg = new Rectangle((int)(this.Width - (double)this.Width / 6)' halfheight + halfheight / 10'                          this.Width / 25' this.Height / 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg = new Rectangle((int)(this.Width - (double)this.Width / 6)' halfheight + halfheight / 10'                          this.Width / 25' this.Height / 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg = new Rectangle((int)(this.Width - (double)this.Width / 6)' halfheight + halfheight / 10'                          this.Width / 25' this.Height / 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: scrollbg = new Rectangle((int)(this.Width - (double)this.Width / 6)' halfheight + halfheight / 10'                          this.Width / 25' this.Height / 5);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Red'                          new RectangleF(scrollbg.Left' scrollbg.Top' scrollbg.Width'                              scrollbg.Height * (100 - _redSSAp) / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Red'                          new RectangleF(scrollbg.Left' scrollbg.Top' scrollbg.Width'                              scrollbg.Height * (100 - _redSSAp) / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Yellow'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _redSSAp) / 100'                              scrollbg.Width' scrollbg.Height * (_redSSAp - _yellowSSAp) / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Yellow'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _redSSAp) / 100'                              scrollbg.Width' scrollbg.Height * (_redSSAp - _yellowSSAp) / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Yellow'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _redSSAp) / 100'                              scrollbg.Width' scrollbg.Height * (_redSSAp - _yellowSSAp) / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Green'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _yellowSSAp) / 100'                              scrollbg.Width' scrollbg.Height * (_yellowSSAp - _greenSSAp) / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Green'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _yellowSSAp) / 100'                              scrollbg.Width' scrollbg.Height * (_yellowSSAp - _greenSSAp) / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Green'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _yellowSSAp) / 100'                              scrollbg.Width' scrollbg.Height * (_yellowSSAp - _greenSSAp) / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Blue'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _greenSSAp) / 100'                              scrollbg.Width' scrollbg.Height * _greenSSAp / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Blue'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _greenSSAp) / 100'                              scrollbg.Width' scrollbg.Height * _greenSSAp / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.FillRectangle(Brushes.Blue'                          new RectangleF(scrollbg.Left' scrollbg.Top + scrollbg.Height * (100 - _greenSSAp) / 100'                              scrollbg.Width' scrollbg.Height * _greenSSAp / 100));
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float AOA_ind = scrollbg.Height * (100 - _greenSSAp) / 100 -                                      (_AOA / _critAOA) * (scrollbg.Height * (_redSSAp - _greenSSAp) / 100);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float AOA_ind = scrollbg.Height * (100 - _greenSSAp) / 100 -                                      (_AOA / _critAOA) * (scrollbg.Height * (_redSSAp - _greenSSAp) / 100);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: float AOA_ind = scrollbg.Height * (100 - _greenSSAp) / 100 -                                      (_AOA / _critAOA) * (scrollbg.Height * (_redSSAp - _greenSSAp) / 100);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: PointF[] AOA_arrow = new PointF[3];
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: AOA_arrow[0] = new PointF(scrollbg.Left + scrollbg.Width / 5' scrollbg.Top + AOA_ind);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: AOA_arrow[1] = new PointF(scrollbg.Left - scrollbg.Width / 2 + scrollbg.Width / 5'                          scrollbg.Top + scrollbg.Width / 2 + AOA_ind);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: AOA_arrow[1] = new PointF(scrollbg.Left - scrollbg.Width / 2 + scrollbg.Width / 5'                          scrollbg.Top + scrollbg.Width / 2 + AOA_ind);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: AOA_arrow[1] = new PointF(scrollbg.Left - scrollbg.Width / 2 + scrollbg.Width / 5'                          scrollbg.Top + scrollbg.Width / 2 + AOA_ind);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: AOA_arrow[2] = new PointF(scrollbg.Left - scrollbg.Width / 2 + scrollbg.Width / 5'                          scrollbg.Top - scrollbg.Width / 2 + AOA_ind);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: AOA_arrow[2] = new PointF(scrollbg.Left - scrollbg.Width / 2 + scrollbg.Width / 5'                          scrollbg.Top - scrollbg.Width / 2 + AOA_ind);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: AOA_arrow[2] = new PointF(scrollbg.Left - scrollbg.Width / 2 + scrollbg.Width / 5'                          scrollbg.Top - scrollbg.Width / 2 + AOA_ind);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: AOA_arrow[2] = new PointF(scrollbg.Left - scrollbg.Width / 2 + scrollbg.Width / 5'                          scrollbg.Top - scrollbg.Width / 2 + AOA_ind);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(text' font' fontsize + 2' (SolidBrush)Brushes.Red' fontsize'                              this.Height - 30 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(text' font' fontsize + 2' (SolidBrush)Brushes.Red' fontsize'                              this.Height - 30 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(gps' font' fontsize + 2' col' this.Width - 13 * fontsize'                          this.Height - 30 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(gps' font' fontsize + 2' col' this.Width - 13 * fontsize'                          this.Height - 30 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(gps' font' fontsize + 2' col' this.Width - 13 * fontsize'                          this.Height - 30 - fontoffset);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring("NaN Error " + DateTime.Now' font' this.Height / 30 + 10'                          (SolidBrush)Brushes.Red' 50' 50);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring("NaN Error " + DateTime.Now' font' this.Height / 30 + 10'                          (SolidBrush)Brushes.Red' 50' 50);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring("NaN Error " + DateTime.Now' font' this.Height / 30 + 10'                          (SolidBrush)Brushes.Red' 50' 50);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring("NaN Error " + DateTime.Now' font' this.Height / 30 + 10'                          (SolidBrush)Brushes.Red' 50' 50);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int height = this.Height - 30 - fontoffset - fontsize - 8;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: int height = this.Height - 30 - fontoffset - fontsize - 8;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(item.Header + item.GetValue.ToString("0.#######")' font'                                  fontsize + 2' _whiteBrush' this.Width / 8' height);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(item.Header + item.GetValue.ToString("0.#######")' font'                                  fontsize + 2' _whiteBrush' this.Width / 8' height);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: height -= fontsize + 5;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: graphicsObject.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.DISARMED' font' fontsize + 10' (SolidBrush)Brushes.Red' -85'                              halfheight / -3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.DISARMED' font' fontsize + 10' (SolidBrush)Brushes.Red' -85'                              halfheight / -3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.DISARMED' font' fontsize + 10' (SolidBrush)Brushes.Red' -85'                              halfheight / -3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.FAILSAFE' font' fontsize + 20' (SolidBrush)Brushes.Red' -85'                          halfheight / -HUDT.FailsafeH);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(HUDT.FAILSAFE' font' fontsize + 20' (SolidBrush)Brushes.Red' -85'                          halfheight / -HUDT.FailsafeH);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(message' font' fontsize + 10' (SolidBrush)Brushes.Red' -halfwidth + 50'                          halfheight / 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(message' font' fontsize + 10' (SolidBrush)Brushes.Red' -halfwidth + 50'                          halfheight / 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring(message' font' fontsize + 10' (SolidBrush)Brushes.Red' -halfwidth + 50'                          halfheight / 3);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: message != "" && messagetime.AddSeconds(10) > DateTime.Now
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: vibehitzone = new Rectangle(this.Width - 18 * fontsize' this.Height - 30 - fontoffset' 40'                          fontsize * 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: vibehitzone = new Rectangle(this.Width - 18 * fontsize' this.Height - 30 - fontoffset' 40'                          fontsize * 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: vibehitzone = new Rectangle(this.Width - 18 * fontsize' this.Height - 30 - fontoffset' 40'                          fontsize * 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: vibehitzone = new Rectangle(this.Width - 18 * fontsize' this.Height - 30 - fontoffset' 40'                          fontsize * 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring("Vibe"' font' fontsize + 2' (SolidBrush)Brushes.Red' vibehitzone.X'                              vibehitzone.Y);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: vibex > 30 || vibey > 30 || vibez > 30
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: vibex > 30 || vibey > 30 || vibez > 30
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: vibex > 30 || vibey > 30 || vibez > 30
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ekfhitzone = new Rectangle(this.Width - 23 * fontsize' this.Height - 30 - fontoffset' 40'                          fontsize * 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ekfhitzone = new Rectangle(this.Width - 23 * fontsize' this.Height - 30 - fontoffset' 40'                          fontsize * 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ekfhitzone = new Rectangle(this.Width - 23 * fontsize' this.Height - 30 - fontoffset' 40'                          fontsize * 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ekfhitzone = new Rectangle(this.Width - 23 * fontsize' this.Height - 30 - fontoffset' 40'                          fontsize * 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: drawstring("EKF"' font' fontsize + 2' (SolidBrush)Brushes.Red'                                  ekfhitzone.X'                                  ekfhitzone.Y);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ekfstatus > 0.8
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,doPaint,The following statement contains a magic number: ekfstatus > 0.5
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,The following statement contains a magic number: int charid = charno ^ (int)(fontsize * 1000) ^ brush.Color.ToArgb();
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,The following statement contains a magic number: charDict[charid] = new character()                      {                          bitmap = new Bitmap(128' 128' SKColorType.Bgra8888)'                          size = (int)fontsize                      };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,The following statement contains a magic number: charDict[charid] = new character()                      {                          bitmap = new Bitmap(128' 128' SKColorType.Bgra8888)'                          size = (int)fontsize                      };
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,The following statement contains a magic number: float maxx = this.Width / 150;
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,The following statement contains a magic number: pth.AddString(cha + ""' font.FontFamily' 0' fontsize + 5' new Point((int)0' (int)0)'                                  StringFormat.GenericTypographic);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,drawstring,The following statement contains a magic number: charDict[charid].width = (int)(maxx + 2);
Magic Number,MissionPlanner.Controls,HUD,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\HUD.cs,wrap360,The following statement contains a magic number: return noin + 360;
Magic Number,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,OnTouch,The following statement contains a magic number: mouse.X = (int)(m2.X + mid.X/2.0);
Magic Number,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,OnTouch,The following statement contains a magic number: mouse.Y = (int)(m2.Y + mid.Y/2.0);
Magic Number,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,OnTouch,The following statement contains a magic number: delta.Length > mousewheeldelta + 10 || delta.Length < mousewheeldelta - 10
Magic Number,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,OnTouch,The following statement contains a magic number: delta.Length > mousewheeldelta + 10 || delta.Length < mousewheeldelta - 10
Magic Number,MissionPlanner.Maps,Custom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Custom.cs,Custom,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,GMapMarkerADSBPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerADSBPlane.cs,OnRender,The following statement contains a magic number: switch (AlertLevel)              {                  case AlertLevelOptions.Green:                      g.DrawImageUnscaled(icong' icong.Width/-2' icong.Height/-2);                      break;                  case AlertLevelOptions.Orange:                      g.DrawImageUnscaled(icono' icono.Width/-2' icono.Height/-2);                      break;                  case AlertLevelOptions.Red:                      g.DrawImageUnscaled(iconr' iconr.Width/-2' iconr.Height/-2);                      break;              }
Magic Number,MissionPlanner.Maps,GMapMarkerADSBPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerADSBPlane.cs,OnRender,The following statement contains a magic number: switch (AlertLevel)              {                  case AlertLevelOptions.Green:                      g.DrawImageUnscaled(icong' icong.Width/-2' icong.Height/-2);                      break;                  case AlertLevelOptions.Orange:                      g.DrawImageUnscaled(icono' icono.Width/-2' icono.Height/-2);                      break;                  case AlertLevelOptions.Red:                      g.DrawImageUnscaled(iconr' iconr.Width/-2' iconr.Height/-2);                      break;              }
Magic Number,MissionPlanner.Maps,GMapMarkerADSBPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerADSBPlane.cs,OnRender,The following statement contains a magic number: switch (AlertLevel)              {                  case AlertLevelOptions.Green:                      g.DrawImageUnscaled(icong' icong.Width/-2' icong.Height/-2);                      break;                  case AlertLevelOptions.Orange:                      g.DrawImageUnscaled(icono' icono.Width/-2' icono.Height/-2);                      break;                  case AlertLevelOptions.Red:                      g.DrawImageUnscaled(iconr' iconr.Width/-2' iconr.Height/-2);                      break;              }
Magic Number,MissionPlanner.Maps,GMapMarkerADSBPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerADSBPlane.cs,OnRender,The following statement contains a magic number: switch (AlertLevel)              {                  case AlertLevelOptions.Green:                      g.DrawImageUnscaled(icong' icong.Width/-2' icong.Height/-2);                      break;                  case AlertLevelOptions.Orange:                      g.DrawImageUnscaled(icono' icono.Width/-2' icono.Height/-2);                      break;                  case AlertLevelOptions.Red:                      g.DrawImageUnscaled(iconr' iconr.Width/-2' iconr.Height/-2);                      break;              }
Magic Number,MissionPlanner.Maps,GMapMarkerADSBPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerADSBPlane.cs,OnRender,The following statement contains a magic number: switch (AlertLevel)              {                  case AlertLevelOptions.Green:                      g.DrawImageUnscaled(icong' icong.Width/-2' icong.Height/-2);                      break;                  case AlertLevelOptions.Orange:                      g.DrawImageUnscaled(icono' icono.Width/-2' icono.Height/-2);                      break;                  case AlertLevelOptions.Red:                      g.DrawImageUnscaled(iconr' iconr.Width/-2' iconr.Height/-2);                      break;              }
Magic Number,MissionPlanner.Maps,GMapMarkerADSBPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerADSBPlane.cs,OnRender,The following statement contains a magic number: switch (AlertLevel)              {                  case AlertLevelOptions.Green:                      g.DrawImageUnscaled(icong' icong.Width/-2' icong.Height/-2);                      break;                  case AlertLevelOptions.Orange:                      g.DrawImageUnscaled(icono' icono.Width/-2' icono.Height/-2);                      break;                  case AlertLevelOptions.Red:                      g.DrawImageUnscaled(iconr' iconr.Width/-2' iconr.Height/-2);                      break;              }
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: wprad = 9000;
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: p.Lng < -25
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: wprad = 5559;
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: p.Lat < -10 && p.Lng > 109 && p.Lng < 180
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: p.Lat < -10 && p.Lng > 109 && p.Lng < 180
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: p.Lat < -10 && p.Lng > 109 && p.Lng < 180
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: Size = new System.Drawing.Size(50' 50);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: Size = new System.Drawing.Size(50' 50);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: Offset = new System.Drawing.Point(-Size.Width/2' -Size.Height/2);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,GMapMarkerAirport,The following statement contains a magic number: Offset = new System.Drawing.Point(-Size.Width/2' -Size.Height/2);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: double width =                  (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                      Overlay.Control.FromLocalToLatLng(Overlay.Control.Width' 0))*1000.0);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: double height =                  (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                      Overlay.Control.FromLocalToLatLng(Overlay.Control.Height' 0))*1000.0);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: GPoint loc = new GPoint((int) (LocalPosition.X - (m2pixelwidth*wprad*2))' LocalPosition.Y);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: int x = LocalPosition.X - Offset.X - (int) (Math.Abs(loc.X - LocalPosition.X)/2);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: int y = LocalPosition.Y - Offset.Y - (int) Math.Abs(loc.X - LocalPosition.X)/2;
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: g.FillPie(new SolidBrush(Color.FromArgb(25' Color.Red))' x' y' widtharc' heightarc' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: g.FillPie(new SolidBrush(Color.FromArgb(25' Color.Red))' x' y' widtharc' heightarc' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: widtharc > 0 && widtharc < 200000000 && Overlay.Control.Zoom > 3
Magic Number,MissionPlanner.Maps,GMapMarkerAirport,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAirport.cs,OnRender,The following statement contains a magic number: widtharc > 0 && widtharc < 200000000 && Overlay.Control.Zoom > 3
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: int length = 500;
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawImage(icon' -20' -20' 40' 40);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawImage(icon' -20' -20' 40' 40);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawImage(icon' -20' -20' 40' 40);
Magic Number,MissionPlanner.Maps,GMapMarkerAntennaTracker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerAntennaTracker.cs,OnRender,The following statement contains a magic number: g.DrawImage(icon' -20' -20' 40' 40);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: int length = 500;
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(global::MissionPlanner.Maps.Resources.boat.ToBitmap()'                  Size.Width / -2'                  Size.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerBoat,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerBoat.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(global::MissionPlanner.Maps.Resources.boat.ToBitmap()'                  Size.Width / -2'                  Size.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,GMapMarkerDistance,The following statement contains a magic number: Size = new System.Drawing.Size(50' 50);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,GMapMarkerDistance,The following statement contains a magic number: Size = new System.Drawing.Size(50' 50);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,GMapMarkerDistance,The following statement contains a magic number: Offset = new System.Drawing.Point(-Size.Width / 2' -Size.Height / 2);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,GMapMarkerDistance,The following statement contains a magic number: Offset = new System.Drawing.Point(-Size.Width / 2' -Size.Height / 2);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: double width =                  (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                      Overlay.Control.FromLocalToLatLng(Overlay.Control.Width' 0)) * 1000.0);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: double height =                  (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                      Overlay.Control.FromLocalToLatLng(Overlay.Control.Height' 0)) * 1000.0);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: GPoint loc = new GPoint((int)(LocalPosition.X - (m2pixelwidth * wprad * 2))' LocalPosition.Y);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: GPoint loc2 = new GPoint((int)(LocalPosition.X - (m2pixelwidth * wprad * tolerance * 2))' LocalPosition.Y);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: int x = LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: int y = LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2;
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: int x2 = LocalPosition.X - Offset.X - (int)(Math.Abs(loc2.X - LocalPosition.X) / 2);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: int y2 = LocalPosition.Y - Offset.Y - (int)Math.Abs(loc2.X - LocalPosition.X) / 2;
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pen' new System.Drawing.Rectangle(x' y' widtharc' heightarc)' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: widtharc > 0 && widtharc < 10000
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pen2' new System.Drawing.Rectangle(x2' y2' widtharc2' heightarc2)' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: widtharc2 > 0 && widtharc2 < 10000 && tolerance != 0
Magic Number,MissionPlanner.Maps,GMapMarkerDistance,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerDistance.cs,OnRender,The following statement contains a magic number: Overlay.Control.Zoom > 3
Magic Number,MissionPlanner.Maps,GMapMarkerElevation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerElevation.cs,GMapMarkerElevation,The following statement contains a magic number: int[] pixels = new int[(bmData.Stride/4) * bmData.Height];
Magic Number,MissionPlanner.Maps,GMapMarkerElevation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerElevation.cs,GMapMarkerElevation,The following statement contains a magic number: pixels[(y * (bmData.Stride/4) + x)] = ConvertColor(imageData[x' y]);
Magic Number,MissionPlanner.Maps,GMapMarkerElevation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerElevation.cs,GMapMarkerElevation,The following statement contains a magic number: System.Runtime.InteropServices.Marshal.Copy(pixels' 0' bmData.Scan0' (bmData.Stride/4) * bmData.Height);
Magic Number,MissionPlanner.Maps,GMapMarkerElevation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerElevation.cs,GMapMarkerElevation,The following statement contains a magic number: pal.Entries[i] = Color.FromArgb((int)100' bmp.Palette.Entries[i].R' bmp.Palette.Entries[i].G' bmp.Palette.Entries[i].B);
Magic Number,MissionPlanner.Maps,GMapMarkerElevation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerElevation.cs,GMapMarkerElevation,The following statement contains a magic number: i < 256
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: int length = 500;
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width/-2 + 2' icon.Height/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width/-2 + 2' icon.Height/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerHeli,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerHeli.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width/-2 + 2' icon.Height/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The following statement contains a magic number: colorbrushs[a] = new SolidBrush(Color.FromArgb(140' color1.R' color1.G' color1.B));
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The following statement contains a magic number: double width =                  (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                      Overlay.Control.FromLocalToLatLng(Overlay.Control.Width' 0))*1000.0);
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The following statement contains a magic number: Rect screenRect = new Rect(Overlay.Control.Width/-2' Overlay.Control.Height/-2' Overlay.Control.Width'                  Overlay.Control.Height);
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The following statement contains a magic number: Rect screenRect = new Rect(Overlay.Control.Width/-2' Overlay.Control.Height/-2' Overlay.Control.Width'                  Overlay.Control.Height);
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The following statement contains a magic number: var col = Math.Min(pg.Value - 1' 7);
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The following statement contains a magic number: var widthc = 5*m2pixelwidth;
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The following statement contains a magic number: var halfwidthc = widthc/2.0f;
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,OnRender,The following statement contains a magic number: g.FillPie(coloruse' (float) (p.X - halfwidthc)' (float) (p.Y - halfwidthc)' (float) (widthc)'                      (float) (widthc)' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,drawLegend,The following statement contains a magic number: double width = Overlay.Control.MapProvider.Projection.GetDistance(tl' tr)*1000.0;
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,drawLegend,The following statement contains a magic number: var widthc = 20;
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,drawLegend,The following statement contains a magic number: var halfwidthc = widthc/2.0f;
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,drawLegend,The following statement contains a magic number: GPoint p = new GPoint(20' (long) (100 + a*(widthc + 5)));
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,drawLegend,The following statement contains a magic number: GPoint p = new GPoint(20' (long) (100 + a*(widthc + 5)));
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,drawLegend,The following statement contains a magic number: GPoint p = new GPoint(20' (long) (100 + a*(widthc + 5)));
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,drawLegend,The following statement contains a magic number: g.FillPie(brush' (float) (p.X - halfwidthc)' (float) (p.Y - halfwidthc)' (float) (widthc)'                          (float) (widthc)' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,generateCoverageAll,The following statement contains a magic number: var p = new PointLatLng(Math.Round(lat' 4)' Math.Round(lng' 4));
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,generateCoverageAll,The following statement contains a magic number: var p = new PointLatLng(Math.Round(lat' 4)' Math.Round(lng' 4));
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,generateCoverageFP,The following statement contains a magic number: var p = new PointLatLng(Math.Round(lat' 4)' Math.Round(lng' 4));
Magic Number,MissionPlanner.Maps,GMapMarkerOverlapCount,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerOverlapCount.cs,generateCoverageFP,The following statement contains a magic number: var p = new PointLatLng(Math.Round(lat' 4)' Math.Round(lng' 4));
Magic Number,MissionPlanner.Maps,GMapMarkerPhoto,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPhoto.cs,GMapMarkerPhoto,The following statement contains a magic number: Offset = new Point(-localcache1.Width/2' -localcache1.Height/2);
Magic Number,MissionPlanner.Maps,GMapMarkerPhoto,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPhoto.cs,GMapMarkerPhoto,The following statement contains a magic number: Offset = new Point(-localcache1.Width/2' -localcache1.Height/2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: int length = 500;
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float) Math.Cos((nav_bearing - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((nav_bearing - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float) Math.Cos((nav_bearing - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((nav_bearing - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float) Math.Cos((nav_bearing - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((nav_bearing - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: float desired_lead_dist = 100;
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: double width =                  (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                       Overlay.Control.FromLocalToLatLng(Overlay.Control.Width' 0))*1000.0);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawArc(new Pen(Color.HotPink' 2)' p1' p2' Math.Abs(scaledradius) * 2' Math.Abs(scaledradius) * 2' cog' alpha);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawArc(new Pen(Color.HotPink' 2)' p1' p2' Math.Abs(scaledradius) * 2' Math.Abs(scaledradius) * 2' cog' alpha);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawArc(new Pen(Color.HotPink' 2)' p1' p2' Math.Abs(scaledradius) * 2' Math.Abs(scaledradius) * 2' cog' alpha);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width / -2' icon.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width / -2' icon.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon1' icon1.Width / -2' icon1.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon1' icon1.Width / -2' icon1.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon2' icon2.Width / -2' icon2.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon2' icon2.Width / -2' icon2.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: which == 2
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon3' icon3.Width / -2' icon3.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon3' icon3.Width / -2' icon3.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: which == 3
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon4' icon4.Width / -2' icon4.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon4' icon4.Width / -2' icon4.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: which == 4
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon5' icon5.Width / -2' icon5.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon5' icon5.Width / -2' icon5.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: which == 5
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon6' icon6.Width / -2' icon6.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon6' icon6.Width / -2' icon6.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerPlane.cs,OnRender,The following statement contains a magic number: which == 6
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: int length = 500;
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width/-2 + 2' icon.Height/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width/-2 + 2' icon.Height/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width/-2 + 2' icon.Height/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawString(sysid.ToString()' new Font(FontFamily.GenericMonospace' 15' FontStyle.Bold)' Brushes.Red' -8'                  -8);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawString(sysid.ToString()' new Font(FontFamily.GenericMonospace' 15' FontStyle.Bold)' Brushes.Red' -8'                  -8);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawString(sysid.ToString()' new Font(FontFamily.GenericMonospace' 15' FontStyle.Bold)' Brushes.Red' -8'                  -8);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: double width =                  (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                       Overlay.Control.FromLocalToLatLng(Overlay.Control.Width' 0)) * 1000.0);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: GPoint loc = new GPoint((int)(LocalPosition.X - (m2pixelwidth * warn * 2))' LocalPosition.Y);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pens.Orange'                          new System.Drawing.Rectangle(                              LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                              LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                              (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pens.Orange'                          new System.Drawing.Rectangle(                              LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                              LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                              (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pens.Orange'                          new System.Drawing.Rectangle(                              LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                              LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                              (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: loc = new GPoint((int)(LocalPosition.X - (m2pixelwidth * danger * 2))' LocalPosition.Y);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pens.Red'                          new System.Drawing.Rectangle(                              LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                              LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                              (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pens.Red'                          new System.Drawing.Rectangle(                              LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                              LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                              (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerQuad,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerQuad.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pens.Red'                          new System.Drawing.Rectangle(                              LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                              LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                              (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerRallyPt,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRallyPt.cs,GMapMarkerRallyPt,The following statement contains a magic number: Offset = new Point(-10' -40);
Magic Number,MissionPlanner.Maps,GMapMarkerRallyPt,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRallyPt.cs,GMapMarkerRallyPt,The following statement contains a magic number: Offset = new Point(-10' -40);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: int length = 500;
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float) Math.Cos((heading - 90)*MathHelper.deg2rad)*length'                      (float) Math.Sin((heading - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float) Math.Cos((nav_bearing - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((nav_bearing - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float) Math.Cos((nav_bearing - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((nav_bearing - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float) Math.Cos((nav_bearing - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((nav_bearing - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float) Math.Cos((cog - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((cog - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float) Math.Cos((target - 90)*MathHelper.deg2rad)*length'                  (float) Math.Sin((target - 90)*MathHelper.deg2rad)*length);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(global::MissionPlanner.Maps.Resources.rover.ToBitmap()'                  Size.Width/-2'                  Size.Height/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerRover,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRover.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(global::MissionPlanner.Maps.Resources.rover.ToBitmap()'                  Size.Width/-2'                  Size.Height/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: int length = 500;
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width / -2 + 2' icon.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width / -2 + 2' icon.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(icon' icon.Width / -2 + 2' icon.Height / -2);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawString(sysid.ToString()' new Font(FontFamily.GenericMonospace' 15' FontStyle.Bold)' Brushes.Red' -8'                  -8);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawString(sysid.ToString()' new Font(FontFamily.GenericMonospace' 15' FontStyle.Bold)' Brushes.Red' -8'                  -8);
Magic Number,MissionPlanner.Maps,GMapMarkerSingle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSingle.cs,OnRender,The following statement contains a magic number: g.DrawString(sysid.ToString()' new Font(FontFamily.GenericMonospace' 15' FontStyle.Bold)' Brushes.Red' -8'                  -8);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: int length = 500;
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Red' 2)' 0.0f' 0.0f' (float)Math.Cos((heading - 90) * MathHelper.deg2rad) * length'                      (float)Math.Sin((heading - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Green' 2)' 0.0f' 0.0f' (float)Math.Cos((nav_bearing - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((nav_bearing - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Black' 2)' 0.0f' 0.0f' (float)Math.Cos((cog - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((cog - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawLine(new Pen(Color.Orange' 2)' 0.0f' 0.0f' (float)Math.Cos((target - 90) * MathHelper.deg2rad) * length'                  (float)Math.Sin((target - 90) * MathHelper.deg2rad) * length);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(imagecache' 59/-2' 59/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(imagecache' 59/-2' 59/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(imagecache' 59/-2' 59/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerSub,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerSub.cs,OnRender,The following statement contains a magic number: g.DrawImageUnscaled(imagecache' 59/-2' 59/-2);
Magic Number,MissionPlanner.Maps,GMapMarkerWP,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerWP.cs,GMapMarkerWP,The following statement contains a magic number: Bitmap temp = new Bitmap(100'40' PixelFormat.Format32bppArgb);
Magic Number,MissionPlanner.Maps,GMapMarkerWP,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerWP.cs,GMapMarkerWP,The following statement contains a magic number: Bitmap temp = new Bitmap(100'40' PixelFormat.Format32bppArgb);
Magic Number,MissionPlanner.Maps,GMapMarkerWP,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerWP.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pens.Red' new Rectangle(this.LocalPosition' this.Size)' 0' 360);
Magic Number,MissionPlanner.Maps,GMapMarkerWP,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerWP.cs,OnRender,The following statement contains a magic number: var midw = LocalPosition.X + 10;
Magic Number,MissionPlanner.Maps,GMapMarkerWP,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerWP.cs,OnRender,The following statement contains a magic number: var midh = LocalPosition.Y + 3;
Magic Number,MissionPlanner.Maps,GMapMarkerWP,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerWP.cs,OnRender,The following statement contains a magic number: midw -= 4;
Magic Number,MissionPlanner.Maps,GMapMarkerWP,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerWP.cs,OnRender,The following statement contains a magic number: txtsize.Width > 15
Magic Number,MissionPlanner.Maps,GMapMarkerWP,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerWP.cs,OnRender,The following statement contains a magic number: Overlay.Control.Zoom> 16 || IsMouseOver
Magic Number,MissionPlanner.Maps,Japan,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan.cs,Japan,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan.cs,Japan,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_1974,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1974.cs,Japan_1974,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan_1974,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1974.cs,Japan_1974,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_1974,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1974.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 10 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_1974,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1974.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 10 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_1979,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1979.cs,Japan_1979,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan_1979,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1979.cs,Japan_1979,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_1979,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1979.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 10 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_1979,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1979.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 10 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_1984,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1984.cs,Japan_1984,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan_1984,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1984.cs,Japan_1984,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_1984,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1984.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 10 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_1984,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1984.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 10 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_1988,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1988.cs,Japan_1988,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan_1988,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1988.cs,Japan_1988,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_1988,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1988.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 10 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_1988,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_1988.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 10 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_Lake,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Lake.cs,Japan_Lake,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan_Lake,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Lake.cs,Japan_Lake,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_Lake,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Lake.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 16 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_Lake,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Lake.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 16 || zoom > 17
Magic Number,MissionPlanner.Maps,Japan_Relief,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Relief.cs,Japan_Relief,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan_Relief,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Relief.cs,Japan_Relief,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_Relief,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Relief.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 5 || zoom > 15
Magic Number,MissionPlanner.Maps,Japan_Relief,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Relief.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 5 || zoom > 15
Magic Number,MissionPlanner.Maps,Japan_Sea,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Sea.cs,Japan_Sea,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan_Sea,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Sea.cs,Japan_Sea,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_Sea,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Sea.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 14 || zoom > 16
Magic Number,MissionPlanner.Maps,Japan_Sea,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Sea.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 14 || zoom > 16
Magic Number,MissionPlanner.Maps,Japan_Slopezone,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Slopezone.cs,Japan_Slopezone,The following statement contains a magic number: MaxZoom = 22;
Magic Number,MissionPlanner.Maps,Japan_Slopezone,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Slopezone.cs,Japan_Slopezone,The following statement contains a magic number: MinZoom = 2;
Magic Number,MissionPlanner.Maps,Japan_Slopezone,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Slopezone.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 3 || zoom > 15
Magic Number,MissionPlanner.Maps,Japan_Slopezone,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Japan_Slopezone.cs,MakeTileImageUrl,The following statement contains a magic number: zoom < 3 || zoom > 15
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,Update,The following statement contains a magic number: GMapMarkerDistance home_kmleft_marker = new GMapMarkerDistance(HomeLocation' battery_kmleft * 1000.0' Settings.Instance.GetFloat("Propagation_Tolerance"));
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,Update,The following statement contains a magic number: GMapMarkerDistance drone_kmleft_marker = new GMapMarkerDistance(Location' battery_kmleft * 1000.0' Settings.Instance.GetFloat("Propagation_Tolerance"));
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Thread.Sleep(100);
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: var res = Settings.Instance.GetInt32("Propagation_Resolution"' 4);
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: var tl = gMapControl1.FromLocalToLatLng(-extend / 2' -extend / 2);
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: var tl = gMapControl1.FromLocalToLatLng(-extend / 2' -extend / 2);
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: var rb = gMapControl1.FromLocalToLatLng(width + extend / 2'                                      height + extend / 2);
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: var rb = gMapControl1.FromLocalToLatLng(width + extend / 2'                                      height + extend / 2);
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                      Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' po' y =>                                      {                                          if (zoom != gMapControl1.Zoom || center != gMapControl1.Position)                                          {                                              center = gMapControl1.Position;                                              cts.Cancel();                                          }                                            if (cts.IsCancellationRequested) return;                                          for (var x = res / 2; x < width + extend - res; x += res)                                          {                                              if (cts.IsCancellationRequested) return;                                              var lnglat = gMapControl1.FromLocalToLatLng(x - extend / 2' y - extend / 2);                                              var altresponce = srtm.getAltitude(lnglat.Lat' lnglat.Lng' zoom);                                              if (altresponce != srtm.altresponce.Invalid &&                                                  altresponce != srtm.altresponce.Ocean)                                              {                                                  alts[x' y] = altresponce.alt;                                                    if (ter_run)                                                  {                                                      if (max_alt < altresponce.alt) max_alt = altresponce.alt;                                                        if (min_alt > altresponce.alt) min_alt = altresponce.alt;                                                  }                                              }                                              else                                                  alts[x' y] = -65535;                                          }                                      });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                      Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' po' y =>                                      {                                          if (zoom != gMapControl1.Zoom || center != gMapControl1.Position)                                          {                                              center = gMapControl1.Position;                                              cts.Cancel();                                          }                                            if (cts.IsCancellationRequested) return;                                          for (var x = res / 2; x < width + extend - res; x += res)                                          {                                              if (cts.IsCancellationRequested) return;                                              var lnglat = gMapControl1.FromLocalToLatLng(x - extend / 2' y - extend / 2);                                              var altresponce = srtm.getAltitude(lnglat.Lat' lnglat.Lng' zoom);                                              if (altresponce != srtm.altresponce.Invalid &&                                                  altresponce != srtm.altresponce.Ocean)                                              {                                                  alts[x' y] = altresponce.alt;                                                    if (ter_run)                                                  {                                                      if (max_alt < altresponce.alt) max_alt = altresponce.alt;                                                        if (min_alt > altresponce.alt) min_alt = altresponce.alt;                                                  }                                              }                                              else                                                  alts[x' y] = -65535;                                          }                                      });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                      Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' po' y =>                                      {                                          if (zoom != gMapControl1.Zoom || center != gMapControl1.Position)                                          {                                              center = gMapControl1.Position;                                              cts.Cancel();                                          }                                            if (cts.IsCancellationRequested) return;                                          for (var x = res / 2; x < width + extend - res; x += res)                                          {                                              if (cts.IsCancellationRequested) return;                                              var lnglat = gMapControl1.FromLocalToLatLng(x - extend / 2' y - extend / 2);                                              var altresponce = srtm.getAltitude(lnglat.Lat' lnglat.Lng' zoom);                                              if (altresponce != srtm.altresponce.Invalid &&                                                  altresponce != srtm.altresponce.Ocean)                                              {                                                  alts[x' y] = altresponce.alt;                                                    if (ter_run)                                                  {                                                      if (max_alt < altresponce.alt) max_alt = altresponce.alt;                                                        if (min_alt > altresponce.alt) min_alt = altresponce.alt;                                                  }                                              }                                              else                                                  alts[x' y] = -65535;                                          }                                      });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                      Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' po' y =>                                      {                                          if (zoom != gMapControl1.Zoom || center != gMapControl1.Position)                                          {                                              center = gMapControl1.Position;                                              cts.Cancel();                                          }                                            if (cts.IsCancellationRequested) return;                                          for (var x = res / 2; x < width + extend - res; x += res)                                          {                                              if (cts.IsCancellationRequested) return;                                              var lnglat = gMapControl1.FromLocalToLatLng(x - extend / 2' y - extend / 2);                                              var altresponce = srtm.getAltitude(lnglat.Lat' lnglat.Lng' zoom);                                              if (altresponce != srtm.altresponce.Invalid &&                                                  altresponce != srtm.altresponce.Ocean)                                              {                                                  alts[x' y] = altresponce.alt;                                                    if (ter_run)                                                  {                                                      if (max_alt < altresponce.alt) max_alt = altresponce.alt;                                                        if (min_alt > altresponce.alt) min_alt = altresponce.alt;                                                  }                                              }                                              else                                                  alts[x' y] = -65535;                                          }                                      });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                      Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' po' y =>                                      {                                          if (zoom != gMapControl1.Zoom || center != gMapControl1.Position)                                          {                                              center = gMapControl1.Position;                                              cts.Cancel();                                          }                                            if (cts.IsCancellationRequested) return;                                          for (var x = res / 2; x < width + extend - res; x += res)                                          {                                              if (cts.IsCancellationRequested) return;                                              var lnglat = gMapControl1.FromLocalToLatLng(x - extend / 2' y - extend / 2);                                              var altresponce = srtm.getAltitude(lnglat.Lat' lnglat.Lng' zoom);                                              if (altresponce != srtm.altresponce.Invalid &&                                                  altresponce != srtm.altresponce.Ocean)                                              {                                                  alts[x' y] = altresponce.alt;                                                    if (ter_run)                                                  {                                                      if (max_alt < altresponce.alt) max_alt = altresponce.alt;                                                        if (min_alt > altresponce.alt) min_alt = altresponce.alt;                                                  }                                              }                                              else                                                  alts[x' y] = -65535;                                          }                                      });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Parallel.ForEach(                                  Extensions.SteppedRange(res / 2' height + extend + 1 - res' res)' y =>                                  {                                      for (var x = res / 2; x < width + extend - res; x += res)                                      {                                          if (!ele_enabled)                                              return;                                            if (ele_run)                                          {                                              var rel = altasl - alts[x' y];                                                var normvalue = normalize(rel);                                                /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                          else if (ter_run)                                          {                                              var normvalue = normalize(alts[x' y]);                                              /*                                              //diagonal pattern                                              for (int i = -res / 2; i <= res / 2; i++)                                              {                                                  imageData[x + i' y + i] = Gradient_byte(normvalue'colors2);                                              }                                              */                                                var gradcolor = Gradient_byte(normvalue' colors2);                                                if (alts[x' y] < -999)                                                  gradcolor = 0;                                                //Square pattern                                              for (var i = -res / 2; i <= res / 2; i++)                                              for (var j = -res / 2; j <= res / 2; j++)                                                  imageData[x + i' y + j] = gradcolor;                                          }                                      }                                  });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: gMapControl1.Invoke((Action) delegate                              {                                  LineOfSight.Polygons.Add(new GMapPolygon(pointslist.Cast<PointLatLng>().ToList()' "LOS")                                  {                                      Fill = Brushes.Transparent'                                      Stroke = new Pen(Color.White' 3) {DashStyle = DashStyle.Dash}                                  });                                    if (LineOfSight.Polygons.Count > 1) LineOfSight.Polygons.RemoveAt(0);                              });
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,elevation_calc,The following statement contains a magic number: Thread.Sleep(100);
Magic Number,MissionPlanner.Maps,Propagation,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\Propagation.cs,normalize,The following statement contains a magic number: clearance = Settings.Instance.GetFloat("Propagation_Clearance"' 5);
Magic Number,MissionPlanner.Maps,WMSProvider,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WMSProvider.cs,WMSProvider,The following statement contains a magic number: MaxZoom = 22;
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,DownloadAndUpload,The following statement contains a magic number: request.Timeout = 10000;
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,DownloadAndUpload,The following statement contains a magic number: byte[] buf1 = new byte[1024];
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,DownloadAndUpload,The following statement contains a magic number: dataStream.ReadTimeout = 30000;
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,DownloadAndUpload,The following statement contains a magic number: int len = dataStream.Read(buf1' 0' 1024);
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,UploadPX4,The following statement contains a magic number: DateTime DEADLINE = DateTime.Now.AddSeconds(30);
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,UploadPX4,The following statement contains a magic number: portUsb.BaudRate = 115200;
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,UploadPX4,The following statement contains a magic number: System.Threading.Thread.Sleep(500);
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,UploadPX4,The following statement contains a magic number: updateProgress(100' "Upload Done");
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,AttemptRebootToBootloader,The following statement contains a magic number: var task = Task.Run(() =>                     {                         portUsb.BaudRate = 115200;                         using (var up = new Uploader(portUsb))                         {                             up.identify();                             return true;                         }                          return false;                     });
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,AttemptRebootToBootloader,The following statement contains a magic number: task.Wait(TimeSpan.FromSeconds(3)) && task.Result == true
Magic Number,Xamarin.GCSViews,Firmware,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\Firmware.xaml.cs,DeviceAttached,The following statement contains a magic number: Task.Run(async () =>             {                 Parallel.ForEach(await Test.TestMethod.GetDeviceInfoList()' port =>                 {                     var portUsb = Test.TestMethod.GetUSB(port).Result;                      if (portUsb == null)                         return;                      px4uploader.Uploader up;                      try                     {                         portUsb.BaudRate = 115200;                         up = new px4uploader.Uploader(portUsb);                     }                     catch (Exception ex)                     {                         Console.WriteLine(ex.Message);                         return;                     }                      try                     {                         up.identify();                         var msg = String.Format("Found board type {0} boardrev {1} bl rev {2} fwmax {3} on {4}"'                             up.board_type'                             up.board_rev' up.bl_rev' up.fw_maxsize' port);                         log.Info(msg);                          up.close();                          //this.InvokeIfRequired(() => lbl_status.Text = msg);                         detectedport = port;                         detectedboardid = up.board_type;                     }                     catch (Exception)                     {                         Console.WriteLine("Not There..");                         up.close();                     }                 });             });
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The following statement contains a magic number: g.DrawString("Exception: " + ex.Message' MissingDataFont' Brushes.Red'                                            new RectangleF(Core.tileRect.X + 11' Core.tileRect.Y + 11'                                                Core.tileRect.Width - 11' Core.tileRect.Height - 11));
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The following statement contains a magic number: g.DrawString("Exception: " + ex.Message' MissingDataFont' Brushes.Red'                                            new RectangleF(Core.tileRect.X + 11' Core.tileRect.Y + 11'                                                Core.tileRect.Width - 11' Core.tileRect.Height - 11));
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The following statement contains a magic number: g.DrawString("Exception: " + ex.Message' MissingDataFont' Brushes.Red'                                            new RectangleF(Core.tileRect.X + 11' Core.tileRect.Y + 11'                                                Core.tileRect.Width - 11' Core.tileRect.Height - 11));
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,DrawMap,The following statement contains a magic number: g.DrawString("Exception: " + ex.Message' MissingDataFont' Brushes.Red'                                            new RectangleF(Core.tileRect.X + 11' Core.tileRect.Y + 11'                                                Core.tileRect.Width - 11' Core.tileRect.Height - 11));
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,doPaint,The following statement contains a magic number: var center = new GPoint(Width / 2' Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,doPaint,The following statement contains a magic number: var center = new GPoint(Width / 2' Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,UpdateRotationMatrix,The following statement contains a magic number: PointF center = new PointF(Core.Width / 2' Core.Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,UpdateRotationMatrix,The following statement contains a magic number: PointF center = new PointF(Core.Width / 2' Core.Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(ScalePen' -20' 0' 20' 0);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(ScalePen' -20' 0' 20' 0);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(ScalePen' 0' -20' 0' 20);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(ScalePen' 0' -20' 0' 20);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("debug build"' CopyrightFont' Brushes.Blue' 2' CopyrightFont.Height);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2 - 5' Height / 2' Width / 2 + 5' Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2 - 5' Height / 2' Width / 2 + 5' Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2 - 5' Height / 2' Width / 2 + 5' Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2 - 5' Height / 2' Width / 2 + 5' Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2 - 5' Height / 2' Width / 2 + 5' Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2 - 5' Height / 2' Width / 2 + 5' Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2' Height / 2 - 5' Width / 2' Height / 2 + 5);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2' Height / 2 - 5' Width / 2' Height / 2 + 5);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2' Height / 2 - 5' Width / 2' Height / 2 + 5);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2' Height / 2 - 5' Width / 2' Height / 2 + 5);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2' Height / 2 - 5' Width / 2' Height / 2 + 5);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawLine(CenterPen' Width / 2' Height / 2 - 5' Width / 2' Height / 2 + 5);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString(Core.provider.Copyright' CopyrightFont' Brushes.Navy' 3' Height - CopyrightFont.Height - 5);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString(Core.provider.Copyright' CopyrightFont' Brushes.Navy' 3' Height - CopyrightFont.Height - 5);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes5000km * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes5000km * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes5000km * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("5000Km"' ScaleFont' brush' (int)(Core.pxRes5000km * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("5000Km"' ScaleFont' brush' (int)(Core.pxRes5000km * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes1000km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes1000km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes1000km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("1000Km"' ScaleFont' brush' (int)(Core.pxRes1000km * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("1000Km"' ScaleFont' brush' (int)(Core.pxRes1000km * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes100km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes100km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes100km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("100Km"' ScaleFont' brush' (int)(Core.pxRes100km * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("100Km"' ScaleFont' brush' (int)(Core.pxRes100km * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: Width > Core.pxRes100km && Zoom > 2
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10'(int)( Core.pxRes10km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10'(int)( Core.pxRes10km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10'(int)( Core.pxRes10km* transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("10Km"' ScaleFont' brush' (int)(Core.pxRes10km * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("10Km"' ScaleFont' brush' (int)(Core.pxRes10km * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: Width > Core.pxRes10km && Zoom > 5
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes1000m * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes1000m * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes1000m * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("1000m"' ScaleFont' brush' (int)(Core.pxRes1000m * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("1000m"' ScaleFont' brush' (int)(Core.pxRes1000m * transform) + 10' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: Width > Core.pxRes1000m && Zoom >= 10
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes100m * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes100m * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawRectangle(ScalePen' 10' 10' (int)(Core.pxRes100m * transform)' 10);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("100m"' ScaleFont' brush' (int)(Core.pxRes100m * transform) + 9' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: g.DrawString("100m"' ScaleFont' brush' (int)(Core.pxRes100m * transform) + 9' 11);
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnPaintOverlays,The following statement contains a magic number: Width > Core.pxRes100m && Zoom > 11
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseMove,The following statement contains a magic number: Math.Abs(p.X - Core.mouseDown.X) * 2 >= DragSize.Width || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= DragSize.Height
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,OnMouseMove,The following statement contains a magic number: Math.Abs(p.X - Core.mouseDown.X) * 2 >= DragSize.Width || Math.Abs(p.Y - Core.mouseDown.Y) * 2 >= DragSize.Height
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,FromLocalToLatLng,The following statement contains a magic number: f.X += (Width - Core.vWidth) / 2;
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,FromLocalToLatLng,The following statement contains a magic number: f.Y += (Height - Core.vHeight) / 2;
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,FromLatLngToLocal,The following statement contains a magic number: f.X += (Width - Core.vWidth) / 2;
Magic Number,GMap.NET.WindowsForms,GMapControl,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapControl.cs,FromLatLngToLocal,The following statement contains a magic number: f.Y += (Height - Core.vHeight) / 2;
Magic Number,GMap.NET.WindowsForms,GMapMarker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapMarker.cs,OnRender,The following statement contains a magic number: g.FillPie(Brushes.Red' -5' -5' 10' 10' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapMarker.cs,OnRender,The following statement contains a magic number: g.FillPie(Brushes.Red' -5' -5' 10' 10' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapMarker.cs,OnRender,The following statement contains a magic number: g.FillPie(Brushes.Red' -5' -5' 10' 10' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapMarker.cs,OnRender,The following statement contains a magic number: g.FillPie(Brushes.Red' -5' -5' 10' 10' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarker,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapMarker.cs,OnRender,The following statement contains a magic number: g.FillPie(Brushes.Red' -5' -5' 10' 10' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,The following statement contains a magic number: r.IsInside(Control.Position) ||                           viewarea.Contains(r.Points[0]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.2)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.4)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.6)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.8)])
Magic Number,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,The following statement contains a magic number: r.IsInside(Control.Position) ||                           viewarea.Contains(r.Points[0]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.2)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.4)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.6)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.8)])
Magic Number,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,The following statement contains a magic number: r.IsInside(Control.Position) ||                           viewarea.Contains(r.Points[0]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.2)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.4)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.6)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.8)])
Magic Number,GMap.NET.WindowsForms,GMapOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapOverlay.cs,OnRender,The following statement contains a magic number: r.IsInside(Control.Position) ||                           viewarea.Contains(r.Points[0]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.2)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.4)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.6)]) ||                           viewarea.Contains(r.Points[(int) (r.Points.Count*0.8)])
Magic Number,GMap.NET.WindowsForms,GMapPolygon,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapPolygon.cs,OnRender,The following statement contains a magic number: maxx > ((1 << 16) - 1) || maxy > ((1 << 16) - 1)
Magic Number,GMap.NET.WindowsForms,GMapPolygon,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapPolygon.cs,OnRender,The following statement contains a magic number: maxx > ((1 << 16) - 1) || maxy > ((1 << 16) - 1)
Magic Number,GMap.NET.WindowsForms,GMapPolygon,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapPolygon.cs,OnRender,The following statement contains a magic number: graphicsPath.PointCount > 1000
Magic Number,GMap.NET.WindowsForms,GMapPolygon,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapPolygon.cs,GMapPolygon,The following statement contains a magic number: DefaultStroke.Width = 5;
Magic Number,GMap.NET.WindowsForms,GMapPolygon,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapPolygon.cs,IsInside,The following statement contains a magic number: count < 3
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: graphicsPath.PointCount > 400
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: double deg2rad = Math.PI / 180.0;
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: double r = Math.Sqrt(Math.Pow(polx' 2) + Math.Pow(poly' 2));
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: double r = Math.Sqrt(Math.Pow(polx' 2) + Math.Pow(poly' 2));
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: r <= 20
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: float midx = polx / 2;
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: float midy = poly / 2;
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: double leftangle = angle + 210 * deg2rad;
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: double rightangle = angle - 210 * deg2rad;
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,OnRender,The following statement contains a magic number: float length = 15;
Magic Number,GMap.NET.WindowsForms,GMapRoute,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapRoute.cs,GMapRoute,The following statement contains a magic number: DefaultStroke.Width = 5;
Magic Number,GMap.NET.WindowsForms,GMapToolTip,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapToolTip.cs,GMapToolTip,The following statement contains a magic number: DefaultStroke.Width = 2;
Magic Number,GMap.NET.WindowsForms,GMapToolTip,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapToolTip.cs,GMapToolTip,The following statement contains a magic number: this.Offset = new Point(14' -44);
Magic Number,GMap.NET.WindowsForms,GMapToolTip,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapToolTip.cs,GMapToolTip,The following statement contains a magic number: this.Offset = new Point(14' -44);
Magic Number,GMap.NET.WindowsForms,GMapToolTip,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapToolTip.cs,OnRender,The following statement contains a magic number: g.DrawLine(Stroke' Marker.ToolTipPosition.X' Marker.ToolTipPosition.Y' rect.X' rect.Y + rect.Height / 2);
Magic Number,GMap.NET.WindowsForms,GMapToolTip,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapToolTip.cs,GMapToolTip,The following statement contains a magic number: this.TextPadding = Extensions.GetStruct<Size>(info' "TextPadding"' new Size(10' 10));
Magic Number,GMap.NET.WindowsForms,GMapToolTip,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\GMapToolTip.cs,GMapToolTip,The following statement contains a magic number: this.TextPadding = Extensions.GetStruct<Size>(info' "TextPadding"' new Size(10' 10));
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,GMapMarkerRect,The following statement contains a magic number: Size = new System.Drawing.Size(50' 50);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,GMapMarkerRect,The following statement contains a magic number: Size = new System.Drawing.Size(50' 50);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,GMapMarkerRect,The following statement contains a magic number: Offset = new System.Drawing.Point(-Size.Width/2' -Size.Height/2 - 20);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,GMapMarkerRect,The following statement contains a magic number: Offset = new System.Drawing.Point(-Size.Width/2' -Size.Height/2 - 20);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,GMapMarkerRect,The following statement contains a magic number: Offset = new System.Drawing.Point(-Size.Width/2' -Size.Height/2 - 20);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: double width =              (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                   Overlay.Control.FromLocalToLatLng(Overlay.Control.Width' 0))*1000.0);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: double height =              (Overlay.Control.MapProvider.Projection.GetDistance(Overlay.Control.FromLocalToLatLng(0' 0)'                   Overlay.Control.FromLocalToLatLng(Overlay.Control.Height' 0))*1000.0);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: GPoint loc = new GPoint((int) (LocalPosition.X - (m2pixelwidth*wprad*2))' LocalPosition.Y);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pen'                      new System.Drawing.Rectangle(                          LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                          LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                          (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pen'                      new System.Drawing.Rectangle(                          LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                          LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                          (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: g.DrawArc(Pen'                      new System.Drawing.Rectangle(                          LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                          LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                          (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: g.FillPie(new SolidBrush(FillColor.Value)' new System.Drawing.Rectangle(                                  LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                                  LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                                  (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: g.FillPie(new SolidBrush(FillColor.Value)' new System.Drawing.Rectangle(                                  LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                                  LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                                  (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: g.FillPie(new SolidBrush(FillColor.Value)' new System.Drawing.Rectangle(                                  LocalPosition.X - Offset.X - (int)(Math.Abs(loc.X - LocalPosition.X) / 2)'                                  LocalPosition.Y - Offset.Y - (int)Math.Abs(loc.X - LocalPosition.X) / 2'                                  (int)Math.Abs(loc.X - LocalPosition.X)' (int)Math.Abs(loc.X - LocalPosition.X))' 0' 360);
Magic Number,GMap.NET.WindowsForms,GMapMarkerRect,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerRect.cs,OnRender,The following statement contains a magic number: m2pixelheight > 0.5 && !double.IsInfinity(m2pixelheight)
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerCross,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerCross.cs,OnRender,The following statement contains a magic number: p1.Offset(0' -10);
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerCross,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerCross.cs,OnRender,The following statement contains a magic number: p2.Offset(0' 10);
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerCross,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerCross.cs,OnRender,The following statement contains a magic number: p3.Offset(-10' 0);
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerCross,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerCross.cs,OnRender,The following statement contains a magic number: p4.Offset(10' 0);
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,LoadBitmap,The following statement contains a magic number: switch(Type)           {              case GMarkerGoogleType.arrow:              {                 Offset = new Point(-11' -Size.Height);                   if(arrowshadow == null)                 {                    arrowshadow = Resources.arrowshadow.ToBitmap();                 }                 BitmapShadow = arrowshadow;              }              break;                case GMarkerGoogleType.blue:              case GMarkerGoogleType.blue_dot:              case GMarkerGoogleType.green:              case GMarkerGoogleType.green_dot:              case GMarkerGoogleType.yellow:              case GMarkerGoogleType.yellow_dot:              case GMarkerGoogleType.lightblue:              case GMarkerGoogleType.lightblue_dot:              case GMarkerGoogleType.orange:              case GMarkerGoogleType.orange_dot:              case GMarkerGoogleType.pink:              case GMarkerGoogleType.pink_dot:              case GMarkerGoogleType.purple:              case GMarkerGoogleType.purple_dot:              case GMarkerGoogleType.red:              case GMarkerGoogleType.red_dot:              {                 Offset = new Point(-Size.Width / 2 + 1' -Size.Height + 1);                   if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.black_small:              case GMarkerGoogleType.blue_small:              case GMarkerGoogleType.brown_small:              case GMarkerGoogleType.gray_small:              case GMarkerGoogleType.green_small:              case GMarkerGoogleType.yellow_small:              case GMarkerGoogleType.orange_small:              case GMarkerGoogleType.purple_small:              case GMarkerGoogleType.red_small:              case GMarkerGoogleType.white_small:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                   if(shadow_small == null)                 {                    shadow_small = Resources.shadow_small.ToBitmap();                 }                 BitmapShadow = shadow_small;              }              break;                case GMarkerGoogleType.green_big_go:              case GMarkerGoogleType.yellow_big_pause:              case GMarkerGoogleType.red_big_stop:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                 if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.blue_pushpin:              case GMarkerGoogleType.green_pushpin:              case GMarkerGoogleType.yellow_pushpin:              case GMarkerGoogleType.lightblue_pushpin:              case GMarkerGoogleType.pink_pushpin:              case GMarkerGoogleType.purple_pushpin:              case GMarkerGoogleType.red_pushpin:              {                 Offset = new Point(-9' -Size.Height + 1);                   if(pushpin_shadow == null)                 {                    pushpin_shadow = Resources.pushpin_shadow.ToBitmap();                 }                 BitmapShadow = pushpin_shadow;              }              break;           }
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,LoadBitmap,The following statement contains a magic number: switch(Type)           {              case GMarkerGoogleType.arrow:              {                 Offset = new Point(-11' -Size.Height);                   if(arrowshadow == null)                 {                    arrowshadow = Resources.arrowshadow.ToBitmap();                 }                 BitmapShadow = arrowshadow;              }              break;                case GMarkerGoogleType.blue:              case GMarkerGoogleType.blue_dot:              case GMarkerGoogleType.green:              case GMarkerGoogleType.green_dot:              case GMarkerGoogleType.yellow:              case GMarkerGoogleType.yellow_dot:              case GMarkerGoogleType.lightblue:              case GMarkerGoogleType.lightblue_dot:              case GMarkerGoogleType.orange:              case GMarkerGoogleType.orange_dot:              case GMarkerGoogleType.pink:              case GMarkerGoogleType.pink_dot:              case GMarkerGoogleType.purple:              case GMarkerGoogleType.purple_dot:              case GMarkerGoogleType.red:              case GMarkerGoogleType.red_dot:              {                 Offset = new Point(-Size.Width / 2 + 1' -Size.Height + 1);                   if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.black_small:              case GMarkerGoogleType.blue_small:              case GMarkerGoogleType.brown_small:              case GMarkerGoogleType.gray_small:              case GMarkerGoogleType.green_small:              case GMarkerGoogleType.yellow_small:              case GMarkerGoogleType.orange_small:              case GMarkerGoogleType.purple_small:              case GMarkerGoogleType.red_small:              case GMarkerGoogleType.white_small:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                   if(shadow_small == null)                 {                    shadow_small = Resources.shadow_small.ToBitmap();                 }                 BitmapShadow = shadow_small;              }              break;                case GMarkerGoogleType.green_big_go:              case GMarkerGoogleType.yellow_big_pause:              case GMarkerGoogleType.red_big_stop:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                 if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.blue_pushpin:              case GMarkerGoogleType.green_pushpin:              case GMarkerGoogleType.yellow_pushpin:              case GMarkerGoogleType.lightblue_pushpin:              case GMarkerGoogleType.pink_pushpin:              case GMarkerGoogleType.purple_pushpin:              case GMarkerGoogleType.red_pushpin:              {                 Offset = new Point(-9' -Size.Height + 1);                   if(pushpin_shadow == null)                 {                    pushpin_shadow = Resources.pushpin_shadow.ToBitmap();                 }                 BitmapShadow = pushpin_shadow;              }              break;           }
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,LoadBitmap,The following statement contains a magic number: switch(Type)           {              case GMarkerGoogleType.arrow:              {                 Offset = new Point(-11' -Size.Height);                   if(arrowshadow == null)                 {                    arrowshadow = Resources.arrowshadow.ToBitmap();                 }                 BitmapShadow = arrowshadow;              }              break;                case GMarkerGoogleType.blue:              case GMarkerGoogleType.blue_dot:              case GMarkerGoogleType.green:              case GMarkerGoogleType.green_dot:              case GMarkerGoogleType.yellow:              case GMarkerGoogleType.yellow_dot:              case GMarkerGoogleType.lightblue:              case GMarkerGoogleType.lightblue_dot:              case GMarkerGoogleType.orange:              case GMarkerGoogleType.orange_dot:              case GMarkerGoogleType.pink:              case GMarkerGoogleType.pink_dot:              case GMarkerGoogleType.purple:              case GMarkerGoogleType.purple_dot:              case GMarkerGoogleType.red:              case GMarkerGoogleType.red_dot:              {                 Offset = new Point(-Size.Width / 2 + 1' -Size.Height + 1);                   if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.black_small:              case GMarkerGoogleType.blue_small:              case GMarkerGoogleType.brown_small:              case GMarkerGoogleType.gray_small:              case GMarkerGoogleType.green_small:              case GMarkerGoogleType.yellow_small:              case GMarkerGoogleType.orange_small:              case GMarkerGoogleType.purple_small:              case GMarkerGoogleType.red_small:              case GMarkerGoogleType.white_small:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                   if(shadow_small == null)                 {                    shadow_small = Resources.shadow_small.ToBitmap();                 }                 BitmapShadow = shadow_small;              }              break;                case GMarkerGoogleType.green_big_go:              case GMarkerGoogleType.yellow_big_pause:              case GMarkerGoogleType.red_big_stop:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                 if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.blue_pushpin:              case GMarkerGoogleType.green_pushpin:              case GMarkerGoogleType.yellow_pushpin:              case GMarkerGoogleType.lightblue_pushpin:              case GMarkerGoogleType.pink_pushpin:              case GMarkerGoogleType.purple_pushpin:              case GMarkerGoogleType.red_pushpin:              {                 Offset = new Point(-9' -Size.Height + 1);                   if(pushpin_shadow == null)                 {                    pushpin_shadow = Resources.pushpin_shadow.ToBitmap();                 }                 BitmapShadow = pushpin_shadow;              }              break;           }
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,LoadBitmap,The following statement contains a magic number: switch(Type)           {              case GMarkerGoogleType.arrow:              {                 Offset = new Point(-11' -Size.Height);                   if(arrowshadow == null)                 {                    arrowshadow = Resources.arrowshadow.ToBitmap();                 }                 BitmapShadow = arrowshadow;              }              break;                case GMarkerGoogleType.blue:              case GMarkerGoogleType.blue_dot:              case GMarkerGoogleType.green:              case GMarkerGoogleType.green_dot:              case GMarkerGoogleType.yellow:              case GMarkerGoogleType.yellow_dot:              case GMarkerGoogleType.lightblue:              case GMarkerGoogleType.lightblue_dot:              case GMarkerGoogleType.orange:              case GMarkerGoogleType.orange_dot:              case GMarkerGoogleType.pink:              case GMarkerGoogleType.pink_dot:              case GMarkerGoogleType.purple:              case GMarkerGoogleType.purple_dot:              case GMarkerGoogleType.red:              case GMarkerGoogleType.red_dot:              {                 Offset = new Point(-Size.Width / 2 + 1' -Size.Height + 1);                   if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.black_small:              case GMarkerGoogleType.blue_small:              case GMarkerGoogleType.brown_small:              case GMarkerGoogleType.gray_small:              case GMarkerGoogleType.green_small:              case GMarkerGoogleType.yellow_small:              case GMarkerGoogleType.orange_small:              case GMarkerGoogleType.purple_small:              case GMarkerGoogleType.red_small:              case GMarkerGoogleType.white_small:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                   if(shadow_small == null)                 {                    shadow_small = Resources.shadow_small.ToBitmap();                 }                 BitmapShadow = shadow_small;              }              break;                case GMarkerGoogleType.green_big_go:              case GMarkerGoogleType.yellow_big_pause:              case GMarkerGoogleType.red_big_stop:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                 if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.blue_pushpin:              case GMarkerGoogleType.green_pushpin:              case GMarkerGoogleType.yellow_pushpin:              case GMarkerGoogleType.lightblue_pushpin:              case GMarkerGoogleType.pink_pushpin:              case GMarkerGoogleType.purple_pushpin:              case GMarkerGoogleType.red_pushpin:              {                 Offset = new Point(-9' -Size.Height + 1);                   if(pushpin_shadow == null)                 {                    pushpin_shadow = Resources.pushpin_shadow.ToBitmap();                 }                 BitmapShadow = pushpin_shadow;              }              break;           }
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,LoadBitmap,The following statement contains a magic number: switch(Type)           {              case GMarkerGoogleType.arrow:              {                 Offset = new Point(-11' -Size.Height);                   if(arrowshadow == null)                 {                    arrowshadow = Resources.arrowshadow.ToBitmap();                 }                 BitmapShadow = arrowshadow;              }              break;                case GMarkerGoogleType.blue:              case GMarkerGoogleType.blue_dot:              case GMarkerGoogleType.green:              case GMarkerGoogleType.green_dot:              case GMarkerGoogleType.yellow:              case GMarkerGoogleType.yellow_dot:              case GMarkerGoogleType.lightblue:              case GMarkerGoogleType.lightblue_dot:              case GMarkerGoogleType.orange:              case GMarkerGoogleType.orange_dot:              case GMarkerGoogleType.pink:              case GMarkerGoogleType.pink_dot:              case GMarkerGoogleType.purple:              case GMarkerGoogleType.purple_dot:              case GMarkerGoogleType.red:              case GMarkerGoogleType.red_dot:              {                 Offset = new Point(-Size.Width / 2 + 1' -Size.Height + 1);                   if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.black_small:              case GMarkerGoogleType.blue_small:              case GMarkerGoogleType.brown_small:              case GMarkerGoogleType.gray_small:              case GMarkerGoogleType.green_small:              case GMarkerGoogleType.yellow_small:              case GMarkerGoogleType.orange_small:              case GMarkerGoogleType.purple_small:              case GMarkerGoogleType.red_small:              case GMarkerGoogleType.white_small:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                   if(shadow_small == null)                 {                    shadow_small = Resources.shadow_small.ToBitmap();                 }                 BitmapShadow = shadow_small;              }              break;                case GMarkerGoogleType.green_big_go:              case GMarkerGoogleType.yellow_big_pause:              case GMarkerGoogleType.red_big_stop:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                 if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.blue_pushpin:              case GMarkerGoogleType.green_pushpin:              case GMarkerGoogleType.yellow_pushpin:              case GMarkerGoogleType.lightblue_pushpin:              case GMarkerGoogleType.pink_pushpin:              case GMarkerGoogleType.purple_pushpin:              case GMarkerGoogleType.red_pushpin:              {                 Offset = new Point(-9' -Size.Height + 1);                   if(pushpin_shadow == null)                 {                    pushpin_shadow = Resources.pushpin_shadow.ToBitmap();                 }                 BitmapShadow = pushpin_shadow;              }              break;           }
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,GMarkerGoogle,The following statement contains a magic number: Offset = new Point(-Size.Width / 2' -Size.Height);
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,OnRender,The following statement contains a magic number: Math.Abs(LocalPosition.X) > 100000 || Math.Abs(LocalPosition.Y) > 100000
Magic Number,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,OnRender,The following statement contains a magic number: Math.Abs(LocalPosition.X) > 100000 || Math.Abs(LocalPosition.Y) > 100000
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,listernforclients,The following statement contains a magic number: listener = new TcpListener(IPAddress.Any' 56781);
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The following statement contains a magic number: stream.ReadTimeout = 5000;
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The following statement contains a magic number: var request = new byte[1024*4];
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The following statement contains a magic number: var request = new byte[1024*4];
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The following statement contains a magic number: int start = head.IndexOf("Sec-WebSocket-Key:") + 19;
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The following statement contains a magic number: byte[] packet = new byte[1024 * 32];
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The following statement contains a magic number: byte[] packet = new byte[1024 * 32];
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The following statement contains a magic number: tosend <= 125
Magic Number,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The following statement contains a magic number: Thread.Sleep(200);
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: int minbytes = 10;
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: Settings.Instance.GetBoolean("speechbatteryenabled") == true &&                              MainV2.comPort.MAV.cs.battery_voltage <= warnvolt &&                              MainV2.comPort.MAV.cs.battery_voltage >= 5.0
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: speechEnable && speechEngine != null && (DateTime.Now - speechcustomtime).TotalSeconds > 30 &&                          (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: speechEnable && speechEngine != null && (DateTime.Now - speechlowspeedtime).TotalSeconds > 10 &&                          (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: MainV2.comPort.MAV.cs.linkqualitygcs = (ushort)(MainV2.comPort.MAV.cs.linkqualitygcs * 0.8f);
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: (DateTime.Now - MainV2.comPort.MAV.lastvalidpacket).TotalSeconds > 10                          && (DateTime.Now - connecttime).TotalSeconds > 30                          && (DateTime.Now - nodatawarning).TotalSeconds > 5                          && (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)                          && MainV2.comPort.MAV.cs.armed
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: (DateTime.Now - MainV2.comPort.MAV.lastvalidpacket).TotalSeconds > 10                          && (DateTime.Now - connecttime).TotalSeconds > 30                          && (DateTime.Now - nodatawarning).TotalSeconds > 5                          && (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)                          && MainV2.comPort.MAV.cs.armed
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: (DateTime.Now - MainV2.comPort.MAV.lastvalidpacket).TotalSeconds > 10                          && (DateTime.Now - connecttime).TotalSeconds > 30                          && (DateTime.Now - nodatawarning).TotalSeconds > 5                          && (MainV2.comPort.logreadmode || comPort.BaseStream.IsOpen)                          && MainV2.comPort.MAV.cs.armed
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: System.Threading.ThreadPool.QueueUserWorkItem(state =>                              {                                  Thread.CurrentThread.Name = "Arm State change";                                  try                                  {                                      while (comPort.giveComport == true)                                          Thread.Sleep(100);                                        MainV2.comPort.MAV.cs.HomeLocation = new PointLatLngAlt(MainV2.comPort.getWP(0));                                                               }                                  catch                                  {                                      // dont hang this loop                                                                 }                              });
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: MAVLink.mavlink_heartbeat_t htb = new MAVLink.mavlink_heartbeat_t()                          {                              type = (byte)MAVLink.MAV_TYPE.GCS'                              autopilot = (byte)MAVLink.MAV_AUTOPILOT.INVALID'                              mavlink_version = 3 // MAVLink.MAVLINK_VERSION                          };
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: !port.giveComport && !MAV.cs.armed && (DateTime.Now.Second % 20) == 0 && MAV.cs.version < new Version(0' 1)
Magic Number,MissionPlanner.Utilities,MainV2,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\MainV2.cs,SerialReader,The following statement contains a magic number: System.Threading.Thread.Sleep(100);
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,CreateOverlay,The following statement contains a magic number: double maxlat = -180;
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,CreateOverlay,The following statement contains a magic number: double maxlong = -180;
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,CreateOverlay,The following statement contains a magic number: double minlat = 180;
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,CreateOverlay,The following statement contains a magic number: double minlong = 180;
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,GetHomeAlt,The following statement contains a magic number: return -999;
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,RegenerateWPRoute,The following statement contains a magic number: wproute.ForEach(x =>                  {                      counter++;                      if (counter == 1)                      {                          homepoint = x;                          return;                      }                      if (counter == 2)                      {                          firstpoint = x;                      }                      if (counter == count - 1)                      {                          lastpoint = x;                      }                      if (counter == count)                      {                          homeroute.Points.Add(lastpoint);                          homeroute.Points.Add(homepoint);                          homeroute.Points.Add(firstpoint);                          return;                      }                      route.Points.Add(x);                  });
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,RegenerateWPRoute,The following statement contains a magic number: homeroute.Stroke = new Pen(Color.Yellow' 2);
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,RegenerateWPRoute,The following statement contains a magic number: homepoint.GetDistance(lastpoint) < 5000 && homepoint.GetDistance(firstpoint) < 5000
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,RegenerateWPRoute,The following statement contains a magic number: homepoint.GetDistance(lastpoint) < 5000 && homepoint.GetDistance(firstpoint) < 5000
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,RegenerateWPRoute,The following statement contains a magic number: route.Stroke = new Pen(Color.Yellow' 4);
Magic Number,MissionPlanner.ArduPilot,WPOverlay,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\WPOverlay.cs,RegenerateWPRoute,The following statement contains a magic number: count > 2
Magic Number,MissionPlanner.test,FirmwareSelection,D:\research\architectureSmells\repos\diydrones_MissionPlanner\test\FirmwareSelection.xaml.cs,FirmwareSelection,The following statement contains a magic number: versiontype.Items.Count == 2
Magic Number,MissionPlanner.test,FirmwareSelection,D:\research\architectureSmells\repos\diydrones_MissionPlanner\test\FirmwareSelection.xaml.cs,FirmwareSelection,The following statement contains a magic number: version.Items.Count == 2
Magic Number,MissionPlanner.test,FirmwareSelection,D:\research\architectureSmells\repos\diydrones_MissionPlanner\test\FirmwareSelection.xaml.cs,FirmwareSelection,The following statement contains a magic number: this.HeightRequest = Button.Y + Button.Height + 20;
Magic Number,MissionPlanner.test,FirmwareSelection,D:\research\architectureSmells\repos\diydrones_MissionPlanner\test\FirmwareSelection.xaml.cs,OnSelectedIndexChanged,The following statement contains a magic number: FWList.Count() < 100
Duplicate Code,MissionPlanner.Utilities,httpserver,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Linked\httpserver.cs,ProcessClient,The method contains a code clone-set at the following line numbers (starting from the method definition): ((479' 508)' (515' 544))
Missing Default,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,FlightData,The following switch statement is missing a default case: switch (Forms.Device.RuntimePlatform)              {                  case Device.Android:                      //myhud.IgnorePixelScaling = true;                      break;              }
Missing Default,Xamarin,FlightData,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GCSViews\FlightData.xaml.cs,mainloop,The following switch statement is missing a default case: switch (plla.ThreatLevel)                                      {                                          case MAVLink.MAV_COLLISION_THREAT_LEVEL.NONE:                                              adsbplane.AlertLevel = GMapMarkerADSBPlane.AlertLevelOptions.Green;                                              break;                                          case MAVLink.MAV_COLLISION_THREAT_LEVEL.LOW:                                              adsbplane.AlertLevel = GMapMarkerADSBPlane.AlertLevelOptions.Orange;                                              break;                                          case MAVLink.MAV_COLLISION_THREAT_LEVEL.HIGH:                                              adsbplane.AlertLevel = GMapMarkerADSBPlane.AlertLevelOptions.Red;                                              break;                                      }
Missing Default,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following switch statement is missing a default case: switch (BackgroundImageLayout)                          {                              case ImageLayout.Center:                                  ggr.DrawImageUnscaled(BackgroundImage' Width/2 - BackgroundImage.Width/2'                                      Height/2 - BackgroundImage.Height/2);                                  break;                              case ImageLayout.None:                                  ggr.DrawImageUnscaled(BackgroundImage' 0' 0);                                  break;                              case ImageLayout.Stretch:                                  ggr.DrawImage(BackgroundImage' 0' 0' Width' Height);                                  break;                              case ImageLayout.Tile:                                  Int32 pixelOffsetX = 0;                                  Int32 pixelOffsetY = 0;                                  while (pixelOffsetX < Width)                                  {                                      pixelOffsetY = 0;                                      while (pixelOffsetY < Height)                                      {                                          ggr.DrawImageUnscaled(BackgroundImage' pixelOffsetX' pixelOffsetY);                                          pixelOffsetY += BackgroundImage.Height;                                      }                                      pixelOffsetX += BackgroundImage.Width;                                  }                                  break;                              case ImageLayout.Zoom:                                  if ((BackgroundImage.Width/Width) < (BackgroundImage.Height/Height))                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Height' Height);                                  }                                  else                                  {                                      ggr.DrawImage(BackgroundImage' 0' 0' Width' Width);                                  }                                  break;                          }
Missing Default,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following switch statement is missing a default case: switch (m_NeedleType[m_NeedIdx])                  {                      case 0:                          PointF[] points = new PointF[3];                          Brush brush1 = Brushes.White;                          Brush brush2 = Brushes.White;                          Brush brush3 = Brushes.White;                          Brush brush4 = Brushes.White;                            Brush brushBucket = Brushes.White;                          Int32 subcol = (Int32)(((brushAngle + 225) % 180) * 100 / 180);                          Int32 subcol2 = (Int32)(((brushAngle + 135) % 180) * 100 / 180);                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                          switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }                            if (Math.Floor((Single)(((brushAngle + 225) % 360) / 180.0)) == 0)                          {                              brushBucket = brush1;                              brush1 = brush2;                              brush2 = brushBucket;                          }                            if (Math.Floor((Single)(((brushAngle + 135) % 360) / 180.0)) == 0)                          {                              brush4 = brush3;                          }                            points[0].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          pe.Graphics.FillPolygon(brush1' points);                            points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush2' points);                            points[0].X = (Single)(Center.X - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - (m_NeedleRadius[m_NeedIdx] / 20 - 1) * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle + Math.PI / 2));                          points[1].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle + Math.PI / 2));                          points[2].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 5 * Math.Cos(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Cos(needleAngle - Math.PI / 2));                          points[2].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 5 * Math.Sin(needleAngle) + m_NeedleWidth[m_NeedIdx] * 2 * Math.Sin(needleAngle - Math.PI / 2));                          pe.Graphics.FillPolygon(brush4' points);                            points[0].X = (Single)(Center.X - m_NeedleRadius[m_NeedIdx] / 20 * Math.Cos(needleAngle));                          points[0].Y = (Single)(Center.Y - m_NeedleRadius[m_NeedIdx] / 20 * Math.Sin(needleAngle));                          points[1].X = (Single)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle));                          points[1].Y = (Single)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle));                            pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[0].X' points[0].Y);                          pe.Graphics.DrawLine(new Pen(m_NeedleColor2[m_NeedIdx])' Center.X' Center.Y' points[1].X' points[1].Y);                            brush1.Dispose();                          brush2.Dispose();                          brush3.Dispose();                          brush4.Dispose();                            break;                      case 1:                          Point startPoint = new Point((Int32)(Center.X - m_NeedleRadius[m_NeedIdx] / 8 * Math.Cos(needleAngle))'                                                     (Int32)(Center.Y - m_NeedleRadius[m_NeedIdx] / 8 * Math.Sin(needleAngle)));                          Point endPoint = new Point((Int32)(Center.X + m_NeedleRadius[m_NeedIdx] * Math.Cos(needleAngle))'                                                   (Int32)(Center.Y + m_NeedleRadius[m_NeedIdx] * Math.Sin(needleAngle)));                            pe.Graphics.FillEllipse(new SolidBrush(m_NeedleColor2[m_NeedIdx])' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                            switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }                          break;                  }
Missing Default,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following switch statement is missing a default case: switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  brush1 = new SolidBrush(Color.FromArgb(80 + subcol' 80 + subcol' 80 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(180 - subcol' 180 - subcol' 180 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255' ((80 + subcol2) + 255) % 255));                                  brush4 = new SolidBrush(Color.FromArgb(((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255' ((180 - subcol2) + 255) % 255));                                  pe.Graphics.DrawEllipse(Pens.Gray' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Red:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Red' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Green:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Green' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Blue:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Blue' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Magenta:                                  brush1 = new SolidBrush(Color.FromArgb(subcol' 145 + subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(100 - subcol' 245 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(subcol2' 145 + subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(100 - subcol2' 245 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Magenta' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Violet:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' subcol' 145 + subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 100 - subcol' 245 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' subcol2' 145 + subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 100 - subcol2' 245 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                              case NeedleColorEnum.Yellow:                                  brush1 = new SolidBrush(Color.FromArgb(145 + subcol' 145 + subcol' subcol));                                  brush2 = new SolidBrush(Color.FromArgb(245 - subcol' 245 - subcol' 100 - subcol));                                  brush3 = new SolidBrush(Color.FromArgb(145 + subcol2' 145 + subcol2' subcol2));                                  brush4 = new SolidBrush(Color.FromArgb(245 - subcol2' 245 - subcol2' 100 - subcol2));                                  pe.Graphics.DrawEllipse(Pens.Violet' Center.X - m_NeedleWidth[m_NeedIdx] * 3' Center.Y - m_NeedleWidth[m_NeedIdx] * 3' m_NeedleWidth[m_NeedIdx] * 6' m_NeedleWidth[m_NeedIdx] * 6);                                  break;                          }
Missing Default,MissionPlanner.Controls,AGauge,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\AGauge.cs,OnPaint,The following switch statement is missing a default case: switch (m_NeedleColor1[m_NeedIdx])                          {                              case NeedleColorEnum.Gray:                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.DarkGray' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Red:                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Red' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Green:                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Green' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Blue:                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Blue' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Magenta:                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Magenta' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Violet:                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Violet' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                              case NeedleColorEnum.Yellow:                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' endPoint.X' endPoint.Y);                                  pe.Graphics.DrawLine(new Pen(Color.Yellow' m_NeedleWidth[m_NeedIdx])' Center.X' Center.Y' startPoint.X' startPoint.Y);                                  break;                          }
Missing Default,Xamarin.Controls,MySKCanvasView,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Controls\MySKCanvasView.cs,OnTouch,The following switch statement is missing a default case: switch (e.ActionType)             {                 case SKTouchAction.Pressed:                     // start of a stroke                     var p = new SKPath();                     p.MoveTo(e.Location);                     temporaryPaths[e.Id] = p;                     Invalidate();                     break;                 case SKTouchAction.Moved:                     // the stroke' while pressed                     if (e.InContact && temporaryPaths.ContainsKey(e.Id))                         temporaryPaths[e.Id].LineTo(e.Location);                     break;                 case SKTouchAction.Released:                     // end of a stroke                     //paths.Add(temporaryPaths[e.Id]);                     temporaryPaths.Remove(e.Id);                     Invalidate();                     break;                 case SKTouchAction.Cancelled:                     // we don't want that stroke                     temporaryPaths.Remove(e.Id);                     break;             }
Missing Default,MissionPlanner.Maps,GMapMarkerADSBPlane,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\Maps\GMapMarkerADSBPlane.cs,OnRender,The following switch statement is missing a default case: switch (AlertLevel)              {                  case AlertLevelOptions.Green:                      g.DrawImageUnscaled(icong' icong.Width/-2' icong.Height/-2);                      break;                  case AlertLevelOptions.Orange:                      g.DrawImageUnscaled(icono' icono.Width/-2' icono.Height/-2);                      break;                  case AlertLevelOptions.Red:                      g.DrawImageUnscaled(iconr' iconr.Width/-2' iconr.Height/-2);                      break;              }
Missing Default,GMap.NET.WindowsForms.Markers,GMarkerGoogle,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\Xamarin\Xamarin\GMap.NET.WindowsForms\Markers\GMarkerGoogle.cs,LoadBitmap,The following switch statement is missing a default case: switch(Type)           {              case GMarkerGoogleType.arrow:              {                 Offset = new Point(-11' -Size.Height);                   if(arrowshadow == null)                 {                    arrowshadow = Resources.arrowshadow.ToBitmap();                 }                 BitmapShadow = arrowshadow;              }              break;                case GMarkerGoogleType.blue:              case GMarkerGoogleType.blue_dot:              case GMarkerGoogleType.green:              case GMarkerGoogleType.green_dot:              case GMarkerGoogleType.yellow:              case GMarkerGoogleType.yellow_dot:              case GMarkerGoogleType.lightblue:              case GMarkerGoogleType.lightblue_dot:              case GMarkerGoogleType.orange:              case GMarkerGoogleType.orange_dot:              case GMarkerGoogleType.pink:              case GMarkerGoogleType.pink_dot:              case GMarkerGoogleType.purple:              case GMarkerGoogleType.purple_dot:              case GMarkerGoogleType.red:              case GMarkerGoogleType.red_dot:              {                 Offset = new Point(-Size.Width / 2 + 1' -Size.Height + 1);                   if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.black_small:              case GMarkerGoogleType.blue_small:              case GMarkerGoogleType.brown_small:              case GMarkerGoogleType.gray_small:              case GMarkerGoogleType.green_small:              case GMarkerGoogleType.yellow_small:              case GMarkerGoogleType.orange_small:              case GMarkerGoogleType.purple_small:              case GMarkerGoogleType.red_small:              case GMarkerGoogleType.white_small:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                   if(shadow_small == null)                 {                    shadow_small = Resources.shadow_small.ToBitmap();                 }                 BitmapShadow = shadow_small;              }              break;                case GMarkerGoogleType.green_big_go:              case GMarkerGoogleType.yellow_big_pause:              case GMarkerGoogleType.red_big_stop:              {                 Offset = new Point(-Size.Width / 2' -Size.Height + 1);                 if(msmarker_shadow == null)                 {                    msmarker_shadow = Resources.msmarker_shadow.ToBitmap();                 }                 BitmapShadow = msmarker_shadow;              }              break;                case GMarkerGoogleType.blue_pushpin:              case GMarkerGoogleType.green_pushpin:              case GMarkerGoogleType.yellow_pushpin:              case GMarkerGoogleType.lightblue_pushpin:              case GMarkerGoogleType.pink_pushpin:              case GMarkerGoogleType.purple_pushpin:              case GMarkerGoogleType.red_pushpin:              {                 Offset = new Point(-9' -Size.Height + 1);                   if(pushpin_shadow == null)                 {                    pushpin_shadow = Resources.pushpin_shadow.ToBitmap();                 }                 BitmapShadow = pushpin_shadow;              }              break;           }
