Implementation smell,Namespace,Class,File,Method,Description
Long Method,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The method has 102 lines of code.
Complex Method,MissionPlanner.Comms,CommsFile,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsFile.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,Cyclomatic complexity of the method is 10
Complex Method,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Open,Cyclomatic complexity of the method is 8
Long Parameter List,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' securityAttrs' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,DeviceIoControl,The method has 8 parameters. Parameters: hDevice' dwIoControlCode' lpInBuffer' nInBufferSize' lpOutBuffer' nOutBufferSize' lpBytesReturned' lpOverlapped
Long Parameter List,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,ReadFile,The method has 5 parameters. Parameters: hFile' lpBuffer' nNumberOfBytesToRead' lpNumberOfBytesRead' lpOverlapped
Long Parameter List,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,ReadFile,The method has 5 parameters. Parameters: hFile' lpBuffer' nNumberOfBytesToRead' lpNumberOfBytesRead' lpOverlapped
Long Parameter List,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,WriteFile,The method has 5 parameters. Parameters: handle' bytes' numBytesToWrite' numBytesWritten' lpOverlapped
Long Parameter List,MissionPlanner.Comms,NativeMethods,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,FormatMessage,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' arguments
Long Parameter List,MissionPlanner.Comms,NativeMethods,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' securityAttrs' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,MissionPlanner.Comms,SerialTest,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\SerialTest.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' SecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Statement,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Open,The length of the statement  "            if (inputboxreturn.Cancel == OnInputBoxShow("Listern Port"' "Enter Local port (ensure remote end is already sending)"' ref dest)) " is 129.
Long Statement,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Open,The length of the statement  "                //CustomMessageBox.Show("Please check your Firewall settings\nPlease try running this command\n1.    Run the following command in an elevated command prompt to disable Windows Firewall temporarily:\n    \nNetsh advfirewall set allprofiles state off\n    \nNote: This is just for test; please turn it back on with the command 'Netsh advfirewall set allprofiles state on'.\n"' "Error"); " is 384.
Long Statement,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,Open,The length of the statement  "                if (inputboxreturn.Cancel == OnInputBoxShow("remote host"' "Enter host name/ip (ensure remote end is already started)"' ref host)) " is 130.
Empty Catch Block,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,VerifyConnected,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,Write,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,Close,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,Close,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,Open,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,toggleDTR,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,toggleDTR,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetPortNames,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetPortNames,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetPortNames,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetPortNames,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetPortNames,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetPortNames,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetNiceName,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetName,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,doAutoReconnect,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,doAutoReconnect,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,VerifyConnected,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,Write,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,Close,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,Close,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Open,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Open,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Write,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,VerifyConnected,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,Write,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,Close,The method has an empty catch block.
Empty Catch Block,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,Close,The method has an empty catch block.
Magic Number,MissionPlanner.Comms,CommsFile,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsFile.cs,Open,The following statement contains a magic number: bps = 10000;
Magic Number,MissionPlanner.Comms,CommsFile,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsFile.cs,Open,The following statement contains a magic number: bps = 10000;
Magic Number,MissionPlanner.Comms,CommsFile,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsFile.cs,Read,The following statement contains a magic number: while (true)               {                  // check if we have credit and continue                  if (count < bytecredit)                  {                      bytecredit -= count;                      break;                  }                    // get the time taken since last read in seconds                  double LapsedSinceLastRead = (DateTime.Now - lastread).TotalSeconds;                    // escape if we are out of range                  if (LapsedSinceLastRead < 0 || LapsedSinceLastRead > 2)                      break;                    // get our target bps for this time slice.                  int targetbps = (int)(bps * LapsedSinceLastRead) + bytecredit;                    // check if out target+count is less than our required bps                  if (count < targetbps)                  {                      bytecredit = targetbps - count;                      break;                  }                    System.Threading.Thread.Sleep(1);                    }
Magic Number,MissionPlanner.Comms,CommsFile,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsFile.cs,Read,The following statement contains a magic number: if (buffer[0] == 254 && offset == 1)                  step = buffer[1] + 5 + 2;
Magic Number,MissionPlanner.Comms,CommsFile,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsFile.cs,Read,The following statement contains a magic number: if (buffer[0] == 254 && offset == 1)                  step = buffer[1] + 5 + 2;
Magic Number,MissionPlanner.Comms,CommsFile,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsFile.cs,Read,The following statement contains a magic number: if (buffer[0] == 254 && offset == 1)                  step = buffer[1] + 5 + 2;
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,CommsNTRIP,The following statement contains a magic number: ReadTimeout = 500;
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,TcpKeepAlive,The following statement contains a magic number: byte[] InValue = new byte[12];
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,TcpKeepAlive,The following statement contains a magic number: Array.ConstrainedCopy(BitConverter.GetBytes(Convert.ToUInt32(On_Off))' 0' InValue' 0' 4);
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,TcpKeepAlive,The following statement contains a magic number: Array.ConstrainedCopy(BitConverter.GetBytes(KeepaLiveTime)' 0' InValue' 4' 4);
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,TcpKeepAlive,The following statement contains a magic number: Array.ConstrainedCopy(BitConverter.GetBytes(KeepaLiveTime)' 0' InValue' 4' 4);
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,TcpKeepAlive,The following statement contains a magic number: Array.ConstrainedCopy(BitConverter.GetBytes(KeepaLiveInterval)' 0' InValue' 8' 4);
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,TcpKeepAlive,The following statement contains a magic number: Array.ConstrainedCopy(BitConverter.GetBytes(KeepaLiveInterval)' 0' InValue' 8' 4);
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,doConnect,The following statement contains a magic number: client.Client.IOControl(IOControlCode.KeepAliveValues' TcpKeepAlive(true' 36000000' 3000)' null);
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,doConnect,The following statement contains a magic number: client.Client.IOControl(IOControlCode.KeepAliveValues' TcpKeepAlive(true' 36000000' 3000)' null);
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,SendNMEA,The following statement contains a magic number: if (lat != 0 || lng != 0)              {                  if (_lastnmea.AddSeconds(30) < DateTime.Now)                  {                      double latdms = (int) lat + ((lat - (int) lat) * .6f);                      double lngdms = (int) lng + ((lng - (int) lng) * .6f);                        var line = string.Format(System.Globalization.CultureInfo.InvariantCulture'                          "$GP{0}'{1:HHmmss.ff}'{2}'{3}'{4}'{5}'{6}'{7}'{8}'{9}'{10}'{11}'{12}'{13}'"' "GGA"'                          DateTime.Now.ToUniversalTime()' Math.Abs(latdms * 100).ToString("0.00000")' lat < 0 ? "S" : "N"'                          Math.Abs(lngdms * 100).ToString("0.00000")' lng < 0 ? "W" : "E"' 1' 10'                          1' alt' "M"' 0' "M"' "0.0");                        string checksum = GetChecksum(line);                      WriteLine(line + "*" + checksum);                        log.Info(line + "*" + checksum);                        _lastnmea = DateTime.Now;                  }              }
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,SendNMEA,The following statement contains a magic number: if (lat != 0 || lng != 0)              {                  if (_lastnmea.AddSeconds(30) < DateTime.Now)                  {                      double latdms = (int) lat + ((lat - (int) lat) * .6f);                      double lngdms = (int) lng + ((lng - (int) lng) * .6f);                        var line = string.Format(System.Globalization.CultureInfo.InvariantCulture'                          "$GP{0}'{1:HHmmss.ff}'{2}'{3}'{4}'{5}'{6}'{7}'{8}'{9}'{10}'{11}'{12}'{13}'"' "GGA"'                          DateTime.Now.ToUniversalTime()' Math.Abs(latdms * 100).ToString("0.00000")' lat < 0 ? "S" : "N"'                          Math.Abs(lngdms * 100).ToString("0.00000")' lng < 0 ? "W" : "E"' 1' 10'                          1' alt' "M"' 0' "M"' "0.0");                        string checksum = GetChecksum(line);                      WriteLine(line + "*" + checksum);                        log.Info(line + "*" + checksum);                        _lastnmea = DateTime.Now;                  }              }
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,SendNMEA,The following statement contains a magic number: if (lat != 0 || lng != 0)              {                  if (_lastnmea.AddSeconds(30) < DateTime.Now)                  {                      double latdms = (int) lat + ((lat - (int) lat) * .6f);                      double lngdms = (int) lng + ((lng - (int) lng) * .6f);                        var line = string.Format(System.Globalization.CultureInfo.InvariantCulture'                          "$GP{0}'{1:HHmmss.ff}'{2}'{3}'{4}'{5}'{6}'{7}'{8}'{9}'{10}'{11}'{12}'{13}'"' "GGA"'                          DateTime.Now.ToUniversalTime()' Math.Abs(latdms * 100).ToString("0.00000")' lat < 0 ? "S" : "N"'                          Math.Abs(lngdms * 100).ToString("0.00000")' lng < 0 ? "W" : "E"' 1' 10'                          1' alt' "M"' 0' "M"' "0.0");                        string checksum = GetChecksum(line);                      WriteLine(line + "*" + checksum);                        log.Info(line + "*" + checksum);                        _lastnmea = DateTime.Now;                  }              }
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,SendNMEA,The following statement contains a magic number: if (lat != 0 || lng != 0)              {                  if (_lastnmea.AddSeconds(30) < DateTime.Now)                  {                      double latdms = (int) lat + ((lat - (int) lat) * .6f);                      double lngdms = (int) lng + ((lng - (int) lng) * .6f);                        var line = string.Format(System.Globalization.CultureInfo.InvariantCulture'                          "$GP{0}'{1:HHmmss.ff}'{2}'{3}'{4}'{5}'{6}'{7}'{8}'{9}'{10}'{11}'{12}'{13}'"' "GGA"'                          DateTime.Now.ToUniversalTime()' Math.Abs(latdms * 100).ToString("0.00000")' lat < 0 ? "S" : "N"'                          Math.Abs(lngdms * 100).ToString("0.00000")' lng < 0 ? "W" : "E"' 1' 10'                          1' alt' "M"' 0' "M"' "0.0");                        string checksum = GetChecksum(line);                      WriteLine(line + "*" + checksum);                        log.Info(line + "*" + checksum);                        _lastnmea = DateTime.Now;                  }              }
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,ReadLine,The following statement contains a magic number: byte[] temp = new byte[4000];
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!this.IsOpen) { break; }                  if (this.BytesToRead > 0)                  {                      byte letter = (byte)this.ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  } else {                      timeout++;                      System.Threading.Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,CommsNTRIP,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsNTRIP.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!this.IsOpen) { break; }                  if (this.BytesToRead > 0)                  {                      byte letter = (byte)this.ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  } else {                      timeout++;                      System.Threading.Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: WriteTimeout = 500;
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,Open,The following statement contains a magic number: try              {                  IsOpen = false;                  BaseStream = new MemoryStream(20000);                    var dwFlagsAndAttributes = 128;                  safeFileHandle = CreateFile("\\\\.\\" + PortName'                      -1073741824' 0' IntPtr.Zero' 3' dwFlagsAndAttributes' IntPtr.Zero);                      if (safeFileHandle.IsInvalid)                  {                      throw new Exception("Invalid Port");                  }                    var num1 = 0;                  var commProp = default(COMMPROP);                  if (!GetCommProperties(safeFileHandle' ref commProp) || !GetCommModemStatus(safeFileHandle' ref num1))                  {                      var lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == 87 || lastWin32Error == 6)                      {                          //throw new ArgumentException(SR.GetString("Arg_InvalidSerialPortExtended")' "portName");                      }                      //WinIOError(lastWin32Error' string.Empty);                  }                    //var comStat = default(COMSTAT);                  var dcb = default(DCB);                    if (!GetCommState(safeFileHandle' ref dcb))                  {                  }                    dcb.BaudRate = (uint) BaudRate;                  dcb.ByteSize = 8;                  dcb.StopBits = 0;                  dcb.Parity = 0;                  //https://msdn.microsoft.com/en-us/library/windows/desktop/aa363214(v=vs.85).aspx                  SetDcbFlag(dcb' 0' 1); //fBinary                    SetDcbFlag(dcb' 1' 0); //fParity                    SetDcbFlag(dcb' 2' 1); //fOutxCtsFlow                    SetDcbFlag(dcb' 3' 0); // fOutxDsrFlow                    SetDcbFlag(dcb' 4' 0); //fDtrControl                    SetDcbFlag(dcb' 5' 0); //fDsrSensitivity                    SetDcbFlag(dcb' 6' 0); //fTXContinueOnXoff                    SetDcbFlag(dcb' 7' 0); //fOutX                    SetDcbFlag(dcb' 8' 0); //fInX                    SetDcbFlag(dcb' 9' 0); //fErrorChar                    SetDcbFlag(dcb' 10' 0); //fNull                    SetDcbFlag(dcb' 11' 1); //fRtsControl                    SetDcbFlag(dcb' 14' 0); //fAbortOnError                      if (!SetCommState(safeFileHandle' ref dcb))                  {                  }                    commTimeouts.ReadTotalTimeoutConstant = 0;                  commTimeouts.ReadTotalTimeoutMultiplier = 0;                  commTimeouts.ReadIntervalTimeout = -1;                    if (!SetCommTimeouts(safeFileHandle' ref commTimeouts))                  {                  }                    //ThreadPool.BindHandle(safeFileHandle);                    //                    SetCommMask(safeFileHandle' 507);                      IsOpen = true;                    var th = new Thread(() =>                  {                      while (IsOpen)                      {                          var buffer = new byte[4096];                            uint read = 0;                            ReadFile(safeFileHandle' buffer' (uint) buffer.Length' out read' IntPtr.Zero);                            if (!IsOpen)                              continue;                            lock (locker)                          {                              var pos = BaseStream.Position;                                BaseStream.Write(buffer' 0' (int) read);                                BaseStream.Seek(pos' SeekOrigin.Begin);                          }                        }                        safeFileHandle.Dispose();                  });                    th.IsBackground = true;                  th.Name = "CommsSerialPipe reader";                  th.Start();              }              catch              {                  try                  {                      Close();                  }                  catch                  {                  }                  throw;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,ReadLine,The following statement contains a magic number: var temp = new byte[4000];
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!IsOpen)                  {                      break;                  }                  if (BytesToRead > 0)                  {                      var letter = (byte) ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  }                  else                  {                      timeout++;                      Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!IsOpen)                  {                      break;                  }                  if (BytesToRead > 0)                  {                      var letter = (byte) ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  }                  else                  {                      timeout++;                      Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,SetDcbFlag,The following statement contains a magic number: if (whichFlag == 4 || whichFlag == 12)              {                  num = 3u;              }              else if (whichFlag == 15)              {                  num = 131071u;              }              else              {                  num = 1u;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,SetDcbFlag,The following statement contains a magic number: if (whichFlag == 4 || whichFlag == 12)              {                  num = 3u;              }              else if (whichFlag == 15)              {                  num = 131071u;              }              else              {                  num = 1u;              }
Magic Number,MissionPlanner.Comms,CommsSerialPipe,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPipe.cs,SetDcbFlag,The following statement contains a magic number: if (whichFlag == 4 || whichFlag == 12)              {                  num = 3u;              }              else if (whichFlag == 15)              {                  num = 131071u;              }              else              {                  num = 1u;              }
Magic Number,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,Open,The following statement contains a magic number: this.WriteTimeout = 500;
Magic Number,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,Open,The following statement contains a magic number: try              {                  // this causes element not found with bluetooth devices.                  if (BaudRate > 115200)                  {                      Console.WriteLine("Doing SerialPortFixer");                      SerialPortFixer.Execute(this.PortName);                      Console.WriteLine("Done SerialPortFixer");                  }              }              catch (Exception ex) { Console.WriteLine(ex.ToString()); }
Magic Number,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,toggleDTR,The following statement contains a magic number: System.Threading.Thread.Sleep(50);
Magic Number,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,toggleDTR,The following statement contains a magic number: System.Threading.Thread.Sleep(50);
Magic Number,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,GetNiceName,The following statement contains a magic number: lock (locker)              {                  log.Info("start GetNiceName " + port);                  portnamenice = "";                    if (comportnamecache.ContainsKey(port))                  {                      log.Info("done GetNiceName cache " + port);                      return comportnamecache[port];                  }                    try                  {                      CallWithTimeout(new Action<string>(GetName)' 1000' port);                  }                  catch                  {                  }                  log.Info("done GetNiceName " + port + " = " + portnamenice);                    comportnamecache[port] = portnamenice;                    return (string)portnamenice.Clone();              }
Magic Number,MissionPlanner.Comms,SerialPort,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,FixBlueToothPortNameBug,The following statement contains a magic number: foreach (var portChar in portName.Substring(3).ToCharArray())  //  Remove "COM"' put the rest in a character array               {                  if (char.IsDigit(portChar))                      newPortName += portChar.ToString(); // Good character' append to portName                   //  else                  //log.WarnFormat("Bad (Non Numeric) character in port name '{0}' - removing"' portName);              }
Magic Number,MissionPlanner.Comms,SerialPortFixer,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,SerialPortFixer,The following statement contains a magic number: SafeFileHandle hFile = NativeMethods.CreateFile(@"\\.\" + portName' dwAccess' 0' IntPtr.Zero' 3' dwFlagsAndAttributes'                                                IntPtr.Zero);
Magic Number,MissionPlanner.Comms,SerialPortFixer,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsSerialPort.cs,SerialPortFixer,The following statement contains a magic number: try              {                  int fileType = NativeMethods.GetFileType(hFile);                  if ((fileType != 2) && (fileType != 0))                  {                      throw new ArgumentException("Invalid Serial Port"' "portName");                  }                  m_Handle = hFile;                  InitializeDcb();              }              catch              {                  hFile.Dispose();                  m_Handle = null;                  throw;              }
Magic Number,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,TcpSerial,The following statement contains a magic number: ReadTimeout = 500;
Magic Number,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,doAutoReconnect,The following statement contains a magic number: try              {                  if (DateTime.Now > lastReconnectTime)                  {                      try                      {                          client.Dispose();                      }                      catch { }                        client = new TcpClient();                                            var host = OnSettings("TCP_host"' "");                      var port = int.Parse(OnSettings("TCP_port"' ""));                        log.InfoFormat("doAutoReconnect {0} {1}"' host'port);                        var task = client.ConnectAsync(host' port);                        lastReconnectTime = DateTime.Now.AddSeconds(5);                  }              }              catch { }
Magic Number,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,ReadLine,The following statement contains a magic number: byte[] temp = new byte[4000];
Magic Number,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!this.IsOpen) { break; }                  if (this.BytesToRead > 0)                  {                      byte letter = (byte)this.ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  } else {                      timeout++;                      System.Threading.Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,TcpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsTCPSerial.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!this.IsOpen) { break; }                  if (this.BytesToRead > 0)                  {                      byte letter = (byte)this.ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  } else {                      timeout++;                      System.Threading.Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,UdpSerial,The following statement contains a magic number: ReadTimeout = 500;
Magic Number,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,UdpSerial,The following statement contains a magic number: ReadTimeout = 500;
Magic Number,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Open,The following statement contains a magic number: while (true)              {                  System.Threading.Thread.Sleep(500);                    if (CancelConnect)                  {                      try                      {                          client.Close();                      }                      catch { }                      return;                  }                    if (BytesToRead > 0)                      break;              }
Magic Number,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Read,The following statement contains a magic number: try              {                  if (length < 1) { return 0; }                    // check if we are at the end of our current allocation                  if (rbufferread == rbuffer.Length)                  {                      DateTime deadline = DateTime.Now.AddMilliseconds(this.ReadTimeout);                        MemoryStream r = new MemoryStream();                      do                      {                          // read more                          while (client.Available > 0 && r.Length < (1024 * 1024))                          {                              var currentRemoteIpEndPoint = new IPEndPoint(IPAddress.Any' 0);                              // assumes the udp packets are mavlink aligned' if we are receiving from more than one source                              Byte[] b = client.Receive(ref currentRemoteIpEndPoint);                              r.Write(b' 0' b.Length);                                if(!EndPointList.Contains(currentRemoteIpEndPoint))                                  EndPointList.Add(currentRemoteIpEndPoint);                          }                          // copy mem stream to byte array.                          rbuffer = r.ToArray();                          // reset head.                          rbufferread = 0;                      } while (rbuffer.Length < length && DateTime.Now < deadline);                  }                    // prevent read past end of array                  if ((rbuffer.Length - rbufferread) < length)                  {                      length = (rbuffer.Length - rbufferread);                  }                    Array.Copy(rbuffer' rbufferread' readto' offset' length);                    rbufferread += length;                    return length;              }              catch { throw; }
Magic Number,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,Read,The following statement contains a magic number: try              {                  if (length < 1) { return 0; }                    // check if we are at the end of our current allocation                  if (rbufferread == rbuffer.Length)                  {                      DateTime deadline = DateTime.Now.AddMilliseconds(this.ReadTimeout);                        MemoryStream r = new MemoryStream();                      do                      {                          // read more                          while (client.Available > 0 && r.Length < (1024 * 1024))                          {                              var currentRemoteIpEndPoint = new IPEndPoint(IPAddress.Any' 0);                              // assumes the udp packets are mavlink aligned' if we are receiving from more than one source                              Byte[] b = client.Receive(ref currentRemoteIpEndPoint);                              r.Write(b' 0' b.Length);                                if(!EndPointList.Contains(currentRemoteIpEndPoint))                                  EndPointList.Add(currentRemoteIpEndPoint);                          }                          // copy mem stream to byte array.                          rbuffer = r.ToArray();                          // reset head.                          rbufferread = 0;                      } while (rbuffer.Length < length && DateTime.Now < deadline);                  }                    // prevent read past end of array                  if ((rbuffer.Length - rbufferread) < length)                  {                      length = (rbuffer.Length - rbufferread);                  }                    Array.Copy(rbuffer' rbufferread' readto' offset' length);                    rbufferread += length;                    return length;              }              catch { throw; }
Magic Number,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,ReadLine,The following statement contains a magic number: byte[] temp = new byte[4000];
Magic Number,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!this.IsOpen) { break; }                  if (this.BytesToRead > 0)                  {                      byte letter = (byte)this.ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  } else {                      timeout++;                      System.Threading.Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,UdpSerial,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUdpSerial.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!this.IsOpen) { break; }                  if (this.BytesToRead > 0)                  {                      byte letter = (byte)this.ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  } else {                      timeout++;                      System.Threading.Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,UdpSerialConnect,The following statement contains a magic number: ReadTimeout = 500;
Magic Number,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,Read,The following statement contains a magic number: try              {                  if (length < 1) { return 0; }                    // check if we are at the end of our current allocation                  if (rbufferread == rbuffer.Length)                  {                      DateTime deadline = DateTime.Now.AddMilliseconds(this.ReadTimeout);                        MemoryStream r = new MemoryStream();                      do                      {                          // read more                          while (client.Available > 0 && r.Length < (1024 * 1024))                          {                              Byte[] b = client.Receive(ref RemoteIpEndPoint);                              r.Write(b' 0' b.Length);                          }                          // copy mem stream to byte array.                          rbuffer = r.ToArray();                          // reset head.                          rbufferread = 0;                      } while (rbuffer.Length < length && DateTime.Now < deadline);                  }                    // prevent read past end of array                  if ((rbuffer.Length - rbufferread) < length)                  {                      length = (rbuffer.Length - rbufferread);                  }                    Array.Copy(rbuffer' rbufferread' readto' offset' length);                    rbufferread += length;                    return length;              }              catch { throw; }
Magic Number,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,Read,The following statement contains a magic number: try              {                  if (length < 1) { return 0; }                    // check if we are at the end of our current allocation                  if (rbufferread == rbuffer.Length)                  {                      DateTime deadline = DateTime.Now.AddMilliseconds(this.ReadTimeout);                        MemoryStream r = new MemoryStream();                      do                      {                          // read more                          while (client.Available > 0 && r.Length < (1024 * 1024))                          {                              Byte[] b = client.Receive(ref RemoteIpEndPoint);                              r.Write(b' 0' b.Length);                          }                          // copy mem stream to byte array.                          rbuffer = r.ToArray();                          // reset head.                          rbufferread = 0;                      } while (rbuffer.Length < length && DateTime.Now < deadline);                  }                    // prevent read past end of array                  if ((rbuffer.Length - rbufferread) < length)                  {                      length = (rbuffer.Length - rbufferread);                  }                    Array.Copy(rbuffer' rbufferread' readto' offset' length);                    rbufferread += length;                    return length;              }              catch { throw; }
Magic Number,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,ReadLine,The following statement contains a magic number: byte[] temp = new byte[4000];
Magic Number,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!this.IsOpen) { break; }                  if (this.BytesToRead > 0)                  {                      byte letter = (byte)this.ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  } else {                      timeout++;                      System.Threading.Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,UdpSerialConnect,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\CommsUDPSerialConnect.cs,ReadLine,The following statement contains a magic number: while (timeout <= 100)              {                  if (!this.IsOpen) { break; }                  if (this.BytesToRead > 0)                  {                      byte letter = (byte)this.ReadByte();                        temp[count] = letter;                        if (letter == '\n') // normal line                      {                          break;                      }                          count++;                      if (count == temp.Length)                          break;                      timeout = 0;                  } else {                      timeout++;                      System.Threading.Thread.Sleep(5);                  }              }
Magic Number,MissionPlanner.Comms,SerialTest,C:\repos\diydrones_MissionPlanner\ExtLibs\Comms\SerialTest.cs,Main,The following statement contains a magic number: IntPtr handle = CreateFile(portName' 0' 0' IntPtr.Zero' 3' 0x80' IntPtr.Zero);
