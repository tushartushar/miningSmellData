Implementation smell,Namespace,Class,File,Method,Description
Long Method,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,CheckForIntersect,The method has 146 lines of code.
Long Method,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The method has 110 lines of code.
Complex Method,LibTessDotNet,Geom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Geom.cs,EdgeIntersect,Cyclomatic complexity of the method is 15
Complex Method,LibTessDotNet,Mesh,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Mesh.cs,MergeConvexFaces,Cyclomatic complexity of the method is 8
Complex Method,LibTessDotNet,PriorityQueue<TValue>,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\PriorityQueue.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,CheckForIntersect,Cyclomatic complexity of the method is 15
Complex Method,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,WalkDirtyRegions,Cyclomatic complexity of the method is 13
Complex Method,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,Cyclomatic complexity of the method is 14
Complex Method,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,Cyclomatic complexity of the method is 10
Complex Method,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,TessellateMonoRegion,Cyclomatic complexity of the method is 8
Complex Method,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,Cyclomatic complexity of the method is 18
Long Parameter List,LibTessDotNet,Geom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Geom.cs,EdgeIntersect,The method has 5 parameters. Parameters: o1' d1' o2' d2' v
Long Parameter List,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,AddRightEdges,The method has 5 parameters. Parameters: regUp' eFirst' eLast' eTopLeft' cleanUp
Long Parameter List,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,VertexWeights,The method has 5 parameters. Parameters: isect' org' dst' w0' w1
Long Parameter List,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,GetIntersectData,The method has 5 parameters. Parameters: isect' orgUp' dstUp' orgLo' dstLo
Long Statement,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,AddContour,The length of the statement  "                reverse = (forceOrientation == ContourOrientation.Clockwise && area < 0.0f) || (forceOrientation == ContourOrientation.CounterClockwise && area > 0.0f); " is 152.
Complex Conditional,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,CheckForIntersect,The conditional expression  "(! Geom.VertEq(dstUp' _event)                  && Geom.EdgeSign(dstUp' _event' isect) >= 0.0f)                  || (! Geom.VertEq(dstLo' _event)                  && Geom.EdgeSign(dstLo' _event' isect) <= 0.0f)"  is complex.
Complex Conditional,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,WalkDirtyRegions,The conditional expression  "eUp._Dst != eLo._Dst                          && ! regUp._fixUpperEdge && ! regLo._fixUpperEdge                          && (eUp._Dst == _event || eLo._Dst == _event)"  is complex.
Magic Number,LibTessDotNet,Geom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Geom.cs,IsWindingInside,The following statement contains a magic number: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
Magic Number,LibTessDotNet,Geom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Geom.cs,IsWindingInside,The following statement contains a magic number: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
Magic Number,LibTessDotNet,Geom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Geom.cs,Interpolate,The following statement contains a magic number: return ((a <= b) ? ((b == 0.0f) ? ((x+y) / 2.0f)                      : (x + (y-x) * (a/(a+b))))                      : (y + (x-y) * (b/(a+b))));
Magic Number,LibTessDotNet,Geom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Geom.cs,EdgeIntersect,The following statement contains a magic number: v._s = (o2._s + d1._s) / 2.0f;
Magic Number,LibTessDotNet,Geom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Geom.cs,EdgeIntersect,The following statement contains a magic number: v._t = (o2._t + d1._t) / 2.0f;
Magic Number,LibTessDotNet,Mesh,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Mesh.cs,MergeConvexFaces,The following statement contains a magic number: (curNv + symNv - 2) <= maxVertsPerFace
Magic Number,LibTessDotNet,Vec3,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\MeshUtils.cs,LongAxis,The following statement contains a magic number: i = 2;
Magic Number,LibTessDotNet,PriorityHeap<TValue>,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\PriorityHeap.cs,Insert,The following statement contains a magic number: (curr * 2) > _max
Magic Number,LibTessDotNet,PriorityQueue<TValue>,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\PriorityQueue.cs,Init,The following statement contains a magic number: uint seed = 2016473283;
Magic Number,LibTessDotNet,PriorityQueue<TValue>,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\PriorityQueue.cs,Init,The following statement contains a magic number: seed = seed * 1539415821 + 1;
Magic Number,LibTessDotNet,PriorityQueue<TValue>,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\PriorityQueue.cs,Init,The following statement contains a magic number: r > p + 10
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,VertexWeights,The following statement contains a magic number: w0 = (t2 / (t1 + t2)) / 2.0f;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,VertexWeights,The following statement contains a magic number: w1 = (t1 / (t1 + t2)) / 2.0f;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,InitPriorityQ,The following statement contains a magic number: vertexCount += 8;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: var minVal = new Real[3] { v._coords.X' v._coords.Y' v._coords.Z };
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: var minVert = new MeshUtils.Vertex[3] { v' v' v };
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: var maxVal = new Real[3] { v._coords.X' v._coords.Y' v._coords.Z };
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: var maxVert = new MeshUtils.Vertex[3] { v' v' v };
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: minVal[2] = v._coords.Z;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: minVert[2] = v;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: v._coords.Z < minVal[2]
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: maxVal[2] = v._coords.Z;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: maxVert[2] = v;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: v._coords.Z > maxVal[2]
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: i = 2;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: maxVal[2] - minVal[2] > maxVal[i] - minVal[i]
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: maxVal[2] - minVal[2] > maxVal[i] - minVal[i]
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 1) % 3] = SUnitX;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 2) % 3] = SUnitY;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 2) % 3] = SUnitY;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 1) % 3] = norm[i] > 0.0f ? -SUnitY : SUnitY;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 2) % 3] = norm[i] > 0.0f ? SUnitX : -SUnitX;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 2) % 3] = norm[i] > 0.0f ? SUnitX : -SUnitX;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The following statement contains a magic number: polySize = 3;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The following statement contains a magic number: polySize < 3
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The following statement contains a magic number: polySize > 3
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The following statement contains a magic number: maxFaceCount *= 2;
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,OutputContours,The following statement contains a magic number: _elements = new int[_elementCount * 2];
Magic Number,LibTessDotNet,Tess,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Sweep.cs,SignedArea,The following statement contains a magic number: return 0.5f * area;
Missing Default,LibTessDotNet,Geom,D:\research\architectureSmells\repos\diydrones_MissionPlanner\ExtLibs\LibTessDotNet\Sources\Geom.cs,IsWindingInside,The following switch statement is missing a default case: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
