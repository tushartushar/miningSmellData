Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ExpressiveAnnotations.Analysis,TypeAdapter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeAdapter.cs,MakeTypesCompatible,Cyclomatic complexity of the method is 22
Complex Method,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ConvertTokenValue,Cyclomatic complexity of the method is 8
Complex Method,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ParsePrimaryExp,Cyclomatic complexity of the method is 11
Complex Method,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ParseAccess,Cyclomatic complexity of the method is 10
Long Parameter List,ExpressiveAnnotations.Analysis,Expr,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Expr.cs,Condition,The method has 5 parameters. Parameters: arg1' arg2' arg3' start' qmark
Long Parameter List,ExpressiveAnnotations.Analysis,TypeAdapter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeAdapter.cs,MakeTypesCompatible,The method has 5 parameters. Parameters: e1' e2' oute1' oute2' operation
Long Parameter List,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,Eq,The method has 5 parameters. Parameters: arg1' arg2' type1' type2' oper
Long Parameter List,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,Rel,The method has 5 parameters. Parameters: arg1' arg2' type1' type2' oper
Long Parameter List,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,Add,The method has 5 parameters. Parameters: arg1' arg2' type1' type2' oper
Long Parameter List,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,Mul,The method has 5 parameters. Parameters: arg1' arg2' type1' type2' oper
Long Parameter List,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,Cond,The method has 7 parameters. Parameters: arg1' arg2' arg3' type2' type3' start' qmark
Long Parameter List,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,AssertArgsNotNullLiterals,The method has 5 parameters. Parameters: arg1' type1' arg2' type2' oper
Long Parameter List,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ConvertArgument,The method has 5 parameters. Parameters: arg' type' funcName' argIdx' argPos
Long Statement,ExpressiveAnnotations.Analysis,TypeAdapter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeAdapter.cs,MakeTypesCompatible,The length of the statement  "            var small = new[] {typeof(sbyte)' typeof(byte)' typeof(char)' typeof(short)' typeof(ushort)}; // convart all <32bit integral types to signed int " is 144.
Long Statement,ExpressiveAnnotations.Analysis,TypeAdapter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeAdapter.cs,MakeTypesCompatible,The length of the statement  "            if (operation != TokenType.DIV // do not promote integral numeric values to double - exception for division operation' e.g. 1/2 should evaluate to 0.5 double like in JS " is 168.
Long Statement,ExpressiveAnnotations.Analysis,TypeAdapter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeAdapter.cs,MakeTypesCompatible,The length of the statement  "            // promote numeric values to double - do computations with higher precision (to be compatible with JavaScript' e.g. 1/2 should evaluate to 0.5 double not 0 int) " is 160.
Long Statement,ExpressiveAnnotations.Analysis,TypeAdapter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeAdapter.cs,MakeTypesCompatible,The length of the statement  "                // non-nullable operand is converted to nullable if necessary' and the lifted-to-nullable form of the comparison is used (C# rule' which is currently not followed by expression trees) " is 183.
Long Statement,ExpressiveAnnotations.Analysis,TypeAdapter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeAdapter.cs,MakeTypesCompatible,The length of the statement  "            // make DateTime and TimeSpan compatible (also do not care when first argument is TimeSpan and second DateTime because it is not allowed) " is 137.
Long Statement,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,Cond,The length of the statement  "                    $"Type of conditional expression cannot be determined because there is no implicit conversion between 'null' and '{type3}'."' ExprString' qmark); " is 145.
Long Statement,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,Cond,The length of the statement  "                    $"Type of conditional expression cannot be determined because there is no implicit conversion between '{type2}' and 'null'."' ExprString' qmark); " is 145.
Long Statement,ExpressiveAnnotations.Analysis,TypeWall,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeWall.cs,Cond,The length of the statement  "                    $"Type of conditional expression cannot be determined because there is no implicit conversion between '{type2}' and '{type3}'."' ExprString' qmark); " is 148.
Long Statement,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,Analyze,The length of the statement  "                // once we've reached the end of the string' EOF token is returned - thus' parser's lookahead does not have to worry about running out of tokens " is 144.
Long Statement,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ConvertTokenValue,The length of the statement  "                        return double.Parse(value' CultureInfo.InvariantCulture); // By default' treat float numeric literals as 64-bit floating binary point values (as C# " is 147.
Long Statement,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ConvertTokenValue,The length of the statement  "                    case TokenType.BOOL:                                          // does' gives better precision than float). What's more' InvariantCulture means no matter " is 152.
Long Statement,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ConvertTokenValue,The length of the statement  "                        return bool.Parse(value);                                 // the current culture' dot is always accepted in double literal to be succesfully parsed. " is 148.
Long Statement,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ParseStringLiteral,The length of the statement  "            //System.Diagnostics.Debug.WriteLine(value); // when looking at expression in debugger' take into account that debugger prints control characters' while output does not " is 168.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ParseAdditiveExp,The length of the statement  "                                typeof(string).GetMethod("Concat"' new[] {typeof(object)' typeof(object)})) // convert string + string into a call to string.Concat " is 131.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ParsePrimaryExp,The length of the statement  "                        "Expected \"null\"' bool' int' float' bin' hex' string' array or id. Unexpected end of expression."' ExprString' PeekToken().Location); " is 135.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ParsePrimaryExp,The length of the statement  "                        $"Expected \"null\"' bool' int' float' bin' hex' string' array or id. Unexpected token: '{PeekRawValue()}'."' ExprString' PeekToken().Location); " is 144.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ParseArray,The length of the statement  "                : Expression.NewArrayInit(typeof(object)' args.Select(x => Expression.Convert(x' typeof(object)))); // items of various types' let it be an array of objects " is 156.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,FetchPropertyValue,The length of the statement  "            var pi = context.Type.GetProperties().FirstOrDefault(p => p.GetIndexParameters().Any()); // look for indexer property (usually called Item...) " is 142.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,FetchConstValue,The length of the statement  "            Consts[name] = (value as string)?.Replace(Environment.NewLine' "\n") ?? value; // in our language new line is represented by \n char (consts map is then sent to JavaScript' and JavaScript new line is also \n) " is 208.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ExtractMethodExpression,The length of the statement  "            var expression = FetchModelMethod(name' args' funcPos) ?? FetchToolchainMethod(name' args' funcPos); // firstly' try to take method from model context - if not found' take one from toolchain " is 190.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ExtractMethodExpression,The length of the statement  "                    $"Function '{name}' accepting {args.Count} argument{(args.Count == 1 ? string.Empty : "s")} not found."' ExprString' funcPos); " is 126.
Long Statement,ExpressiveAnnotations.Analysis,Parser,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Parser.cs,ConvertArgument,The length of the statement  "                    $"Function '{funcName}' {argIdx.ToOrdinal()} argument implicit conversion from '{arg.Type}' to expected '{type}' failed."' " is 122.
Long Statement,ExpressiveAnnotations.Attributes,AssertThatAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\AssertThatAttribute.cs,IsValidInternal,The length of the statement  "                if (!CachedValidationFuncs[validationContext.ObjectType](validationContext.ObjectInstance)) // check if the assertion condition is not satisfied " is 144.
Long Statement,ExpressiveAnnotations.Attributes,ExpressiveAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\ExpressiveAttribute.cs,FormatErrorMessage,The length of the statement  "                message = items.Aggregate(message' (cargo' current) => current.Indicator != null && !current.Constant ? cargo.Replace(current.Uuid.ToString()' Helper.ExtractDisplayName(objectInstance.GetType()' current.FieldPath)) : cargo); " is 224.
Long Statement,ExpressiveAnnotations.Attributes,ExpressiveAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\ExpressiveAttribute.cs,FormatErrorMessage,The length of the statement  "                message = items.Aggregate(message' (cargo' current) => current.Indicator == null && !current.Constant ? cargo.Replace(current.Uuid.ToString()' (Helper.ExtractValue(objectInstance' current.FieldPath) ?? string.Empty).ToString()) : cargo); " is 237.
Long Statement,ExpressiveAnnotations.Attributes,ExpressiveAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\ExpressiveAttribute.cs,FormatErrorMessage,The length of the statement  "                var map = items.Where(x => x.Indicator == null && !x.Constant).Select(x => x.FieldPath).Distinct().ToDictionary(x => x' x => Guid.NewGuid()); // sanitize " is 153.
Long Statement,ExpressiveAnnotations.Attributes,ExpressiveAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\ExpressiveAttribute.cs,FormatErrorMessage,The length of the statement  "                message = items.Aggregate(message' (cargo' current) => current.Indicator != null && !current.Constant ? cargo.Replace(current.Uuid.ToString()' Helper.ExtractDisplayName(objectType' current.FieldPath)) : cargo); " is 210.
Long Statement,ExpressiveAnnotations.Attributes,ExpressiveAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\ExpressiveAttribute.cs,FormatErrorMessage,The length of the statement  "                message = items.Aggregate(message' (cargo' current) => current.Indicator == null && !current.Constant ? cargo.Replace(current.Uuid.ToString()' map[current.FieldPath].ToString()) : cargo); " is 187.
Long Statement,ExpressiveAnnotations.Attributes,ExpressiveAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\ExpressiveAttribute.cs,PreformatMessage,The length of the statement  "            var message = MessageFormatter.FormatString(ErrorMessageString' out items); // process custom format items: {fieldPath[:indicator]}' and substitute them entirely with guids' not to interfere with standard string.Format() invoked below " is 234.
Long Statement,ExpressiveAnnotations.Attributes,ExpressiveAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\ExpressiveAttribute.cs,PreformatMessage,The length of the statement  "            message = string.Format(message' displayName' expression); // process standard format items: {index['alignment][:formatString]}' https://msdn.microsoft.com/en-us/library/txafckwd(v=vs.110).aspx " is 193.
Long Statement,ExpressiveAnnotations.Attributes,ExpressiveAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\ExpressiveAttribute.cs,PreformatMessage,The length of the statement  "            message = items.Aggregate(message' (cargo' current) => cargo.Replace(current.Uuid.ToString()' current.Substitute)); // give back' initially preprocessed' custom format items " is 173.
Long Statement,ExpressiveAnnotations.Attributes,RequiredIfAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\RequiredIfAttribute.cs,IsValidInternal,The length of the statement  "                if (CachedValidationFuncs[validationContext.ObjectType](validationContext.ObjectInstance)) // check if the requirement condition is satisfied " is 141.
Long Statement,ExpressiveAnnotations.Attributes,RequiredIfAttribute,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Attributes\RequiredIfAttribute.cs,AssertNonValueType,The length of the statement  "                    $"{nameof(RequiredIfAttribute)} has no effect when applied to a field of non-nullable value type '{PropertyType.FullName}'. Use nullable '{PropertyType.FullName}?' version instead' or switch to {nameof(AssertThatAttribute)} otherwise."); " is 237.
Long Statement,ExpressiveAnnotations,MessageFormatter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\MessageFormatter.cs,FormatString,The length of the statement  "                    Substitute = $"{leftBracesFlattened}{(length%2 != 0 ? uuid.ToString() : param)}{rightBracesFlattened}" // for odd number of braces' substitute param with respective value (just like string.Format() does) " is 203.
Long Statement,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ExtractDisplayName,The length of the statement  "                    throw new ArgumentException($"No display name provided for {prop} field. Use either Display attribute or DisplayName attribute."' property); " is 140.
Complex Conditional,ExpressiveAnnotations.Analysis,TypeAdapter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\TypeAdapter.cs,MakeTypesCompatible,The conditional expression  "operation != TokenType.DIV // do not promote integral numeric values to double - exception for division operation' e.g. 1/2 should evaluate to 0.5 double like in JS                  && !oute1.Type.IsEnum && !oute2.Type.IsEnum                  && oute1.Type.IsIntegralNumeric() && oute2.Type.IsIntegralNumeric()"  is complex.
Magic Number,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ConvertTokenValue,The following statement contains a magic number: switch (type)                  {                      case TokenType.NULL:                          return null;                      case TokenType.INT:                          return int.Parse(value' CultureInfo.InvariantCulture);                      case TokenType.BIN:                          return Convert.ToInt32(value.Substring(2)' 2);                      case TokenType.HEX:                          return Convert.ToInt32(value.Substring(2)' 16);                      case TokenType.FLOAT:                          return double.Parse(value' CultureInfo.InvariantCulture); // By default' treat float numeric literals as 64-bit floating binary point values (as C#                      case TokenType.BOOL:                                          // does' gives better precision than float). What's more' InvariantCulture means no matter                          return bool.Parse(value);                                 // the current culture' dot is always accepted in double literal to be succesfully parsed.                      case TokenType.STRING:                          return ParseStringLiteral(value);                      default:                          return value;                  }
Magic Number,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ConvertTokenValue,The following statement contains a magic number: switch (type)                  {                      case TokenType.NULL:                          return null;                      case TokenType.INT:                          return int.Parse(value' CultureInfo.InvariantCulture);                      case TokenType.BIN:                          return Convert.ToInt32(value.Substring(2)' 2);                      case TokenType.HEX:                          return Convert.ToInt32(value.Substring(2)' 16);                      case TokenType.FLOAT:                          return double.Parse(value' CultureInfo.InvariantCulture); // By default' treat float numeric literals as 64-bit floating binary point values (as C#                      case TokenType.BOOL:                                          // does' gives better precision than float). What's more' InvariantCulture means no matter                          return bool.Parse(value);                                 // the current culture' dot is always accepted in double literal to be succesfully parsed.                      case TokenType.STRING:                          return ParseStringLiteral(value);                      default:                          return value;                  }
Magic Number,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ConvertTokenValue,The following statement contains a magic number: switch (type)                  {                      case TokenType.NULL:                          return null;                      case TokenType.INT:                          return int.Parse(value' CultureInfo.InvariantCulture);                      case TokenType.BIN:                          return Convert.ToInt32(value.Substring(2)' 2);                      case TokenType.HEX:                          return Convert.ToInt32(value.Substring(2)' 16);                      case TokenType.FLOAT:                          return double.Parse(value' CultureInfo.InvariantCulture); // By default' treat float numeric literals as 64-bit floating binary point values (as C#                      case TokenType.BOOL:                                          // does' gives better precision than float). What's more' InvariantCulture means no matter                          return bool.Parse(value);                                 // the current culture' dot is always accepted in double literal to be succesfully parsed.                      case TokenType.STRING:                          return ParseStringLiteral(value);                      default:                          return value;                  }
Magic Number,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ConvertTokenValue,The following statement contains a magic number: switch (type)                  {                      case TokenType.NULL:                          return null;                      case TokenType.INT:                          return int.Parse(value' CultureInfo.InvariantCulture);                      case TokenType.BIN:                          return Convert.ToInt32(value.Substring(2)' 2);                      case TokenType.HEX:                          return Convert.ToInt32(value.Substring(2)' 16);                      case TokenType.FLOAT:                          return double.Parse(value' CultureInfo.InvariantCulture); // By default' treat float numeric literals as 64-bit floating binary point values (as C#                      case TokenType.BOOL:                                          // does' gives better precision than float). What's more' InvariantCulture means no matter                          return bool.Parse(value);                                 // the current culture' dot is always accepted in double literal to be succesfully parsed.                      case TokenType.STRING:                          return ParseStringLiteral(value);                      default:                          return value;                  }
Magic Number,ExpressiveAnnotations.Analysis,Lexer,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Analysis\Lexer.cs,ParseStringLiteral,The following statement contains a magic number: var unescaped = value.Substring(1' value.Length - 2)                  .Replace(@"\'"' "'") // remove backslash escape character when it is placed in front of single quote character                                       // (when such a quote is used internally inside string literal' e.g. John\'s cat => changed to John's cat)                  .Replace(@"\n"' Environment.NewLine) // in our language \n represents new line for current environment                  .Replace(@"\r"' "\r")                  .Replace(@"\t"' "\t")                  .Replace(@"\\"' "\\");
Magic Number,ExpressiveAnnotations,MessageFormatter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\MessageFormatter.cs,FormatString,The following statement contains a magic number: var rightBraces = match.Groups[2];
Magic Number,ExpressiveAnnotations,MessageFormatter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\MessageFormatter.cs,FormatString,The following statement contains a magic number: var leftBracesFlattened = new string('{'' length / 2);
Magic Number,ExpressiveAnnotations,MessageFormatter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\MessageFormatter.cs,FormatString,The following statement contains a magic number: var rightBracesFlattened = new string('}'' length / 2);
Magic Number,ExpressiveAnnotations,MessageFormatter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\MessageFormatter.cs,FormatString,The following statement contains a magic number: var param = item.Substring(length' item.Length - 2 * length);
Magic Number,ExpressiveAnnotations,MessageFormatter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\MessageFormatter.cs,FormatString,The following statement contains a magic number: var current = new FormatItem                  {                      Uuid = uuid'                      Body = item'                      Constant = length % 2 == 0'                      FieldPath = param.Contains(":") ? param.Substring(0' param.IndexOf(":"' StringComparison.Ordinal)) : param'                      Indicator = param.Contains(":") ? param.Substring(param.IndexOf(":"' StringComparison.Ordinal) + 1) : null'                      Substitute = $"{leftBracesFlattened}{(length%2 != 0 ? uuid.ToString() : param)}{rightBracesFlattened}" // for odd number of braces' substitute param with respective value (just like string.Format() does)                  };
Magic Number,ExpressiveAnnotations,MessageFormatter,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\MessageFormatter.cs,FormatString,The following statement contains a magic number: var current = new FormatItem                  {                      Uuid = uuid'                      Body = item'                      Constant = length % 2 == 0'                      FieldPath = param.Contains(":") ? param.Substring(0' param.IndexOf(":"' StringComparison.Ordinal)) : param'                      Indicator = param.Contains(":") ? param.Substring(param.IndexOf(":"' StringComparison.Ordinal) + 1) : null'                      Substitute = $"{leftBracesFlattened}{(length%2 != 0 ? uuid.ToString() : param)}{rightBracesFlattened}" // for odd number of braces' substitute param with respective value (just like string.Format() does)                  };
Magic Number,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ToOrdinal,The following statement contains a magic number: switch (num%100)              {                  case 11:                  case 12:                  case 13:                      return num + "th";              }
Magic Number,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ToOrdinal,The following statement contains a magic number: switch (num%100)              {                  case 11:                  case 12:                  case 13:                      return num + "th";              }
Magic Number,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ToOrdinal,The following statement contains a magic number: switch (num%100)              {                  case 11:                  case 12:                  case 13:                      return num + "th";              }
Magic Number,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ToOrdinal,The following statement contains a magic number: switch (num%100)              {                  case 11:                  case 12:                  case 13:                      return num + "th";              }
Magic Number,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ToOrdinal,The following statement contains a magic number: switch (num%10)              {                  case 1:                      return num + "st";                  case 2:                      return num + "nd";                  case 3:                      return num + "rd";                  default:                      return num + "th";              }
Magic Number,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ToOrdinal,The following statement contains a magic number: switch (num%10)              {                  case 1:                      return num + "st";                  case 2:                      return num + "nd";                  case 3:                      return num + "rd";                  default:                      return num + "th";              }
Magic Number,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ToOrdinal,The following statement contains a magic number: switch (num%10)              {                  case 1:                      return num + "st";                  case 2:                      return num + "nd";                  case 3:                      return num + "rd";                  default:                      return num + "th";              }
Magic Number,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,BuildParseError,The following statement contains a magic number: return suffix.Length == 0                  ? $"Parse error on line {location.Line}' last column: {message}"                  : $"Parse error on line {location.Line}' column {location.Column}:{suffix.Indicator(100)}{message}";
Missing Default,ExpressiveAnnotations,Helper,D:\research\architectureSmells\repos\JaroslawWaliszko_ExpressiveAnnotations\src\ExpressiveAnnotations\Helper.cs,ToOrdinal,The following switch statement is missing a default case: switch (num%100)              {                  case 11:                  case 12:                  case 13:                      return num + "th";              }
