Implementation smell,Namespace,Class,File,Method,Description
Long Method,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The method has 156 lines of code.
Long Method,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The method has 277 lines of code.
Complex Method,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,Cyclomatic complexity of the method is 8
Long Statement,s4pi.ImageResource,PixelFormat,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DDS.cs,Parse,The length of the statement  "            if (size != this.size) throw new InvalidDataException(string.Format("Expected size: 0x{0:X8}' read 0x{1:X8}"' this.size' size)); " is 128.
Long Statement,s4pi.ImageResource,PixelFormat,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DDS.cs,Parse,The length of the statement  "            //if ((this.pixelFormatFlag & PixelFormatFlags.FourCC) != PixelFormatFlags.FourCC) throw new InvalidDataException("Bad pixel format flag"); " is 139.
Long Statement,s4pi.ImageResource,PixelFormat,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DDS.cs,Parse,The length of the statement  "            if (!Enum.IsDefined(typeof(PixelFormatFlags)' pixelFormatFlag)) throw new InvalidDataException("Bad pixel format flag"); else this.pixelFormatFlag = (PixelFormatFlags) pixelFormatFlag; " is 184.
Long Statement,s4pi.ImageResource,PixelFormat,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DDS.cs,Parse,The length of the statement  "            if (!Enum.IsDefined(typeof(FourCC)' fourCC)) throw new InvalidDataException(string.Format("Unexpected data' read 0x{0:X8}"' fourCC)); else this.fourcc = (FourCC)fourCC; " is 168.
Long Statement,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The length of the statement  "                using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream()) " is 122.
Long Statement,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The length of the statement  "            if (this.info.pixelFormat.Fourcc != FourCC.DXT5) throw new InvalidDataException(string.Format("Not a DXT5 format DDS' read {0}"' this.info.pixelFormat.Fourcc)); " is 160.
Long Statement,s4pi.ImageResource,RLEInfo,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,Parse,The length of the statement  "                if (signature != Signature) throw new InvalidDataException(string.Format("Expected signature 0x{0:X8}' read 0x{1:X8}"' Signature' signature)); " is 142.
Long Statement,s4pi.ImageResource,RLEInfo,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,Parse,The length of the statement  "                if (size != this.size) throw new InvalidDataException(string.Format("Expected size: 0x{0:X8}' read 0x{1:X8}"' this.size' size)); " is 128.
Long Statement,s4pi.ImageResource,RLEInfo,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,Parse,The length of the statement  "                if ((this.headerFlags & HeaderFlags.Texture) != HeaderFlags.Texture) throw new InvalidDataException(string.Format("Expected 0x{0:X8}' read 0x{1:X8}"' (uint)HeaderFlags.Texture' (uint)this.headerFlags)); " is 202.
Long Statement,s4pi.ImageResource,RLEInfo,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,Parse,The length of the statement  "                if (this.Height > ushort.MaxValue || this.Width > ushort.MaxValue) throw new InvalidDataException("Invalid width or length"); " is 125.
Long Statement,s4pi.ImageResource,RLEInfo,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,Parse,The length of the statement  "                if (this.Depth != 0 && this.Depth != 1) throw new InvalidDataException(string.Format("Expected depth 1 or 0' read 0x{0:X8}"' this.Depth)); " is 138.
Long Statement,s4pi.ImageResource,RLEInfo,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,Parse,The length of the statement  "                if (this.mipCount > 16) throw new InvalidDataException(string.Format("Expected mini map count less than 16' read 0x{0:X8}"' this.mipCount)); " is 140.
Long Statement,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,ToJFIF,The length of the statement  "            //    length = (int)((length & 0xFF000000) >> 24) | (int)((length & 0x00FF0000) >> 8) | (int)((length & 0x0000FF00) << 8) | (int)((length & 0x000000FF) << 24); " is 159.
Long Statement,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,TransformToPNG,The length of the statement  "                    length = (int)((length & 0xFF000000) >> 24) | (int)((length & 0x00FF0000) >> 8) | (int)((length & 0x0000FF00) << 8) | (int)((length & 0x000000FF) << 24); " is 153.
Long Statement,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,TransformToPNG,The length of the statement  "                        if (colorImage.Width != alphaImage.Width || colorImage.Height != alphaImage.Height) throw new InvalidDataException("Not a proper TS4 Thumbnail image"); " is 151.
Complex Conditional,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The conditional expression  "blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3"  is complex.
Complex Conditional,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The conditional expression  "blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4"  is complex.
Complex Conditional,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The conditional expression  "blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4"  is complex.
Complex Conditional,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The conditional expression  "translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false"  is complex.
Complex Conditional,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The conditional expression  "translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false"  is complex.
Virtual Method Call from Constructor,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,DSTResource,The constructor "DSTResource" calls a virtual method "OnResourceChanged".
Virtual Method Call from Constructor,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,RLEResource,The constructor "RLEResource" calls a virtual method "OnResourceChanged".
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: input.Position = 128;
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Shuffle,The following statement contains a magic number: if(header.pixelFormat.Fourcc == FourCC.DST1)              {                  using(MemoryStream block1 = new MemoryStream()' block2 = new MemoryStream())                  {                      BinaryWriter w1 = new BinaryWriter(block1)' w2 = new BinaryWriter(block2);                      int count = ((int)input.Length - 128) / 8;                        for(int i = 0; i < count; i++)                      {                          w1.Write(r.ReadBytes(4));                          w2.Write(r.ReadBytes(4));                      }                        w.Write(block1.ToArray());                      w.Write(block2.ToArray());                  }              }              else if(header.pixelFormat.Fourcc == FourCC.DST3)              {                  throw new Exception("No sample yet");              }              else if(header.pixelFormat.Fourcc == FourCC.DST5) // dst5              {                  using(MemoryStream ms0 = new MemoryStream()' ms1 = new MemoryStream()' ms2 = new MemoryStream()' ms3 = new MemoryStream())                  {                      BinaryWriter w0 = new BinaryWriter(ms0);                      BinaryWriter w1 = new BinaryWriter(ms1);                      BinaryWriter w2 = new BinaryWriter(ms2);                      BinaryWriter w3 = new BinaryWriter(ms3);                        int count = (int)(input.Length - 128) / 16;                      for (int i = 0; i < count; i++)                      {                          w0.Write(r.ReadBytes(2));                          w1.Write(r.ReadBytes(6));                          w2.Write(r.ReadBytes(4));                          w3.Write(r.ReadBytes(4));                      }                        w.Write(ms0.ToArray());                      w.Write(ms2.ToArray());                      w.Write(ms1.ToArray());                      w.Write(ms3.ToArray());                    }                                }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: const int dataOffset = 128;
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,DSTResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\DSTResource.cs,Unshuffle,The following statement contains a magic number: if (header.pixelFormat.Fourcc == FourCC.DST1)              {                  header.pixelFormat.Fourcc = FourCC.DXT1;                  w.Write(0x20534444); // DDS header                  header.UnParse(result);                    var blockOffset2 = 0;                  var blockOffset3 = blockOffset2 + (dataSize >> 1);                    // probably a better way to do this                  var count = (blockOffset3 - blockOffset2) / 4;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }              else if (header.pixelFormat.Fourcc == FourCC.DST3) // DST3              {                  header.pixelFormat.Fourcc = FourCC.DXT3;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 1);                  var blockOffset3 = blockOffset2 + (dataSize >> 2);                    throw new NotImplementedException("no samples");              }              else if (header.pixelFormat.Fourcc ==  FourCC.DST5) // DST5              {                  header.pixelFormat.Fourcc = FourCC.DXT5;                  w.Write(0x20534444);                  header.UnParse(result);                    var blockOffset0 = 0;                  var blockOffset2 = blockOffset0 + (dataSize >> 3);                  var blockOffset1 = blockOffset2 + (dataSize >> 2);                  var blockOffset3 = blockOffset1 + (6 * dataSize >> 4);                    // probably a better way to do this                  var count = (blockOffset2 - blockOffset0) / 2;                    for (int i = 0; i < count; i++)                  {                      result.Write(temp' blockOffset0' 2);                      result.Write(temp' blockOffset1' 6);                      result.Write(temp' blockOffset2' 4);                      result.Write(temp' blockOffset3' 4);                        blockOffset0 += 2;                      blockOffset1 += 6;                      blockOffset2 += 4;                      blockOffset3 += 4;                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                        for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3)                      {                          throw new InvalidOperationException();                      }                  }              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                    w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                    w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(this.data' blockOffset0' 2);                                  w.Write(this.data' blockOffset1' 6);                                  w.Write(this.data' blockOffset2' 4);                                  w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToBlock4DDS,The following statement contains a magic number: if (this.info.Version == RLEVersion.RLE2)              {                  return null;              }              else              {                  for (int i = 0; i < this.info.mipCount; i++)                  {                      var mipHeader = this.MipHeaders[i];                      var nextMipHeader = MipHeaders[i + 1];                        int blockOffset2' blockOffset3' blockOffset0' blockOffset1' blockOffset4;                      blockOffset2 = mipHeader.Offset2;                      blockOffset3 = mipHeader.Offset3;                      blockOffset0 = mipHeader.Offset0;                      blockOffset1 = mipHeader.Offset1;                      blockOffset4 = mipHeader.Offset4;                      var off4 = 0;                      for (int commandOffset = mipHeader.CommandOffset;                          commandOffset < nextMipHeader.CommandOffset;                          commandOffset += 2)                      {                          var command = BitConverter.ToUInt16(this.data' commandOffset);                            var op = command & 3;                          var count = command >> 2;                            if (op == 0)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullTransparentAlpha' 0' 8);                                  w.Write(fullTransparentAlpha' 0' 8);                              }                          }                          else if (op == 1)                          {                              for (int j = 0; j < count; j++)                              {                                  //output.Write(fullOpaqueAlpha' 0' 8);                                  //output.Write(fullTransparentColor' 0' 8);                                   // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                  blockOffset0 += 2;                                  blockOffset1 += 6;                                   // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                    w.Write(this.data' blockOffset4' 16);                                  blockOffset4 += 16;                                  off4 += 16;                              }                          }                          else if (op == 2)                          {                              for (int j = 0; j < count; j++)                              {                                  w.Write(fullOpaqueAlpha' 0' 8);                                  w.Write(fullOpaqueAlpha' 0' 8);                                                                  // w.Write(this.data' blockOffset0' 2);                                 // w.Write(this.data' blockOffset1' 6);                                 // w.Write(this.data' blockOffset2' 4);                                 // w.Write(this.data' blockOffset3' 4);                                  blockOffset2 += 4;                                  blockOffset3 += 4;                                  blockOffset0 += 2;                                  blockOffset1 += 6;                              }                          }                          else                          {                              throw new NotSupportedException();                          }                      }                        if (blockOffset0 != nextMipHeader.Offset0 ||                          blockOffset1 != nextMipHeader.Offset1 ||                          blockOffset2 != nextMipHeader.Offset2 ||                          blockOffset3 != nextMipHeader.Offset3 ||                          blockOffset4 != nextMipHeader.Offset4)                      {                          throw new InvalidOperationException();                      }                  }                }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The following statement contains a magic number: if (rleVersion == RLEVersion.RLE2)              {                  var headerOffset = 16;                  var dataOffset = 16 + (20 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                      }                        this.data = output.ToArray();                  }              }              else              {                  var headerOffset = 16;                  var dataOffset = 16 + (24 * this.info.mipCount);                  this.MipHeaders = new MipHeader[this.info.mipCount];                    using (var commandData = new MemoryStream())                  using (var block2Data = new MemoryStream())                  using (var block3Data = new MemoryStream())                  using (var block0Data = new MemoryStream())                  using (var block1Data = new MemoryStream())                  using (var block4Data = new MemoryStream())                  {                      BinaryWriter commonDataWriter = new BinaryWriter(commandData);                      for (int mipIndex = 0; mipIndex < this.info.mipCount; mipIndex++)                      {                          this.MipHeaders[mipIndex] = new MipHeader()                          {                              CommandOffset = (int)commandData.Length'                              Offset2 = (int)block2Data.Length'                              Offset3 = (int)block3Data.Length'                              Offset0 = (int)block0Data.Length'                              Offset1 = (int)block1Data.Length'                              Offset4 = (int)block4Data.Length                          };                            var mipWidth = Math.Max(4' this.info.Width >> mipIndex);                          var mipHeight = Math.Max(4' this.info.Height >> mipIndex);                          var mipDepth = Math.Max(1' this.info.Depth >> mipIndex);                            var mipSize = Math.Max(1' (mipWidth + 3) / 4) * Math.Max(1' (mipHeight + 3) / 4) * 16;                          var mipData = r.ReadBytes(mipSize);                            for (int offset = 0; offset < mipSize; )                          {                              ushort transparentCount = 0;                              while (transparentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == false)                              {                                  transparentCount++;                                  offset += 16;                              }                                if (transparentCount > 0)                              {                                  transparentCount <<= 2;                                  transparentCount |= 0;                                  commonDataWriter.Write(transparentCount);                                  continue;                              }                                var opaqueOffset = offset;                              ushort opaqueCount = 0;                              while (opaqueCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == true)                              {                                  opaqueCount++;                                  offset += 16;                              }                                if (opaqueCount > 0)                              {                                  for (int i = 0; i < opaqueCount; i++' opaqueOffset += 16)                                  {                                      block0Data.Write(mipData' opaqueOffset + 0' 2);                                      block1Data.Write(mipData' opaqueOffset + 2' 6);                                      block2Data.Write(mipData' opaqueOffset + 8' 4);                                      block3Data.Write(mipData' opaqueOffset + 12' 4);                                     // block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    opaqueCount <<= 2;                                  opaqueCount |= 2;                                  commonDataWriter.Write(opaqueCount);                                  continue;                              }                                var translucentOffset = offset;                              ushort translucentCount = 0;                              while (translucentCount < 0x3FFF &&                                     offset < mipSize &&                                     TestAlphaAny(mipData' offset' a => a != 0) == true &&                                     TestAlphaAll(mipData' offset' a => a == 0xFF) == false)                              {                                  translucentCount++;                                  offset += 16;                              }                                if (translucentCount > 0)                              {                                  for (int i = 0; i < translucentCount; i++' translucentOffset += 16)                                  {                                      block0Data.Write(mipData' translucentOffset + 0' 2);                                      block1Data.Write(mipData' translucentOffset + 2' 6);                                      block2Data.Write(mipData' translucentOffset + 8' 4);                                      block3Data.Write(mipData' translucentOffset + 12' 4);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                      block4Data.Write(fullOpaqueAlpha' 0' 8);                                  }                                    translucentCount <<= 2;                                  translucentCount |= 1;                                  commonDataWriter.Write(translucentCount);                                  continue;                              }                                throw new NotImplementedException();                          }                      }                        output.Position = dataOffset;                        commandData.Position = 0;                      var commandOffset = (int)output.Position;                      output.Write(commandData.ToArray()' 0' (int)commandData.Length);                        block2Data.Position = 0;                      var block2Offset = (int)output.Position;                      output.Write(block2Data.ToArray()' 0' (int)block2Data.Length);                        block3Data.Position = 0;                      var block3Offset = (int)output.Position;                      output.Write(block3Data.ToArray()' 0' (int)block3Data.Length);                        block0Data.Position = 0;                      var block0Offset = (int)output.Position;                      output.Write(block0Data.ToArray()' 0' (int)block0Data.Length);                        block1Data.Position = 0;                      var block1Offset = (int)output.Position;                      output.Write(block1Data.ToArray()' 0' (int)block1Data.Length);                        block4Data.Position = 0;                      var block4Offset = (int)output.Position;                      output.Write(block4Data.ToArray()' 0' (int)block4Data.Length);                        output.Position = headerOffset;                      for (int i = 0; i < this.info.mipCount; i++)                      {                          var mipHeader = this.MipHeaders[i];                          w.Write(mipHeader.CommandOffset + commandOffset);                          w.Write(mipHeader.Offset2 + block2Offset);                          w.Write(mipHeader.Offset3 + block3Offset);                          w.Write(mipHeader.Offset0 + block0Offset);                          w.Write(mipHeader.Offset1 + block1Offset);                          w.Write(mipHeader.Offset4 + block4Offset);                      }                        this.data = output.ToArray();                  }              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: if (alpha[0] > alpha[1])              {                  alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + 3) / 7);                  alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + 3) / 7);                  alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + 3) / 7);                  alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + 3) / 7);                  alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + 3) / 7);                  alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + 3) / 7);              }              else              {                  alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + 2) / 5);                  alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + 2) / 5);                  alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + 2) / 5);                  alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + 2) / 5);                  alpha[6] = 0x00;                  alpha[7] = 0xFF;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: for (int i = 7; i >= 2; i--)              {                  bits <<= 8;                  bits |= array[offset + i];              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: for (int i = 7; i >= 2; i--)              {                  bits <<= 8;                  bits |= array[offset + i];              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,UnpackAlpha,The following statement contains a magic number: for (int i = 7; i >= 2; i--)              {                  bits <<= 8;                  bits |= array[offset + i];              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,TestAlphaAll,The following statement contains a magic number: var alpha = stackalloc byte[16];
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,TestAlphaAll,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (test(alpha[bits & 7]) == false)                  {                      return false;                  }                    bits >>= 3;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,TestAlphaAll,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (test(alpha[bits & 7]) == false)                  {                      return false;                  }                    bits >>= 3;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,TestAlphaAll,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (test(alpha[bits & 7]) == false)                  {                      return false;                  }                    bits >>= 3;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,TestAlphaAny,The following statement contains a magic number: var alpha = stackalloc byte[16];
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,TestAlphaAny,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (test(alpha[bits & 7]) == true)                  {                      return true;                  }                    bits >>= 3;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,TestAlphaAny,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (test(alpha[bits & 7]) == true)                  {                      return true;                  }                    bits >>= 3;              }
Magic Number,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,TestAlphaAny,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (test(alpha[bits & 7]) == true)                  {                      return true;                  }                    bits >>= 3;              }
Magic Number,s4pi.ImageResource,RLEInfo,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,Parse,The following statement contains a magic number: if (this.mipCount > 16) throw new InvalidDataException(string.Format("Expected mini map count less than 16' read 0x{0:X8}"' this.mipCount));
Magic Number,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,TransformToPNG,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(this.rawData))              {                  BinaryReader r = new BinaryReader(ms);                  Bitmap colorImage = new Bitmap(ms);                  ms.Position = 0;                  r.ReadBytes(24);                  if (r.ReadUInt32() == 0x41464C41U)                  {                      int length = r.ReadInt32();                      length = (int)((length & 0xFF000000) >> 24) | (int)((length & 0x00FF0000) >> 8) | (int)((length & 0x0000FF00) << 8) | (int)((length & 0x000000FF) << 24);                      using (MemoryStream alphaStream = new MemoryStream(r.ReadBytes(length)))                      {                          Bitmap alphaImage = new Bitmap(alphaStream);                          if (colorImage.Width != alphaImage.Width || colorImage.Height != alphaImage.Height) throw new InvalidDataException("Not a proper TS4 Thumbnail image");                          colorImage = UpdateAlpha(colorImage' alphaImage);                            this.image = colorImage;                          return;                      }                  }                  this.image = colorImage;              }
Magic Number,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,TransformToPNG,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(this.rawData))              {                  BinaryReader r = new BinaryReader(ms);                  Bitmap colorImage = new Bitmap(ms);                  ms.Position = 0;                  r.ReadBytes(24);                  if (r.ReadUInt32() == 0x41464C41U)                  {                      int length = r.ReadInt32();                      length = (int)((length & 0xFF000000) >> 24) | (int)((length & 0x00FF0000) >> 8) | (int)((length & 0x0000FF00) << 8) | (int)((length & 0x000000FF) << 24);                      using (MemoryStream alphaStream = new MemoryStream(r.ReadBytes(length)))                      {                          Bitmap alphaImage = new Bitmap(alphaStream);                          if (colorImage.Width != alphaImage.Width || colorImage.Height != alphaImage.Height) throw new InvalidDataException("Not a proper TS4 Thumbnail image");                          colorImage = UpdateAlpha(colorImage' alphaImage);                            this.image = colorImage;                          return;                      }                  }                  this.image = colorImage;              }
Magic Number,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,TransformToPNG,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(this.rawData))              {                  BinaryReader r = new BinaryReader(ms);                  Bitmap colorImage = new Bitmap(ms);                  ms.Position = 0;                  r.ReadBytes(24);                  if (r.ReadUInt32() == 0x41464C41U)                  {                      int length = r.ReadInt32();                      length = (int)((length & 0xFF000000) >> 24) | (int)((length & 0x00FF0000) >> 8) | (int)((length & 0x0000FF00) << 8) | (int)((length & 0x000000FF) << 24);                      using (MemoryStream alphaStream = new MemoryStream(r.ReadBytes(length)))                      {                          Bitmap alphaImage = new Bitmap(alphaStream);                          if (colorImage.Width != alphaImage.Width || colorImage.Height != alphaImage.Height) throw new InvalidDataException("Not a proper TS4 Thumbnail image");                          colorImage = UpdateAlpha(colorImage' alphaImage);                            this.image = colorImage;                          return;                      }                  }                  this.image = colorImage;              }
Magic Number,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,TransformToPNG,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(this.rawData))              {                  BinaryReader r = new BinaryReader(ms);                  Bitmap colorImage = new Bitmap(ms);                  ms.Position = 0;                  r.ReadBytes(24);                  if (r.ReadUInt32() == 0x41464C41U)                  {                      int length = r.ReadInt32();                      length = (int)((length & 0xFF000000) >> 24) | (int)((length & 0x00FF0000) >> 8) | (int)((length & 0x0000FF00) << 8) | (int)((length & 0x000000FF) << 24);                      using (MemoryStream alphaStream = new MemoryStream(r.ReadBytes(length)))                      {                          Bitmap alphaImage = new Bitmap(alphaStream);                          if (colorImage.Width != alphaImage.Width || colorImage.Height != alphaImage.Height) throw new InvalidDataException("Not a proper TS4 Thumbnail image");                          colorImage = UpdateAlpha(colorImage' alphaImage);                            this.image = colorImage;                          return;                      }                  }                  this.image = colorImage;              }
Magic Number,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,TransformToPNG,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(this.rawData))              {                  BinaryReader r = new BinaryReader(ms);                  Bitmap colorImage = new Bitmap(ms);                  ms.Position = 0;                  r.ReadBytes(24);                  if (r.ReadUInt32() == 0x41464C41U)                  {                      int length = r.ReadInt32();                      length = (int)((length & 0xFF000000) >> 24) | (int)((length & 0x00FF0000) >> 8) | (int)((length & 0x0000FF00) << 8) | (int)((length & 0x000000FF) << 24);                      using (MemoryStream alphaStream = new MemoryStream(r.ReadBytes(length)))                      {                          Bitmap alphaImage = new Bitmap(alphaStream);                          if (colorImage.Width != alphaImage.Width || colorImage.Height != alphaImage.Height) throw new InvalidDataException("Not a proper TS4 Thumbnail image");                          colorImage = UpdateAlpha(colorImage' alphaImage);                            this.image = colorImage;                          return;                      }                  }                  this.image = colorImage;              }
Magic Number,s4pi.ImageResource,ThumbnailResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,ComputeAlpha,The following statement contains a magic number: for (int i = 0; i < height; i++)                  for (int j = 0; j < width; j++)                  {                      ColorARGB* sourcePosition = sourceStartingPosition + j + i * width;                      ColorARGB* alphaPosition = alphaStartingPosition + j + i * width;                      ColorRGB* imgPosition = imgStartingPosition + j + i * width;                      *imgPosition = new ColorRGB(sourcePosition);                      *alphaPosition = new ColorARGB(255' sourcePosition->A' sourcePosition->A' sourcePosition->A);                  }
Magic Number,s4pi.ImageResource,ColorARGB,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,ColorARGB,The following statement contains a magic number: this.A = 255;
Magic Number,s4pi.ImageResource,ColorARGB,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,ColorARGB,The following statement contains a magic number: A = (byte)(color >> 24);
Magic Number,s4pi.ImageResource,ColorARGB,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,ColorARGB,The following statement contains a magic number: R = (byte)((color & 0xFF0000) >> 16);
Magic Number,s4pi.ImageResource,ColorARGB,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ThumbnailResource.cs,ColorARGB,The following statement contains a magic number: G = (byte)((color & 0xFF00) >> 8);
Magic Number,ImageResource,ImageResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ImageResource.cs,ImageResource,The following statement contains a magic number: (new Bitmap(128' 128)).Save(stream' System.Drawing.Imaging.ImageFormat.Png);
Magic Number,ImageResource,ImageResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ImageResource.cs,ImageResource,The following statement contains a magic number: (new Bitmap(128' 128)).Save(stream' System.Drawing.Imaging.ImageFormat.Png);
Magic Number,ImageResource,ImageResourceHandler,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\ImageResource.cs,ImageResourceHandler,The following statement contains a magic number: while ((s = sr.ReadLine()) != null)              {                  string[] t = s.Split(new char[] { ' ' }' 2);                  resourceTypes.Add(t[0]);              }
Duplicate Code,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ToDDS,The method contains a code clone-set at the following line numbers (starting from the method definition): ((27' 52)' (101' 126))
Duplicate Code,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 92)' (194' 235))
Duplicate Code,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((95' 121)' (241' 267))
Duplicate Code,s4pi.ImageResource,RLEResource,C:\repos\Sims4Group_Sims4Tools\s4pi Wrappers\ImageResource\RLEResource.cs,ImportToRLE,The method contains a code clone-set at the following line numbers (starting from the method definition): ((122' 155)' (270' 303))
