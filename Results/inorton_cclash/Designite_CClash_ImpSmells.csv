Implementation smell,Namespace,Class,File,Method,Description
Long Method,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The method has 242 lines of code.
Long Method,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The method has 136 lines of code.
Long Method,CClash,Program,C:\repos\inorton_cclash\CClash\Program.cs,Main,The method has 171 lines of code.
Complex Method,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,Listen,Cyclomatic complexity of the method is 10
Complex Method,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,Cyclomatic complexity of the method is 12
Complex Method,CClash,DirectCompilerCache,C:\repos\inorton_cclash\CClash\DirectCompilerCache.cs,CheckCache,Cyclomatic complexity of the method is 15
Complex Method,CClash,FileCacheDatabase,C:\repos\inorton_cclash\CClash\FileCacheDatabase.cs,Open,Cyclomatic complexity of the method is 8
Complex Method,CClash,Program,C:\repos\inorton_cclash\CClash\Program.cs,Main,Cyclomatic complexity of the method is 20
Long Parameter List,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,InvokeCompiler,The method has 5 parameters. Parameters: args' onStdErr' onStdOut' showIncludes' foundIncludes
Long Parameter List,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The method has 5 parameters. Parameters: args' onStdErr' onStdOut' showIncludes' foundIncludes
Long Parameter List,CClash,DirectCompilerCache,C:\repos\inorton_cclash\CClash\DirectCompilerCache.cs,Compile,The method has 5 parameters. Parameters: comp' args' stderr' stdout' includes
Long Parameter List,CClash,DirectCompilerCache,C:\repos\inorton_cclash\CClash\DirectCompilerCache.cs,DoCacheMiss,The method has 5 parameters. Parameters: c' hc' args' req' ifiles
Long Parameter List,CClash,CompilerCacheFactory,C:\repos\inorton_cclash\CClash\CompilerCacheBase.cs,Get,The method has 6 parameters. Parameters: direct' cachedir' compiler' workdir' envs' comp
Long Parameter List,CClash,CompilerCacheBase,C:\repos\inorton_cclash\CClash\CompilerCacheBase.cs,CompileWithStreams,The method has 5 parameters. Parameters: comp' args' stderr' stdout' includes
Long Parameter List,CClash,ICompiler,C:\repos\inorton_cclash\CClash\ICompiler.cs,InvokeCompiler,The method has 5 parameters. Parameters: args' onStdErr' onStdOut' showIncludes' foundIncludes
Long Parameter List,CClash,Logging,C:\repos\inorton_cclash\CClash\Logging.cs,Miss,The method has 5 parameters. Parameters: hc' reason' dir' srcfile' headerfile
Long Statement,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,NewServerThread,The length of the statement  "            var nss = new NamedPipeServerStream(MakePipeName(cachedir)' PipeDirection.InOut' MaxServerThreads' PipeTransmissionMode.Message' PipeOptions.WriteThrough | PipeOptions.Asynchronous); " is 182.
Long Statement,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,NewServerThread,The length of the statement  "                var npa = new PipeAccessRule("Everyone"' PipeAccessRights.ReadWrite' System.Security.AccessControl.AccessControlType.Allow); " is 124.
Long Statement,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The length of the statement  "                                    Logging.Emit("compiler didn't write expected object! {0} after {1}ms"' ObjectTarget' (int)sw.Elapsed.TotalMilliseconds); " is 120.
Long Statement,CClash,DirectCompilerCache,C:\repos\inorton_cclash\CClash\DirectCompilerCache.cs,CheckCache,The length of the statement  "                        Logging.Miss(commonkey.SessionHash' DataHashResult.FileAdded' Directory.GetCurrentDirectory()' comp.SingleSourceFile' f); " is 121.
Long Statement,CClash,DirectCompilerCache,C:\repos\inorton_cclash\CClash\DirectCompilerCache.cs,CheckCache,The length of the statement  "                                Logging.Miss(commonkey.SessionHash' DataHashResult.FileChanged' Directory.GetCurrentDirectory()' comp.SingleSourceFile' h.Key); " is 127.
Long Statement,CClash,DirectCompilerCache,C:\repos\inorton_cclash\CClash\DirectCompilerCache.cs,CheckCache,The length of the statement  "                            Logging.Miss(commonkey.SessionHash' DataHashResult.FileAdded' Directory.GetCurrentDirectory()' comp.SingleSourceFile' h.Key); " is 125.
Long Statement,CClash,FileUtils,C:\repos\inorton_cclash\CClash\FileUtils.cs,CopyUnlocked,The length of the statement  "                    using (var ifs = new FileStream(from' FileMode.Open' FileAccess.Read' FileShare.Read' 4096' FileOptions.SequentialScan)) " is 120.
Long Statement,CClash,Program,C:\repos\inorton_cclash\CClash\Program.cs,Main,The length of the statement  "                        CompilerCacheFactory.Get(Settings.DirectMode' Settings.CacheDirectory' compiler' Environment.CurrentDirectory' Compiler.GetEnvironmentDictionary()' out comp)) " is 158.
Long Statement,CClash,Program,C:\repos\inorton_cclash\CClash\Program.cs,RunBuild,The length of the statement  "                        CompilerCacheFactory.Get(Settings.DirectMode' cachedir' compiler' Environment.CurrentDirectory' Compiler.GetEnvironmentDictionary()' out comp)) " is 143.
Virtual Method Call from Constructor,CClash,DirectCompilerCacheServer,C:\repos\inorton_cclash\CClash\DirectCompilerCacheServer.cs,DirectCompilerCacheServer,The constructor "DirectCompilerCacheServer" calls a virtual method "Lock".
Empty Catch Block,CClash,CClashServerClient,C:\repos\inorton_cclash\CClash\CClashServerClient.cs,Connect,The method has an empty catch block.
Empty Catch Block,CClash,Logging,C:\repos\inorton_cclash\CClash\Logging.cs,Emit,The method has an empty catch block.
Empty Catch Block,CClash,ProcessUtils,C:\repos\inorton_cclash\CClash\ProcessUtils.cs,GetParentProcessName,The method has an empty catch block.
Magic Number,CClash,ArgumentUtils,C:\repos\inorton_cclash\CClash\ArgumentUtils.cs,JoinAguments,The following statement contains a magic number: var sb = new System.Text.StringBuilder(512);
Magic Number,CClash,ArgumentUtils,C:\repos\inorton_cclash\CClash\ArgumentUtils.cs,FixupArgs,The following statement contains a magic number: for (int i = 0; i < aa.Length; i++)              {                  var a = aa[i];                  if ( CanonicalArgument(a) == "/D" )                  {                      string val;                      if (a.Length == 2 && (i + 1 < aa.Length))                      {                          val = aa[++i];                      }                      else                      {                          val = a.Substring(2);                      }                        if (val.Contains("=\""))                      {                          val = Regex.Replace(val' "\""' "\"\"\"");                      }                        rv.Add("/D" + val);                  }                  else                  {                      rv.Add(a);                  }              }
Magic Number,CClash,ArgumentUtils,C:\repos\inorton_cclash\CClash\ArgumentUtils.cs,FixupArgs,The following statement contains a magic number: for (int i = 0; i < aa.Length; i++)              {                  var a = aa[i];                  if ( CanonicalArgument(a) == "/D" )                  {                      string val;                      if (a.Length == 2 && (i + 1 < aa.Length))                      {                          val = aa[++i];                      }                      else                      {                          val = a.Substring(2);                      }                        if (val.Contains("=\""))                      {                          val = Regex.Replace(val' "\""' "\"\"\"");                      }                        rv.Add("/D" + val);                  }                  else                  {                      rv.Add(a);                  }              }
Magic Number,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,Preflight,The following statement contains a magic number: try              {                  if (!mtx.WaitOne(1000))                  {                      quitnow = true;                      Logging.Error("another server is already running");                      return false; // some other process is holding it!                  }                  else                  {                      Logging.Emit("cclash server preflight ok");                  }              }              catch (AbandonedMutexException)              {                  Logging.Warning("previous instance did not exit cleanly!");              }
Magic Number,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,ThreadBeforeProcessRequest,The following statement contains a magic number: if (BusyThreadCount > Environment.ProcessorCount)              {                  System.Threading.Thread.Sleep(60/Environment.ProcessorCount);              }
Magic Number,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,ConnectionThreadFn,The following statement contains a magic number: using (var nss = con as NamedPipeServerStream)              {                  try                  {                                            while (!quitnow)                      {                          var w = nss.BeginWaitForConnection(null' null);                          FirstThreadReady = true;                          Logging.Emit("waiting for client..");                          while (!w.AsyncWaitHandle.WaitOne(1000))                          {                              if (quitnow)                              {                                  return;                              }                          }                          nss.EndWaitForConnection(w);                          Logging.Emit("got client");                          if (nss.IsConnected)                          {                              Logging.Emit("server connected");                              ThreadBeforeProcessRequest();                              ThreadIsBusy();                              ServiceRequest(nss);                          }                                                    ThreadIsIdle();                      }                  }                  catch (IOException ex)                  {                      Logging.Error("server thread got {0}' {1}"' ex.GetType().Name' ex.Message);                      Logging.Error(":{0}"' ex.ToString());                  }              }
Magic Number,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,ServiceRequest,The following statement contains a magic number: var msgbuf = new List<byte>(8192);
Magic Number,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,ServiceRequest,The following statement contains a magic number: var rxbuf = new byte[256 * 1024];
Magic Number,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,ServiceRequest,The following statement contains a magic number: var rxbuf = new byte[256 * 1024];
Magic Number,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,Listen,The following statement contains a magic number: while (!quitnow)              {                  foreach (var t in serverThreads.ToArray())                  {                      if (busyThreads > 0)                          Logging.Emit("{0} busy threads"' busyThreads);                      if (t.Join(1000))                      {                          serverThreads.Remove(t);                          Logging.Emit("replacing thread");                          NewServerThread(cachedir);                      }                  }                  if (busyThreads < 1) {                      Logging.Emit("server is idle..");                  }                  if (DateTime.Now.Subtract(lastRequest).TotalMinutes > QuitAfterIdleMinutes)                  {                      quitnow = true;                  }              }
Magic Number,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,Listen,The following statement contains a magic number: foreach (var t in serverThreads)              {                  Logging.Emit("joining thread {0}"' t.ManagedThreadId);                  if (!t.Join(2000)) {                      Logging.Emit("thread still running..");                  }              }
Magic Number,CClash,CClashServerClient,C:\repos\inorton_cclash\CClash\CClashServerClient.cs,StartBackgroundServer,The following statement contains a magic number: using (var ssm = new System.Threading.Mutex(false' "cclash_server_spawn")) {                  var can_start_server = ssm.WaitOne(500);                  try {                      if (can_start_server) {                          Logging.Emit("starting new server");                          // start the server                          var p = new Process();                          var ours = FileUtils.GetShortPath( typeof(CClashServerClient).Assembly.Location);                          var exedir = Path.GetDirectoryName(ours);                          var exepath = Path.Combine(exedir' "cclash.exe");                          if (!File.Exists(exepath)) {                              exepath = ours;                          }                          var pargs = new List<string>                                  {                                      exepath'                                      "--cclash-server"                                  };                          if (Settings.DebugFile != null) {                              pargs.Add("--debug");                          }                            var command = "cmd";                          var command_args = "/c " + string.Join(" "' pargs.ToArray());                            p.StartInfo = new ProcessStartInfo(command);                          p.StartInfo.UseShellExecute = false;                          p.StartInfo.CreateNoWindow = true;                          p.StartInfo.Arguments = command_args;                          p.StartInfo.ErrorDialog = false;                          p.StartInfo.WorkingDirectory = Path.GetPathRoot(Environment.CurrentDirectory);                          p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;                          p.Start();                      }                      System.Threading.Thread.Sleep(1000);                  } finally {                      if (can_start_server) {                          ssm.ReleaseMutex();                      }                  }              }
Magic Number,CClash,CClashServerClient,C:\repos\inorton_cclash\CClash\CClashServerClient.cs,StartBackgroundServer,The following statement contains a magic number: using (var ssm = new System.Threading.Mutex(false' "cclash_server_spawn")) {                  var can_start_server = ssm.WaitOne(500);                  try {                      if (can_start_server) {                          Logging.Emit("starting new server");                          // start the server                          var p = new Process();                          var ours = FileUtils.GetShortPath( typeof(CClashServerClient).Assembly.Location);                          var exedir = Path.GetDirectoryName(ours);                          var exepath = Path.Combine(exedir' "cclash.exe");                          if (!File.Exists(exepath)) {                              exepath = ours;                          }                          var pargs = new List<string>                                  {                                      exepath'                                      "--cclash-server"                                  };                          if (Settings.DebugFile != null) {                              pargs.Add("--debug");                          }                            var command = "cmd";                          var command_args = "/c " + string.Join(" "' pargs.ToArray());                            p.StartInfo = new ProcessStartInfo(command);                          p.StartInfo.UseShellExecute = false;                          p.StartInfo.CreateNoWindow = true;                          p.StartInfo.Arguments = command_args;                          p.StartInfo.ErrorDialog = false;                          p.StartInfo.WorkingDirectory = Path.GetPathRoot(Environment.CurrentDirectory);                          p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;                          p.Start();                      }                      System.Threading.Thread.Sleep(1000);                  } finally {                      if (can_start_server) {                          ssm.ReleaseMutex();                      }                  }              }
Magic Number,CClash,CClashServerClient,C:\repos\inorton_cclash\CClash\CClashServerClient.cs,ConnectClient,The following statement contains a magic number: if (!ncs.IsConnected)                  ncs.Connect(500);
Magic Number,CClash,CClashServerClient,C:\repos\inorton_cclash\CClash\CClashServerClient.cs,Transact,The following statement contains a magic number: var rxbuf = new byte[8192];
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,cygwinEnvFixup,The following statement contains a magic number: foreach (var e in lines)              {                  var pair = e.Split(new char[] { '=' }' 2);                  var haslow = false;                  foreach (var c in pair[0])                  {                      if (char.IsLower(c))                      {                          haslow = true;                          break;                      }                  }                    if (haslow)                  {                      Environment.SetEnvironmentVariable(pair[0]' null);                      Environment.SetEnvironmentVariable(pair[0].ToUpper()' pair[1]);                  }              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,getOption,The following statement contains a magic number: if (canon.StartsWith("/"))              {                  if (canon == "/link")                      return canon;                  if (canon.Length > 2)                      canon = canon.Substring(0' 3);                  return canon;              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,getOption,The following statement contains a magic number: if (canon.StartsWith("/"))              {                  if (canon == "/link")                      return canon;                  if (canon.Length > 2)                      canon = canon.Substring(0' 3);                  return canon;              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: try              {                  DisableTracker();                  CommandLine = args;                  for (int i = 0; i < args.Length; i++)                  {                      var opt = getOption(args[i]);                      var full = getFullOption(args[i]);                        onlyOptions.Add(full);                        #region switch process each argument type                      switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }                      #endregion                    }                                    if (SingleSource)                  {                      var defaultObj = ArgumentUtils.TargetObject(Path.GetFileNameWithoutExtension(SingleSourceFile));                                               if (ObjectTarget == null)                      {                          if (Path.IsPathRooted(defaultObj))                          {                              ObjectTarget = defaultObj;                          }                          else                          {                              ObjectTarget = Path.Combine(WorkingDirectory' defaultObj);                          }                      }                        if (ObjectTargetIsFolder)                      {                          ObjectTarget = Path.Combine(ObjectTarget' defaultObj);                      }                        if (GeneratePdb)                      {                          if (Settings.ConvertObjPdbToZ7)                          {                              Logging.Emit("converting pdb request to Z7 embedded debug {0}:{1}"' WorkingDirectory' Path.GetFileName(ObjectTarget));                              // append /Z7 to the arg list and don't generate a pdb                              var newargs = new List<string>();                              foreach (var a in args)                              {                                  if (!(a.StartsWith("/Zi") || a.StartsWith("/Fd")))                                  {                                      newargs.Add(a);                                  }                              }                              newargs.Add("/Z7");                              AttemptPdb = false;                              PdbFile = null;                              GeneratePdb = false;                              PdbExistsAlready = false;                              args = newargs.ToArray();                          }                      }                        if (GeneratePdb)                       {                          return NotSupported("PDB file requested");                      }                  }              }              catch (Exception e)              {                  Console.Error.WriteLine(e);                  return NotSupported("option parser exception '{0}'"' e);              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: try              {                  DisableTracker();                  CommandLine = args;                  for (int i = 0; i < args.Length; i++)                  {                      var opt = getOption(args[i]);                      var full = getFullOption(args[i]);                        onlyOptions.Add(full);                        #region switch process each argument type                      switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }                      #endregion                    }                                    if (SingleSource)                  {                      var defaultObj = ArgumentUtils.TargetObject(Path.GetFileNameWithoutExtension(SingleSourceFile));                                               if (ObjectTarget == null)                      {                          if (Path.IsPathRooted(defaultObj))                          {                              ObjectTarget = defaultObj;                          }                          else                          {                              ObjectTarget = Path.Combine(WorkingDirectory' defaultObj);                          }                      }                        if (ObjectTargetIsFolder)                      {                          ObjectTarget = Path.Combine(ObjectTarget' defaultObj);                      }                        if (GeneratePdb)                      {                          if (Settings.ConvertObjPdbToZ7)                          {                              Logging.Emit("converting pdb request to Z7 embedded debug {0}:{1}"' WorkingDirectory' Path.GetFileName(ObjectTarget));                              // append /Z7 to the arg list and don't generate a pdb                              var newargs = new List<string>();                              foreach (var a in args)                              {                                  if (!(a.StartsWith("/Zi") || a.StartsWith("/Fd")))                                  {                                      newargs.Add(a);                                  }                              }                              newargs.Add("/Z7");                              AttemptPdb = false;                              PdbFile = null;                              GeneratePdb = false;                              PdbExistsAlready = false;                              args = newargs.ToArray();                          }                      }                        if (GeneratePdb)                       {                          return NotSupported("PDB file requested");                      }                  }              }              catch (Exception e)              {                  Console.Error.WriteLine(e);                  return NotSupported("option parser exception '{0}'"' e);              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: try              {                  DisableTracker();                  CommandLine = args;                  for (int i = 0; i < args.Length; i++)                  {                      var opt = getOption(args[i]);                      var full = getFullOption(args[i]);                        onlyOptions.Add(full);                        #region switch process each argument type                      switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }                      #endregion                    }                                    if (SingleSource)                  {                      var defaultObj = ArgumentUtils.TargetObject(Path.GetFileNameWithoutExtension(SingleSourceFile));                                               if (ObjectTarget == null)                      {                          if (Path.IsPathRooted(defaultObj))                          {                              ObjectTarget = defaultObj;                          }                          else                          {                              ObjectTarget = Path.Combine(WorkingDirectory' defaultObj);                          }                      }                        if (ObjectTargetIsFolder)                      {                          ObjectTarget = Path.Combine(ObjectTarget' defaultObj);                      }                        if (GeneratePdb)                      {                          if (Settings.ConvertObjPdbToZ7)                          {                              Logging.Emit("converting pdb request to Z7 embedded debug {0}:{1}"' WorkingDirectory' Path.GetFileName(ObjectTarget));                              // append /Z7 to the arg list and don't generate a pdb                              var newargs = new List<string>();                              foreach (var a in args)                              {                                  if (!(a.StartsWith("/Zi") || a.StartsWith("/Fd")))                                  {                                      newargs.Add(a);                                  }                              }                              newargs.Add("/Z7");                              AttemptPdb = false;                              PdbFile = null;                              GeneratePdb = false;                              PdbExistsAlready = false;                              args = newargs.ToArray();                          }                      }                        if (GeneratePdb)                       {                          return NotSupported("PDB file requested");                      }                  }              }              catch (Exception e)              {                  Console.Error.WriteLine(e);                  return NotSupported("option parser exception '{0}'"' e);              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: try              {                  DisableTracker();                  CommandLine = args;                  for (int i = 0; i < args.Length; i++)                  {                      var opt = getOption(args[i]);                      var full = getFullOption(args[i]);                        onlyOptions.Add(full);                        #region switch process each argument type                      switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }                      #endregion                    }                                    if (SingleSource)                  {                      var defaultObj = ArgumentUtils.TargetObject(Path.GetFileNameWithoutExtension(SingleSourceFile));                                               if (ObjectTarget == null)                      {                          if (Path.IsPathRooted(defaultObj))                          {                              ObjectTarget = defaultObj;                          }                          else                          {                              ObjectTarget = Path.Combine(WorkingDirectory' defaultObj);                          }                      }                        if (ObjectTargetIsFolder)                      {                          ObjectTarget = Path.Combine(ObjectTarget' defaultObj);                      }                        if (GeneratePdb)                      {                          if (Settings.ConvertObjPdbToZ7)                          {                              Logging.Emit("converting pdb request to Z7 embedded debug {0}:{1}"' WorkingDirectory' Path.GetFileName(ObjectTarget));                              // append /Z7 to the arg list and don't generate a pdb                              var newargs = new List<string>();                              foreach (var a in args)                              {                                  if (!(a.StartsWith("/Zi") || a.StartsWith("/Fd")))                                  {                                      newargs.Add(a);                                  }                              }                              newargs.Add("/Z7");                              AttemptPdb = false;                              PdbFile = null;                              GeneratePdb = false;                              PdbExistsAlready = false;                              args = newargs.ToArray();                          }                      }                        if (GeneratePdb)                       {                          return NotSupported("PDB file requested");                      }                  }              }              catch (Exception e)              {                  Console.Error.WriteLine(e);                  return NotSupported("option parser exception '{0}'"' e);              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: try              {                  DisableTracker();                  CommandLine = args;                  for (int i = 0; i < args.Length; i++)                  {                      var opt = getOption(args[i]);                      var full = getFullOption(args[i]);                        onlyOptions.Add(full);                        #region switch process each argument type                      switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }                      #endregion                    }                                    if (SingleSource)                  {                      var defaultObj = ArgumentUtils.TargetObject(Path.GetFileNameWithoutExtension(SingleSourceFile));                                               if (ObjectTarget == null)                      {                          if (Path.IsPathRooted(defaultObj))                          {                              ObjectTarget = defaultObj;                          }                          else                          {                              ObjectTarget = Path.Combine(WorkingDirectory' defaultObj);                          }                      }                        if (ObjectTargetIsFolder)                      {                          ObjectTarget = Path.Combine(ObjectTarget' defaultObj);                      }                        if (GeneratePdb)                      {                          if (Settings.ConvertObjPdbToZ7)                          {                              Logging.Emit("converting pdb request to Z7 embedded debug {0}:{1}"' WorkingDirectory' Path.GetFileName(ObjectTarget));                              // append /Z7 to the arg list and don't generate a pdb                              var newargs = new List<string>();                              foreach (var a in args)                              {                                  if (!(a.StartsWith("/Zi") || a.StartsWith("/Fd")))                                  {                                      newargs.Add(a);                                  }                              }                              newargs.Add("/Z7");                              AttemptPdb = false;                              PdbFile = null;                              GeneratePdb = false;                              PdbExistsAlready = false;                              args = newargs.ToArray();                          }                      }                        if (GeneratePdb)                       {                          return NotSupported("PDB file requested");                      }                  }              }              catch (Exception e)              {                  Console.Error.WriteLine(e);                  return NotSupported("option parser exception '{0}'"' e);              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: try              {                  DisableTracker();                  CommandLine = args;                  for (int i = 0; i < args.Length; i++)                  {                      var opt = getOption(args[i]);                      var full = getFullOption(args[i]);                        onlyOptions.Add(full);                        #region switch process each argument type                      switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }                      #endregion                    }                                    if (SingleSource)                  {                      var defaultObj = ArgumentUtils.TargetObject(Path.GetFileNameWithoutExtension(SingleSourceFile));                                               if (ObjectTarget == null)                      {                          if (Path.IsPathRooted(defaultObj))                          {                              ObjectTarget = defaultObj;                          }                          else                          {                              ObjectTarget = Path.Combine(WorkingDirectory' defaultObj);                          }                      }                        if (ObjectTargetIsFolder)                      {                          ObjectTarget = Path.Combine(ObjectTarget' defaultObj);                      }                        if (GeneratePdb)                      {                          if (Settings.ConvertObjPdbToZ7)                          {                              Logging.Emit("converting pdb request to Z7 embedded debug {0}:{1}"' WorkingDirectory' Path.GetFileName(ObjectTarget));                              // append /Z7 to the arg list and don't generate a pdb                              var newargs = new List<string>();                              foreach (var a in args)                              {                                  if (!(a.StartsWith("/Zi") || a.StartsWith("/Fd")))                                  {                                      newargs.Add(a);                                  }                              }                              newargs.Add("/Z7");                              AttemptPdb = false;                              PdbFile = null;                              GeneratePdb = false;                              PdbExistsAlready = false;                              args = newargs.ToArray();                          }                      }                        if (GeneratePdb)                       {                          return NotSupported("PDB file requested");                      }                  }              }              catch (Exception e)              {                  Console.Error.WriteLine(e);                  return NotSupported("option parser exception '{0}'"' e);              }
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,GetUsedIncludeDirs,The following statement contains a magic number: var tmplist = new List<string>(1000);
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ScheduleLaterDelete,The following statement contains a magic number: System.Threading.ThreadPool.QueueUserWorkItem((x) =>              {                  for (int i = 0; i < 5; i++)                  {                      try                      {                          Directory.Delete(folder' true);                          return;                      }                      catch (System.IO.IOException)                      {                          System.Threading.Thread.Sleep(2000);                      }                  }              });
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,ScheduleLaterDelete,The following statement contains a magic number: System.Threading.ThreadPool.QueueUserWorkItem((x) =>              {                  for (int i = 0; i < 5; i++)                  {                      try                      {                          Directory.Delete(folder' true);                          return;                      }                      catch (System.IO.IOException)                      {                          System.Threading.Thread.Sleep(2000);                      }                  }              });
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The following statement contains a magic number: do              {                  retry = false;                  Logging.Emit("invoking real compiler: {0} {1} [{2}]"' CompilerExe' WorkingDirectory' string.Join(" "' args.ToArray()));                    if (string.IsNullOrWhiteSpace(CompilerExe) || !FileUtils.Exists(CompilerExe))                      throw new FileNotFoundException("cant find cl.exe");                    if (string.IsNullOrWhiteSpace(compworkdir))                      throw new InvalidOperationException("no working directory set");                    if (compenvs == null || compenvs.Count == 0)                      throw new InvalidOperationException("no environment set");                    var cla = ArgumentUtils.JoinAguments(ArgumentUtils.FixupArgs(args));                                  var runExe = compilerExe;                    if (showIncludes)                  {                      foundIncludes.Add(SingleSourceFile);                      if (TrackerEnabled)                      {                          runExe = "tracker.exe";                          var trackerargs = new List<string> {                              "/if"' Path.Combine(WorkingDirectory' TrackerFolder)'                              "/k"' "/t"                          };                          var tcla = ArgumentUtils.JoinAguments(trackerargs);                          cla = String.Format("{0} /c \"{1}\" {2}"' tcla' compilerExe' cla);                      }                      else                      {                          cla += " /showIncludes";                      }                  }                    var psi = new ProcessStartInfo(runExe' cla)                  {                      UseShellExecute = false'                      RedirectStandardError = true'                      RedirectStandardOutput = true'                      WorkingDirectory = compworkdir'                  };                    psi.EnvironmentVariables.Clear();                  foreach (var row in compenvs)                  {                      psi.EnvironmentVariables[row.Key] = row.Value;                  }                  psi.EnvironmentVariables["PATH"] = Path.GetDirectoryName(CompilerExe) + ";" + psi.EnvironmentVariables["PATH"];                  psi.ErrorDialog = true;                  var p = Process.Start(psi);                    p.OutputDataReceived += (o' a) =>                  {                      if (a.Data != null)                      {                                                    if (showIncludes && a.Data.StartsWith("Note: including file:"))                          {                              var inc = a.Data.Substring("Note: including file:".Length + 1).TrimStart(' ');                              if (inc.Contains('/'))                              {                                  inc = inc.Replace('/'' '\\');                              }                              foundIncludes.Add(inc);                          }                          else                          {                              if (StdOutputCallback != null) {                                  StdOutputCallback(a.Data + Environment.NewLine);                              }                              if (onStdOut != null) {                                  onStdOut(a.Data + Environment.NewLine);                              }                              if (Settings.DebugEnabled)                                  Logging.Emit("stdout {0}"' a.Data);                          }                      }                    };                    p.ErrorDataReceived += (o' a) =>                  {                      if (a.Data != null)                      {                          if (StdErrorCallback != null) {                              StdErrorCallback(a.Data + Environment.NewLine);                          }                          if (onStdErr != null) {                              onStdErr(a.Data + Environment.NewLine);                          }                          if (Settings.DebugEnabled)                              Logging.Emit("stderr {0}"' a.Data);                      }                  };                    p.BeginErrorReadLine();                  p.BeginOutputReadLine();                    p.WaitForExit();                                    rv = p.ExitCode;                  p.Close();                  Logging.Emit("cl exit {0}"' rv);                  if (rv == 0)                  {                      if (IsSupported)                      {                          if (!string.IsNullOrEmpty(ObjectTarget))                          {                              var sw = new Stopwatch();                              sw.Start();                              while (!File.Exists(ObjectTarget) && (sw.ElapsedMilliseconds < WaitForSlowObject))                              {                                                                  System.Threading.Thread.Sleep(500);                              }                              sw.Stop();                                if (!File.Exists(ObjectTarget))                              {                                  retry = true;                                  if (sw.ElapsedMilliseconds > 2000)                                  {                                      Logging.Emit("compiler didn't write expected object! {0} after {1}ms"' ObjectTarget' (int)sw.Elapsed.TotalMilliseconds);                                      retry = false;                                  }                                  string logmsg = string.Format("cl exited with zero but failed to create the expected object file! {0}"' ObjectTarget);                                  // let the retry system have a go with this                                    if (retry)                                      Logging.Warning("{0}' re-running!"' logmsg);                              }                              else                              {                                  Logging.Emit("output: {0} seen"' ObjectTarget);                              }                          }                      }                  }                    if (rv != 0)                  {                      Logging.Emit("non-zero exit");                  }              } while (retry);
Magic Number,CClash,Compiler,C:\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The following statement contains a magic number: do              {                  retry = false;                  Logging.Emit("invoking real compiler: {0} {1} [{2}]"' CompilerExe' WorkingDirectory' string.Join(" "' args.ToArray()));                    if (string.IsNullOrWhiteSpace(CompilerExe) || !FileUtils.Exists(CompilerExe))                      throw new FileNotFoundException("cant find cl.exe");                    if (string.IsNullOrWhiteSpace(compworkdir))                      throw new InvalidOperationException("no working directory set");                    if (compenvs == null || compenvs.Count == 0)                      throw new InvalidOperationException("no environment set");                    var cla = ArgumentUtils.JoinAguments(ArgumentUtils.FixupArgs(args));                                  var runExe = compilerExe;                    if (showIncludes)                  {                      foundIncludes.Add(SingleSourceFile);                      if (TrackerEnabled)                      {                          runExe = "tracker.exe";                          var trackerargs = new List<string> {                              "/if"' Path.Combine(WorkingDirectory' TrackerFolder)'                              "/k"' "/t"                          };                          var tcla = ArgumentUtils.JoinAguments(trackerargs);                          cla = String.Format("{0} /c \"{1}\" {2}"' tcla' compilerExe' cla);                      }                      else                      {                          cla += " /showIncludes";                      }                  }                    var psi = new ProcessStartInfo(runExe' cla)                  {                      UseShellExecute = false'                      RedirectStandardError = true'                      RedirectStandardOutput = true'                      WorkingDirectory = compworkdir'                  };                    psi.EnvironmentVariables.Clear();                  foreach (var row in compenvs)                  {                      psi.EnvironmentVariables[row.Key] = row.Value;                  }                  psi.EnvironmentVariables["PATH"] = Path.GetDirectoryName(CompilerExe) + ";" + psi.EnvironmentVariables["PATH"];                  psi.ErrorDialog = true;                  var p = Process.Start(psi);                    p.OutputDataReceived += (o' a) =>                  {                      if (a.Data != null)                      {                                                    if (showIncludes && a.Data.StartsWith("Note: including file:"))                          {                              var inc = a.Data.Substring("Note: including file:".Length + 1).TrimStart(' ');                              if (inc.Contains('/'))                              {                                  inc = inc.Replace('/'' '\\');                              }                              foundIncludes.Add(inc);                          }                          else                          {                              if (StdOutputCallback != null) {                                  StdOutputCallback(a.Data + Environment.NewLine);                              }                              if (onStdOut != null) {                                  onStdOut(a.Data + Environment.NewLine);                              }                              if (Settings.DebugEnabled)                                  Logging.Emit("stdout {0}"' a.Data);                          }                      }                    };                    p.ErrorDataReceived += (o' a) =>                  {                      if (a.Data != null)                      {                          if (StdErrorCallback != null) {                              StdErrorCallback(a.Data + Environment.NewLine);                          }                          if (onStdErr != null) {                              onStdErr(a.Data + Environment.NewLine);                          }                          if (Settings.DebugEnabled)                              Logging.Emit("stderr {0}"' a.Data);                      }                  };                    p.BeginErrorReadLine();                  p.BeginOutputReadLine();                    p.WaitForExit();                                    rv = p.ExitCode;                  p.Close();                  Logging.Emit("cl exit {0}"' rv);                  if (rv == 0)                  {                      if (IsSupported)                      {                          if (!string.IsNullOrEmpty(ObjectTarget))                          {                              var sw = new Stopwatch();                              sw.Start();                              while (!File.Exists(ObjectTarget) && (sw.ElapsedMilliseconds < WaitForSlowObject))                              {                                                                  System.Threading.Thread.Sleep(500);                              }                              sw.Stop();                                if (!File.Exists(ObjectTarget))                              {                                  retry = true;                                  if (sw.ElapsedMilliseconds > 2000)                                  {                                      Logging.Emit("compiler didn't write expected object! {0} after {1}ms"' ObjectTarget' (int)sw.Elapsed.TotalMilliseconds);                                      retry = false;                                  }                                  string logmsg = string.Format("cl exited with zero but failed to create the expected object file! {0}"' ObjectTarget);                                  // let the retry system have a go with this                                    if (retry)                                      Logging.Warning("{0}' re-running!"' logmsg);                              }                              else                              {                                  Logging.Emit("output: {0} seen"' ObjectTarget);                              }                          }                      }                  }                    if (rv != 0)                  {                      Logging.Emit("non-zero exit");                  }              } while (retry);
Magic Number,CClash,DirectCompilerCache,C:\repos\inorton_cclash\CClash\DirectCompilerCache.cs,MakeTrackerFolderName,The following statement contains a magic number: return String.Format("cclash-track-{0}"' Guid.NewGuid().ToString().Substring(0' 8));
Magic Number,CClash,DirectCompilerCacheServer,C:\repos\inorton_cclash\CClash\DirectCompilerCacheServer.cs,GetHashes,The following statement contains a magic number: if (hashcache.Count > 20000)              {                  lock (hashcache)                  {                      hashcache.Clear();                  }              }
Magic Number,CClash,FileCacheDatabase,C:\repos\inorton_cclash\CClash\FileCacheDatabase.cs,Open,The following statement contains a magic number: while (true)              {                  try                  {                      if (ReadTextMetafile(CacheInfo.F_CacheType) != "sqlite")                      {                          if (Directory.Exists(FolderPath))                              Directory.Delete(FolderPath' true);                      }                      if (ReadTextMetafile(CacheInfo.F_CacheSchema) != DBSchema)                      {                          if (Directory.Exists(FolderPath))                              Directory.Delete(FolderPath' true);                      }                  }                  catch (IOException)                  {                      System.Threading.Thread.Sleep(100);                  }                  break;              }
Magic Number,CClash,FileCacheDatabase,C:\repos\inorton_cclash\CClash\FileCacheDatabase.cs,OpenConnection,The following statement contains a magic number: cs.BusyTimeout = 1000;
Magic Number,CClash,FileCacheDatabase,C:\repos\inorton_cclash\CClash\FileCacheDatabase.cs,OpenConnection,The following statement contains a magic number: cs.Version = 3;
Magic Number,CClash,FileCacheStore,C:\repos\inorton_cclash\CClash\FileCacheStore.cs,MakePath,The following statement contains a magic number: var tlf = key.Substring(0' 2);
Magic Number,CClash,FileCacheStore,C:\repos\inorton_cclash\CClash\FileCacheStore.cs,MakePath,The following statement contains a magic number: var tlf = key.Substring(0' 2);
Magic Number,CClash,FileCacheStore,C:\repos\inorton_cclash\CClash\FileCacheStore.cs,EnsureKey,The following statement contains a magic number: if (!Directory.Exists(kp.Substring(0'2)))               {                  Directory.CreateDirectory(kp.Substring(0'2));              }
Magic Number,CClash,FileCacheStore,C:\repos\inorton_cclash\CClash\FileCacheStore.cs,EnsureKey,The following statement contains a magic number: if (!Directory.Exists(kp.Substring(0'2)))               {                  Directory.CreateDirectory(kp.Substring(0'2));              }
Magic Number,CClash,FileCacheStore,C:\repos\inorton_cclash\CClash\FileCacheStore.cs,AddFile,The following statement contains a magic number: if (Added != null)              {                  Added(this' new FileCacheStoreAddedEventArgs() { SizeKB = (int)(new FileInfo(filePath).Length / 1024) });              }
Magic Number,CClash,FileCacheStore,C:\repos\inorton_cclash\CClash\FileCacheStore.cs,Remove,The following statement contains a magic number: if (Directory.Exists(p))              {                  int sz = 0;                  var di = new DirectoryInfo(p);                  foreach (var f in di.GetFiles())                  {                      sz += (int)(f.Length / 1024);                  }                  Directory.Delete(MakePath(key)' true);                  if (Removed != null)                  {                      Removed(this' new FileCacheStoreRemovedEventArgs() { SizeKB = sz });                  }              }
Magic Number,CClash,FileUtils,C:\repos\inorton_cclash\CClash\FileUtils.cs,ToLongPathName,The following statement contains a magic number: if ( !string.IsNullOrWhiteSpace(path) && Path.IsPathRooted(path) && path.Contains("~"))              {                  var sb = new StringBuilder(512);                  GetLongPathName(path' sb' sb.Capacity);                  return sb.ToString();              }
Magic Number,CClash,FileUtils,C:\repos\inorton_cclash\CClash\FileUtils.cs,FileMissing,The following statement contains a magic number: if (recent_missing.TryGetValue(path' out mt))              {                  if (now.Subtract(mt).TotalMilliseconds < 200) return true;              }
Magic Number,CClash,FileUtils,C:\repos\inorton_cclash\CClash\FileUtils.cs,FileMissing,The following statement contains a magic number: if (missing)              {                  lock (recent_missing)                  {                      if (recent_missing.Count > 5000) recent_missing.Clear();                      recent_missing[path] = DateTime.Now;                  }              }
Magic Number,CClash,FileUtils,C:\repos\inorton_cclash\CClash\FileUtils.cs,CopyUnlocked,The following statement contains a magic number: do              {                  try                  {                      using (var ifs = new FileStream(from' FileMode.Open' FileAccess.Read' FileShare.Read' 4096' FileOptions.SequentialScan))                      {                          using (var ofs = new FileStream(to' FileMode.Create' FileAccess.Write' FileShare.Write' 4096))                          {                              ifs.CopyTo(ofs);                              return;                          }                      }                  }                  catch (IOException)                  {                      attempts--;                      if (attempts == 0) throw;                      System.Threading.Thread.Sleep(FileIORetrySleep);                  }              } while (true);
Magic Number,CClash,FileUtils,C:\repos\inorton_cclash\CClash\FileUtils.cs,CopyUnlocked,The following statement contains a magic number: do              {                  try                  {                      using (var ifs = new FileStream(from' FileMode.Open' FileAccess.Read' FileShare.Read' 4096' FileOptions.SequentialScan))                      {                          using (var ofs = new FileStream(to' FileMode.Create' FileAccess.Write' FileShare.Write' 4096))                          {                              ifs.CopyTo(ofs);                              return;                          }                      }                  }                  catch (IOException)                  {                      attempts--;                      if (attempts == 0) throw;                      System.Threading.Thread.Sleep(FileIORetrySleep);                  }              } while (true);
Magic Number,CClash,FileUtils,C:\repos\inorton_cclash\CClash\FileUtils.cs,GetShortPath,The following statement contains a magic number: var sb = new StringBuilder(255);
Magic Number,CClash,FileUtils,C:\repos\inorton_cclash\CClash\FileUtils.cs,GetShortPath,The following statement contains a magic number: GetShortPathName(path' sb' 255);
Magic Number,CClash,HashUtil,C:\repos\inorton_cclash\CClash\HashUtil.cs,ThreadyDigestFiles,The following statement contains a magic number: lock (includeCache)              {                  var fcount = files.Count();                  var rv = new Dictionary<string' DataHash>();                  var threadcount = HashingThreadCount;                  if ((threadcount < 2) || (fcount < threadcount))                  {                      Logging.Emit("st hash {0} files"' fcount);                      foreach (var f in files)                      {                          var d = DigestSourceFile(f);                          rv[f.ToLower()] = d;                          if (d.Result != DataHashResult.Ok) break;                      }                  }                  else                  {                      Logging.Emit("mt hash {0} files on {1} threads"' fcount' threadcount);                      var fa = files.ToArray();                      var tl = new List<Thread>();                      var taken = 0;                      var chunk = (1 + fcount / (threadcount));                      if (chunk < 1) chunk = 1;                        var inputs = new List<ThreadyDigestInput>();                        do                      {                          var input = new ThreadyDigestInput()                          {                              files = fa'                              results = new List<DataHash>()'                              provider = new MD5CryptoServiceProvider()'                              begin = taken'                              chunksize = chunk'                              stopOnCachable = stopOnUnCachable'                          };                            var t = new Thread(ThreadyDigestWorker);                          taken += chunk;                          t.Start(input);                          inputs.Add(input);                          tl.Add(t);                      } while (taken < fcount);                        for (var i = 0; i < tl.Count; i++)                      {                          var t = tl[i];                          t.Join(); // thread finished' store it's results                          foreach (var h in inputs[i].results)                          {                              rv[h.InputName.ToLower()] = h;                          }                      }                  }                    return rv;              }
Magic Number,CClash,HashUtil,C:\repos\inorton_cclash\CClash\HashUtil.cs,DigestFile,The following statement contains a magic number: var fs = new FileStream(filepath' FileMode.Open' FileAccess.Read' FileShare.Read' 2048' FileOptions.SequentialScan);
Magic Number,CClash,Logging,C:\repos\inorton_cclash\CClash\Logging.cs,Emit,The following statement contains a magic number: if (Settings.DebugEnabled)              {                  for (int i = 0; i < 4; i++)                  {                      try                      {                          if (Settings.DebugFile == "Console") {                              Console.Error.WriteLine("p{0} t{1}:{2}"' pid'                                   Thread.CurrentThread.ManagedThreadId'                                   string.Format(fmt' args));                          } else {                              File.AppendAllLines(Settings.DebugFile' new string[] { pid + ":" + string.Format(fmt' args) });                          }                          return;                      }                      catch {}                  }              }
Magic Number,CClash,Program,C:\repos\inorton_cclash\CClash\Program.cs,Main,The following statement contains a magic number: if (args.Contains("--cclash"))              {                  Logging.Emit("maint mode");                  Console.Error.WriteLine("cclash {0} (c) Ian Norton' April 2016"'                      typeof(Program).Assembly.GetName().Version.ToString());                    var compiler = Compiler.Find();                  if (Settings.ServiceMode)                  {                      for (int i = 0; i < 3; i++)                      {                          try                          {                              var cc = new CClashServerClient(Settings.CacheDirectory);                              if (args.Contains("--stop"))                              {                                  Console.Error.WriteLine("stopping server..");                                  cc.Transact(new CClashRequest() { cmd = Command.Quit });                              }                              else {                                  #region server commands                                  if (args.Contains("--clear")) {                                      cc.Transact(new CClashRequest() { cmd = Command.ClearCache });                                  } else if ( args.Contains("--disable") ){                                      cc.Transact(new CClashRequest() { cmd = Command.DisableCache });                                  } else if (args.Contains("--enable") ){                                      cc.Transact(new CClashRequest() { cmd = Command.EnableCache });                                  } else if (args.Contains("--start")) {                                      Console.Out.WriteLine("starting server");                                      CClashServerClient.StartBackgroundServer();                                  } else {                                      var stats = cc.Transact(new CClashRequest() { cmd = Command.GetStats });                                      Console.Out.WriteLine(stats.stdout);                                  }                                  return 0;                                    #endregion                              }                            }                          catch (CClashErrorException ex)                          {                              Logging.Error(ex.Message);                              return -1;                          }                          catch (CClashWarningException)                          {                              System.Threading.Thread.Sleep(2000);                          }                          catch (CClashServerNotReadyException)                          {                              Logging.Emit("server not ready' try again");                              return -1;                          }                          catch (IOException ex)                          {                              Logging.Error(ex.ToString());                              return -1;                          }                      }                  }                  else                  {                      ICompiler comp;                      using (ICompilerCache cc =                          CompilerCacheFactory.Get(Settings.DirectMode' Settings.CacheDirectory' compiler' Environment.CurrentDirectory' Compiler.GetEnvironmentDictionary()' out comp))                      {                          Console.Out.WriteLine(StatOutputs.GetStatsString(compiler' cc));                      }                  }                  return 0;              }
Magic Number,CClash,Program,C:\repos\inorton_cclash\CClash\Program.cs,Main,The following statement contains a magic number: if (args.Contains("--cclash"))              {                  Logging.Emit("maint mode");                  Console.Error.WriteLine("cclash {0} (c) Ian Norton' April 2016"'                      typeof(Program).Assembly.GetName().Version.ToString());                    var compiler = Compiler.Find();                  if (Settings.ServiceMode)                  {                      for (int i = 0; i < 3; i++)                      {                          try                          {                              var cc = new CClashServerClient(Settings.CacheDirectory);                              if (args.Contains("--stop"))                              {                                  Console.Error.WriteLine("stopping server..");                                  cc.Transact(new CClashRequest() { cmd = Command.Quit });                              }                              else {                                  #region server commands                                  if (args.Contains("--clear")) {                                      cc.Transact(new CClashRequest() { cmd = Command.ClearCache });                                  } else if ( args.Contains("--disable") ){                                      cc.Transact(new CClashRequest() { cmd = Command.DisableCache });                                  } else if (args.Contains("--enable") ){                                      cc.Transact(new CClashRequest() { cmd = Command.EnableCache });                                  } else if (args.Contains("--start")) {                                      Console.Out.WriteLine("starting server");                                      CClashServerClient.StartBackgroundServer();                                  } else {                                      var stats = cc.Transact(new CClashRequest() { cmd = Command.GetStats });                                      Console.Out.WriteLine(stats.stdout);                                  }                                  return 0;                                    #endregion                              }                            }                          catch (CClashErrorException ex)                          {                              Logging.Error(ex.Message);                              return -1;                          }                          catch (CClashWarningException)                          {                              System.Threading.Thread.Sleep(2000);                          }                          catch (CClashServerNotReadyException)                          {                              Logging.Emit("server not ready' try again");                              return -1;                          }                          catch (IOException ex)                          {                              Logging.Error(ex.ToString());                              return -1;                          }                      }                  }                  else                  {                      ICompiler comp;                      using (ICompilerCache cc =                          CompilerCacheFactory.Get(Settings.DirectMode' Settings.CacheDirectory' compiler' Environment.CurrentDirectory' Compiler.GetEnvironmentDictionary()' out comp))                      {                          Console.Out.WriteLine(StatOutputs.GetStatsString(compiler' cc));                      }                  }                  return 0;              }
Magic Number,CClash,Program,C:\repos\inorton_cclash\CClash\Program.cs,Main,The following statement contains a magic number: if (rv != 0)              {                  if (!Settings.NoAutoRebuild)                  {                      for (int i = 1; i < 4; i++)                      {                          MainStdErr.Clear();                          MainStdOut.Clear();                          rv = RunBuild(args' start' AppendStdout' AppendStderr);                          if (rv == 0) break;                          System.Threading.Thread.Sleep(100);                      }                  }              }
Magic Number,CClash,Program,C:\repos\inorton_cclash\CClash\Program.cs,Main,The following statement contains a magic number: if (rv != 0)              {                  if (!Settings.NoAutoRebuild)                  {                      for (int i = 1; i < 4; i++)                      {                          MainStdErr.Clear();                          MainStdOut.Clear();                          rv = RunBuild(args' start' AppendStdout' AppendStderr);                          if (rv == 0) break;                          System.Threading.Thread.Sleep(100);                      }                  }              }
Magic Number,CClash,StatOutputs,C:\repos\inorton_cclash\CClash\StatOutputs.cs,GetStatsString,The following statement contains a magic number: if (cache != null)              {                  using (var stats = new CacheInfo(cache.OutputCache))                  {                      sb.WriteLine("outputCache usage: {0} kb"' (int)(stats.CacheSize / 1024));                      sb.WriteLine("cached files: {0}"' stats.CacheObjects);                      sb.WriteLine("hits: {0}"' stats.CacheHits);                      sb.WriteLine("misses: {0}"' stats.CacheMisses);                      sb.WriteLine("unsupported: {0}"' stats.CacheUnsupported);                      sb.WriteLine("slow hits: {0}"' stats.SlowHitCount);                  }              }
Missing Default,CClash,CClashServer,C:\repos\inorton_cclash\CClash\CClashServer.cs,ProcessRequest,The following switch statement is missing a default case: switch (req.cmd)              {                    case Command.GetStats:                      rv.exitcode = 0;                      cache.SetupStats(); // commits stats to disk                      rv.stdout = StatOutputs.GetStatsString(req.compiler' cache);                      break;                    case Command.DisableCache:                      DisableCaching = true;                      rv.supported = true;                      break;                    case Command.ClearCache:                      DisableCaching = true;                      cache.SetupStats();                      cache.Lock(CacheLockType.ReadWrite);                      cache.OutputCache.ClearLocked();                      cache.IncludeCache.ClearLocked();                      cache.Unlock(CacheLockType.ReadWrite);                      rv.supported = true;                      break;                    case Command.EnableCache:                      DisableCaching = false;                      rv.supported = true;                      break;                    case Command.Run:                      var stdout = new StringBuilder();                      var stderr = new StringBuilder();                      var comp = cache.SetCompilerEx(req.pid' req.compiler' req.workdir' new Dictionary<string'string>( req.envs ));                      cache.SetCaptureCallback(comp' (so) => { stdout.Append(so); }' (se) => { stderr.Append(se); });                      if (DisableCaching) {                          rv.exitcode = comp.InvokeCompiler(req.argv' null' null' false' new List<string>());                      } else {                          rv.exitcode = cache.CompileOrCache(comp' req.argv' req);                      }                      rv.supported = true;                      rv.stderr = stderr.ToString();                      rv.stdout = stdout.ToString();                        break;                    case Command.Quit:                      cache.SetupStats();                      Stop();                      break;              }
Missing Default,CClash,FileCacheStore,C:\repos\inorton_cclash\CClash\FileCacheStore.cs,OpenFileStream,The following switch statement is missing a default case: switch(mode) {                  case FileMode.Create:                  case FileMode.CreateNew:                      var fdir = Path.GetDirectoryName(fpath);                      if (!Directory.Exists(fdir))                          Directory.CreateDirectory(fdir);                  break;              }
