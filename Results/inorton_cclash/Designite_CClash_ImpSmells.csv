Implementation smell,Namespace,Class,File,Method,Description
Long Method,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The method has 242 lines of code.
Long Method,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The method has 136 lines of code.
Long Method,CClash,Program,D:\research\architectureSmells\repos\inorton_cclash\CClash\Program.cs,Main,The method has 171 lines of code.
Complex Method,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,Listen,Cyclomatic complexity of the method is 10
Complex Method,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,Cyclomatic complexity of the method is 48
Complex Method,CClash,DirectCompilerCache,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCache.cs,CheckCache,Cyclomatic complexity of the method is 15
Complex Method,CClash,FileCacheDatabase,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheDatabase.cs,Open,Cyclomatic complexity of the method is 8
Complex Method,CClash,Program,D:\research\architectureSmells\repos\inorton_cclash\CClash\Program.cs,Main,Cyclomatic complexity of the method is 29
Long Parameter List,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,InvokeCompiler,The method has 5 parameters. Parameters: args' onStdErr' onStdOut' showIncludes' foundIncludes
Long Parameter List,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The method has 5 parameters. Parameters: args' onStdErr' onStdOut' showIncludes' foundIncludes
Long Parameter List,CClash,DirectCompilerCache,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCache.cs,Compile,The method has 5 parameters. Parameters: comp' args' stderr' stdout' includes
Long Parameter List,CClash,DirectCompilerCache,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCache.cs,DoCacheMiss,The method has 5 parameters. Parameters: c' hc' args' req' ifiles
Long Parameter List,CClash,CompilerCacheFactory,D:\research\architectureSmells\repos\inorton_cclash\CClash\CompilerCacheBase.cs,Get,The method has 6 parameters. Parameters: direct' cachedir' compiler' workdir' envs' comp
Long Parameter List,CClash,CompilerCacheBase,D:\research\architectureSmells\repos\inorton_cclash\CClash\CompilerCacheBase.cs,CompileWithStreams,The method has 5 parameters. Parameters: comp' args' stderr' stdout' includes
Long Parameter List,CClash,ICompiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\ICompiler.cs,InvokeCompiler,The method has 5 parameters. Parameters: args' onStdErr' onStdOut' showIncludes' foundIncludes
Long Parameter List,CClash,Logging,D:\research\architectureSmells\repos\inorton_cclash\CClash\Logging.cs,Miss,The method has 5 parameters. Parameters: hc' reason' dir' srcfile' headerfile
Long Statement,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,NewServerThread,The length of the statement  "            var nss = new NamedPipeServerStream(MakePipeName(cachedir)' PipeDirection.InOut' MaxServerThreads' PipeTransmissionMode.Message' PipeOptions.WriteThrough | PipeOptions.Asynchronous); " is 182.
Long Statement,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,NewServerThread,The length of the statement  "                var npa = new PipeAccessRule("Everyone"' PipeAccessRights.ReadWrite' System.Security.AccessControl.AccessControlType.Allow); " is 124.
Long Statement,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The length of the statement  "                                    Logging.Emit("compiler didn't write expected object! {0} after {1}ms"' ObjectTarget' (int)sw.Elapsed.TotalMilliseconds); " is 120.
Long Statement,CClash,DirectCompilerCache,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCache.cs,CheckCache,The length of the statement  "                        Logging.Miss(commonkey.SessionHash' DataHashResult.FileAdded' Directory.GetCurrentDirectory()' comp.SingleSourceFile' f); " is 121.
Long Statement,CClash,DirectCompilerCache,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCache.cs,CheckCache,The length of the statement  "                                Logging.Miss(commonkey.SessionHash' DataHashResult.FileChanged' Directory.GetCurrentDirectory()' comp.SingleSourceFile' h.Key); " is 127.
Long Statement,CClash,DirectCompilerCache,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCache.cs,CheckCache,The length of the statement  "                            Logging.Miss(commonkey.SessionHash' DataHashResult.FileAdded' Directory.GetCurrentDirectory()' comp.SingleSourceFile' h.Key); " is 125.
Long Statement,CClash,FileUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileUtils.cs,CopyUnlocked,The length of the statement  "                    using (var ifs = new FileStream(from' FileMode.Open' FileAccess.Read' FileShare.Read' 4096' FileOptions.SequentialScan)) " is 120.
Long Statement,CClash,Program,D:\research\architectureSmells\repos\inorton_cclash\CClash\Program.cs,Main,The length of the statement  "                        CompilerCacheFactory.Get(Settings.DirectMode' Settings.CacheDirectory' compiler' Environment.CurrentDirectory' Compiler.GetEnvironmentDictionary()' out comp)) " is 158.
Long Statement,CClash,Program,D:\research\architectureSmells\repos\inorton_cclash\CClash\Program.cs,RunBuild,The length of the statement  "                        CompilerCacheFactory.Get(Settings.DirectMode' cachedir' compiler' Environment.CurrentDirectory' Compiler.GetEnvironmentDictionary()' out comp)) " is 143.
Virtual Method Call from Constructor,CClash,DirectCompilerCacheServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCacheServer.cs,DirectCompilerCacheServer,The constructor "DirectCompilerCacheServer" calls a virtual method "Lock".
Empty Catch Block,CClash,CClashServerClient,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServerClient.cs,Connect,The method has an empty catch block.
Empty Catch Block,CClash,Logging,D:\research\architectureSmells\repos\inorton_cclash\CClash\Logging.cs,Emit,The method has an empty catch block.
Empty Catch Block,CClash,ProcessUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\ProcessUtils.cs,GetParentProcessName,The method has an empty catch block.
Magic Number,CClash,ArgumentUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\ArgumentUtils.cs,JoinAguments,The following statement contains a magic number: var sb = new System.Text.StringBuilder(512);
Magic Number,CClash,ArgumentUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\ArgumentUtils.cs,FixupArgs,The following statement contains a magic number: a.Length == 2 && (i + 1 < aa.Length)
Magic Number,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,Preflight,The following statement contains a magic number: !mtx.WaitOne(1000)
Magic Number,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,ThreadBeforeProcessRequest,The following statement contains a magic number: System.Threading.Thread.Sleep(60/Environment.ProcessorCount);
Magic Number,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,ConnectionThreadFn,The following statement contains a magic number: !w.AsyncWaitHandle.WaitOne(1000)
Magic Number,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,ServiceRequest,The following statement contains a magic number: var msgbuf = new List<byte>(8192);
Magic Number,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,ServiceRequest,The following statement contains a magic number: var rxbuf = new byte[256 * 1024];
Magic Number,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,ServiceRequest,The following statement contains a magic number: var rxbuf = new byte[256 * 1024];
Magic Number,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,Listen,The following statement contains a magic number: t.Join(1000)
Magic Number,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,Listen,The following statement contains a magic number: !t.Join(2000)
Magic Number,CClash,CClashServerClient,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServerClient.cs,StartBackgroundServer,The following statement contains a magic number: var can_start_server = ssm.WaitOne(500);
Magic Number,CClash,CClashServerClient,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServerClient.cs,StartBackgroundServer,The following statement contains a magic number: System.Threading.Thread.Sleep(1000);
Magic Number,CClash,CClashServerClient,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServerClient.cs,ConnectClient,The following statement contains a magic number: ncs.Connect(500);
Magic Number,CClash,CClashServerClient,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServerClient.cs,Transact,The following statement contains a magic number: var rxbuf = new byte[8192];
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,cygwinEnvFixup,The following statement contains a magic number: var pair = e.Split(new char[] { '=' }' 2);
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,getOption,The following statement contains a magic number: canon = canon.Substring(0' 3);
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,getOption,The following statement contains a magic number: canon.Length > 2
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ProcessArguments,The following statement contains a magic number: switch (opt)                      {                          case "/c":                              HasDashC = true;                              break;                          case "/o":                              return NotSupported("/o");                          case "/D":                              if (opt == full)                              {                                  // define value is next argument...                                  i++;                                  onlyOptions.Add(args[i]);                              }                              break;                          case "/I":                              if (opt == full)                              {                                  // include path is next argument..                                  // microsoft really dont know how to do command line!                                  i++;                                  if (i > args.Length)                                  {                                      return NotSupported("-I has no path!");                                  }                                  full = "/I" + args[i];                                    onlyOptions.Add(args[i]);                                    goto default;                              }                              break;                            case "/Z7":                              GeneratePdb = false;                              PdbFile = null;                              break;                            case "/Yu":                              PrecompiledHeaders = true;                              return NotSupported("pre-compiler headers {0}"' opt);                            case "/FI":                              return NotSupported(opt);                            case "/Zi":                              GeneratePdb = true;                              break;                            case "/Fd":                              PdbFile = Path.Combine(WorkingDirectory' full.Substring(3));                              // openssl gives us a posix path here..                              PdbFile = PdbFile.Replace('/'' '\\');                              if (!PdbFile.ToLower().EndsWith(".pdb") && !PdbFile.EndsWith("\\"))                              {                                  PdbFile = PdbFile + ".pdb";                              }                              break;                            case "/Fo":                              ObjectTarget = Path.Combine(WorkingDirectory' full.Substring(3));                              if (ArgumentUtils.TargetIsFolder(ObjectTarget))                              {                                  ObjectTargetIsFolder = true;                              }                              else                              {                                  ObjectTarget = ArgumentUtils.TargetObject(ObjectTarget);                              }                              break;                            case "/Tp":                          case "/Tc":                              var srcfile = ArgumentUtils.MakeWindowsPath(full.Substring(3));                              if (!Path.IsPathRooted(srcfile))                                  srcfile = Path.Combine(WorkingDirectory' srcfile);                                if (FileUtils.Exists(srcfile))                              {                                  srcs.Add(srcfile);                                    // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                  srcsOptions.Add(full);                              }                              else                              {                                  return NotSupported("cant find file for {0}"' full);                              }                              break;                            case "/E":                              return NotSupported(opt);                            case "/EP":                              return NotSupported(opt);                            case "/MP":                              var numOfCompilersStr = full.Substring(3);                              if (string.IsNullOrEmpty(numOfCompilersStr))                              {                                  ParallelCompilers = Environment.ProcessorCount;                              }                              else                              {                                  int parallel;                                  if (int.TryParse(numOfCompilersStr' out parallel))                                      ParallelCompilers = parallel;                                  else                                      ParallelCompilers = Environment.ProcessorCount;                              }                              break;                            default:                              #region positional or other flag options                                if (full == "/link")                              {                                  Linking = true;                                  return NotSupported("/link");                              }                                if (opt.StartsWith("@"))                              {                                  // remove last added option                                  onlyOptions.RemoveAt(onlyOptions.Count - 1);                                    #region response file                                  ResponseFile = ArgumentUtils.MakeWindowsPath(full.Substring(1));                                    if (ResponseFile.EndsWith(InternalResponseFileSuffix))                                  {                                      Logging.Emit("cclash misshelper internal response file");                                      return false;                                  }                                    if (!Path.IsPathRooted(ResponseFile))                                      ResponseFile = Path.Combine(WorkingDirectory' ResponseFile);                                  string rsptxt = File.ReadAllText(ResponseFile);                                  if (rsptxt.Length < 2047)                                  // windows max command line' this is why they invented response files                                  {                                      Logging.Emit("response data [{0}]"' rsptxt);                                      if (args.Length == 1)                                      {                                          // this only works if it is the one and only arg!                                          args = ArgumentUtils.FixupArgs(CommandLineToArgs(rsptxt).Skip(1)).ToArray();                                          i = -1;                                          // replace the command line with the response file content                                           // and restart parsing. This does go wrong if the response text is huge                                          continue;                                      }                                  }                                  else                                  {                                      Logging.Emit("response file too large");                                  }                                    return NotSupported("response file error");                                  #endregion                              }                                if (!full.StartsWith("/"))                              {                                  // NOTE' if we ever cache -link calls this will also match input objects and libs                                  var file = ArgumentUtils.MakeWindowsPath(full);                                  if (!Path.IsPathRooted(file))                                      file = Path.Combine(WorkingDirectory' file);                                    if (FileUtils.Exists(file))                                  {                                      srcs.Add(file);                                        // remove last added option                                      onlyOptions.RemoveAt(onlyOptions.Count - 1);                                      srcsOptions.Add(full);                                      continue;                                  }                              }                              if (full.StartsWith("/I"))                              {                                  var d = ArgumentUtils.MakeWindowsPath(full.Substring(2));                                  if (d == ".")                                      d = WorkingDirectory;                                  if (d == "..")                                      d = Path.GetDirectoryName(WorkingDirectory);                                    if (!Path.IsPathRooted(d))                                  {                                      d = Path.Combine(WorkingDirectory' d);                                  }                                    if (Directory.Exists(d))                                  {                                      cliincs.Add(d);                                      continue;                                  }                              }  #endregion                                break;                      }
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,GetUsedIncludeDirs,The following statement contains a magic number: var tmplist = new List<string>(1000);
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ScheduleLaterDelete,The following statement contains a magic number: System.Threading.ThreadPool.QueueUserWorkItem((x) =>              {                  for (int i = 0; i < 5; i++)                  {                      try                      {                          Directory.Delete(folder' true);                          return;                      }                      catch (System.IO.IOException)                      {                          System.Threading.Thread.Sleep(2000);                      }                  }              });
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,ScheduleLaterDelete,The following statement contains a magic number: System.Threading.ThreadPool.QueueUserWorkItem((x) =>              {                  for (int i = 0; i < 5; i++)                  {                      try                      {                          Directory.Delete(folder' true);                          return;                      }                      catch (System.IO.IOException)                      {                          System.Threading.Thread.Sleep(2000);                      }                  }              });
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The following statement contains a magic number: System.Threading.Thread.Sleep(500);
Magic Number,CClash,Compiler,D:\research\architectureSmells\repos\inorton_cclash\CClash\Compiler.cs,RealInvokeCompiler,The following statement contains a magic number: sw.ElapsedMilliseconds > 2000
Magic Number,CClash,DirectCompilerCache,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCache.cs,MakeTrackerFolderName,The following statement contains a magic number: return String.Format("cclash-track-{0}"' Guid.NewGuid().ToString().Substring(0' 8));
Magic Number,CClash,DirectCompilerCacheServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\DirectCompilerCacheServer.cs,GetHashes,The following statement contains a magic number: hashcache.Count > 20000
Magic Number,CClash,FileCacheDatabase,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheDatabase.cs,OpenConnection,The following statement contains a magic number: cs.BusyTimeout = 1000;
Magic Number,CClash,FileCacheDatabase,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheDatabase.cs,OpenConnection,The following statement contains a magic number: cs.Version = 3;
Magic Number,CClash,FileCacheStore,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheStore.cs,MakePath,The following statement contains a magic number: var tlf = key.Substring(0' 2);
Magic Number,CClash,FileCacheStore,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheStore.cs,MakePath,The following statement contains a magic number: var tlf = key.Substring(0' 2);
Magic Number,CClash,FileCacheStore,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheStore.cs,EnsureKey,The following statement contains a magic number: Directory.CreateDirectory(kp.Substring(0'2));
Magic Number,CClash,FileCacheStore,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheStore.cs,EnsureKey,The following statement contains a magic number: !Directory.Exists(kp.Substring(0'2))
Magic Number,CClash,FileCacheStore,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheStore.cs,AddFile,The following statement contains a magic number: Added(this' new FileCacheStoreAddedEventArgs() { SizeKB = (int)(new FileInfo(filePath).Length / 1024) });
Magic Number,CClash,FileCacheStore,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheStore.cs,Remove,The following statement contains a magic number: sz += (int)(f.Length / 1024);
Magic Number,CClash,FileUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileUtils.cs,ToLongPathName,The following statement contains a magic number: var sb = new StringBuilder(512);
Magic Number,CClash,FileUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileUtils.cs,FileMissing,The following statement contains a magic number: now.Subtract(mt).TotalMilliseconds < 200
Magic Number,CClash,FileUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileUtils.cs,FileMissing,The following statement contains a magic number: recent_missing.Count > 5000
Magic Number,CClash,FileUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileUtils.cs,GetShortPath,The following statement contains a magic number: var sb = new StringBuilder(255);
Magic Number,CClash,FileUtils,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileUtils.cs,GetShortPath,The following statement contains a magic number: GetShortPathName(path' sb' 255);
Magic Number,CClash,HashUtil,D:\research\architectureSmells\repos\inorton_cclash\CClash\HashUtil.cs,ThreadyDigestFiles,The following statement contains a magic number: (threadcount < 2) || (fcount < threadcount)
Magic Number,CClash,HashUtil,D:\research\architectureSmells\repos\inorton_cclash\CClash\HashUtil.cs,DigestFile,The following statement contains a magic number: var fs = new FileStream(filepath' FileMode.Open' FileAccess.Read' FileShare.Read' 2048' FileOptions.SequentialScan);
Magic Number,CClash,Logging,D:\research\architectureSmells\repos\inorton_cclash\CClash\Logging.cs,Emit,The following statement contains a magic number: i < 4
Magic Number,CClash,Program,D:\research\architectureSmells\repos\inorton_cclash\CClash\Program.cs,Main,The following statement contains a magic number: i < 3
Magic Number,CClash,Program,D:\research\architectureSmells\repos\inorton_cclash\CClash\Program.cs,Main,The following statement contains a magic number: System.Threading.Thread.Sleep(100);
Magic Number,CClash,Program,D:\research\architectureSmells\repos\inorton_cclash\CClash\Program.cs,Main,The following statement contains a magic number: i < 4
Magic Number,CClash,StatOutputs,D:\research\architectureSmells\repos\inorton_cclash\CClash\StatOutputs.cs,GetStatsString,The following statement contains a magic number: sb.WriteLine("outputCache usage: {0} kb"' (int)(stats.CacheSize / 1024));
Missing Default,CClash,CClashServer,D:\research\architectureSmells\repos\inorton_cclash\CClash\CClashServer.cs,ProcessRequest,The following switch statement is missing a default case: switch (req.cmd)              {                    case Command.GetStats:                      rv.exitcode = 0;                      cache.SetupStats(); // commits stats to disk                      rv.stdout = StatOutputs.GetStatsString(req.compiler' cache);                      break;                    case Command.DisableCache:                      DisableCaching = true;                      rv.supported = true;                      break;                    case Command.ClearCache:                      DisableCaching = true;                      cache.SetupStats();                      cache.Lock(CacheLockType.ReadWrite);                      cache.OutputCache.ClearLocked();                      cache.IncludeCache.ClearLocked();                      cache.Unlock(CacheLockType.ReadWrite);                      rv.supported = true;                      break;                    case Command.EnableCache:                      DisableCaching = false;                      rv.supported = true;                      break;                    case Command.Run:                      var stdout = new StringBuilder();                      var stderr = new StringBuilder();                      var comp = cache.SetCompilerEx(req.pid' req.compiler' req.workdir' new Dictionary<string'string>( req.envs ));                      cache.SetCaptureCallback(comp' (so) => { stdout.Append(so); }' (se) => { stderr.Append(se); });                      if (DisableCaching) {                          rv.exitcode = comp.InvokeCompiler(req.argv' null' null' false' new List<string>());                      } else {                          rv.exitcode = cache.CompileOrCache(comp' req.argv' req);                      }                      rv.supported = true;                      rv.stderr = stderr.ToString();                      rv.stdout = stdout.ToString();                        break;                    case Command.Quit:                      cache.SetupStats();                      Stop();                      break;              }
Missing Default,CClash,FileCacheStore,D:\research\architectureSmells\repos\inorton_cclash\CClash\FileCacheStore.cs,OpenFileStream,The following switch statement is missing a default case: switch(mode) {                  case FileMode.Create:                  case FileMode.CreateNew:                      var fdir = Path.GetDirectoryName(fpath);                      if (!Directory.Exists(fdir))                          Directory.CreateDirectory(fdir);                  break;              }
