Implementation smell,Namespace,Class,File,Method,Description
Complex Method,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,Cyclomatic complexity of the method is 8
Complex Method,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,PersistObject,Cyclomatic complexity of the method is 10
Complex Method,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,ProcessAttribute,Cyclomatic complexity of the method is 10
Complex Method,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,PersistInnerProperties,Cyclomatic complexity of the method is 20
Complex Method,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,PersistInnerProperty,Cyclomatic complexity of the method is 13
Complex Method,AspNetEdit.Editor.Persistence,DesignTimeParser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\DesignTimeParser.cs,TagParsed,Cyclomatic complexity of the method is 33
Complex Method,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,ServerObjectParsingObject,Cyclomatic complexity of the method is 31
Complex Method,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,AddText,Cyclomatic complexity of the method is 9
Complex Method,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,CreateChildParsingObject,Cyclomatic complexity of the method is 18
Complex Method,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,AddControl,Cyclomatic complexity of the method is 8
Complex Method,AspNetEdit.Editor.ComponentModel,DesignContainer,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\DesignContainer.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,AspNetEdit.Editor.ComponentModel,DesignContainer,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\DesignContainer.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,AspNetEdit.Editor.ComponentModel,DesignContainer,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\DesignContainer.cs,OnComponentChanged,Cyclomatic complexity of the method is 8
Complex Method,AspNetEdit.Editor.ComponentModel,DesignerHost,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\DesignerHost.cs,DestroyComponent,Cyclomatic complexity of the method is 8
Complex Method,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,Cyclomatic complexity of the method is 28
Complex Method,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,RemoveDirective,Cyclomatic complexity of the method is 8
Complex Method,AspNetEdit.Editor.ComponentModel,SelectionService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\SelectionService.cs,SetSelectedComponents,Cyclomatic complexity of the method is 10
Complex Method,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,PopulateFromAssembly,Cyclomatic complexity of the method is 13
Complex Method,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,Cyclomatic complexity of the method is 8
Complex Method,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,JSClick,Cyclomatic complexity of the method is 16
Long Parameter List,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,GeckoWebBrowser,The method has 6 parameters.
Long Parameter List,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,PersistInnerProperty,The method has 5 parameters.
Long Statement,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The length of the statement  "		var cu = MonoDevelop.Projects.Dom.Parser.ProjectDomService.Parse (viewContent.Project' viewContent.ContentName) as MonoDevelop.AspNet.Parser.AspNetParsedDocument; " is 162.
Long Statement,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,saveDocumentToTextView,The length of the statement  "			MonoDevelop.Ide.MessageService.ShowException (e' AddinManager.CurrentLocalizer.GetString ("The document could not be retrieved from the designer")); " is 148.
Long Statement,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,MozillaInstalled,The length of the statement  "		error = AddinManager.CurrentLocalizer.GetString ("MOZILLA_FIVE_HOME does not appear to be pointing to a valid Mozilla runtime: \"{0}\"."' mozPath); " is 147.
Long Statement,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,ExtensionInstalled,The length of the statement  "	error = AddinManager.CurrentLocalizer.GetString ("A Mozilla extension is installed for the ASP.NET designer' \n" + "but it is either incorrectly installed or is not the correct version. \n" + "It is only possible to have one version installed."); " is 246.
Long Statement,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,InstallExtension,The length of the statement  "	if (!MessageService.Confirm (AddinManager.CurrentLocalizer.GetString ("Mozilla extension installation")' extensionStatus + "\n" + AddinManager.CurrentLocalizer.GetString ("Would you like to install it?")' new AlertButton (AddinManager.CurrentLocalizer.GetString ("Install extension")))) " is 286.
Long Statement,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,InstallExtension,The length of the statement  "		string jarfile = Path.Combine (Path.GetDirectoryName (System.Reflection.Assembly.GetExecutingAssembly ().Location)' "aspdesigner.jar"); " is 135.
Long Statement,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,InstallExtension,The length of the statement  "	//string installCommand = String.Format ("\"sh -c \\\"cp '{0}' '{1}'; chmod a+r '{1}'\\\"\""' sourcePath' manifestLocation); " is 124.
Long Statement,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,InstallExtension,The length of the statement  "	MessageService.ShowError (AddinManager.CurrentLocalizer.GetString ("Could not execute command as root. \n" + "Please manually run the command \n{0}\nbefore continuing."' installCommand)); " is 187.
Long Statement,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,LoadHtml,The length of the statement  "		MonoDevelop.Core.LoggingService.LogError ("Could not write temporary HTML file '{0}' for Gecko web control\n{1}"' tempFile' ex.ToString ()); " is 140.
Long Statement,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,ProcessEvent,The length of the statement  "	if (prop.SerializationVisibility != DesignerSerializationVisibility.Visible || value == null || prop.DesignTimeOnly || prop.IsReadOnly || !prop.ShouldSerializeValue (comp)) " is 172.
Long Statement,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,ProcessAttribute,The length of the statement  "	if (prop.SerializationVisibility == DesignerSerializationVisibility.Hidden || prop.DesignTimeOnly || prop.IsReadOnly || !prop.ShouldSerializeValue (o) || prop.Converter == null || !prop.Converter.CanConvertTo (typeof(string))) " is 226.
Long Statement,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,PersistInnerProperties,The length of the statement  "	PersistChildrenAttribute persAtt = TypeDescriptor.GetAttributes (component) [typeof(PersistChildrenAttribute)] as PersistChildrenAttribute; " is 139.
Long Statement,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,PersistInnerProperties,The length of the statement  "			if (prop.SerializationVisibility == DesignerSerializationVisibility.Hidden || prop.DesignTimeOnly //|| !prop.ShouldSerializeValue (component) //confused by collections... " is 170.
Long Statement,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,HasInnerProperties,The length of the statement  "	PersistChildrenAttribute persAtt = TypeDescriptor.GetAttributes (component) [typeof(PersistChildrenAttribute)] as PersistChildrenAttribute; " is 139.
Long Statement,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,HasInnerProperties,The length of the statement  "			if (prop.SerializationVisibility == DesignerSerializationVisibility.Hidden || prop.DesignTimeOnly //|| !prop.ShouldSerializeValue(component) //confused by collections.... " is 170.
Long Statement,AspNetEdit.Editor.ComponentModel,DesignerHost,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\DesignerHost.cs,CreateComponent,The length of the statement  "		throw new ArgumentException ("componentClass must be a subclass of System.Web.UI.Control' but is a " + componentClass.ToString ()' "componentClass"); " is 149.
Long Statement,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,AddDirective,The length of the statement  "	if ((0 == String.Compare (name' "Page"' true' CultureInfo.InvariantCulture) && directives ["Page"] != null) || (0 == String.Compare (name' "Control"' true' CultureInfo.InvariantCulture) && directives ["Control"] != null)) " is 221.
Long Statement,AspNetEdit.Editor.ComponentModel,SelectionService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\SelectionService.cs,SetSelectedComponents,The length of the statement  "		modified = ((mt & Gdk.ModifierType.ShiftMask) == Gdk.ModifierType.ShiftMask) || ((mt & Gdk.ModifierType.ControlMask) == Gdk.ModifierType.ControlMask); " is 150.
Long Statement,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,PopulateFromAssembly,The length of the statement  "		else if (t.Namespace == "System.Web.UI.HtmlControls" && t.IsSubclassOf (typeof(System.Web.UI.HtmlControls.HtmlControl))) " is 120.
Long Statement,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The length of the statement  "		buffer [bufIndex++] = (byte)((chars [charLength - 1] > '9' ? (byte)(chars [charLength - 1] - 'A' + 10) : (byte)(chars [charLength - 1] - '0')) << 4); " is 149.
Long Statement,AspNetEdit.Editor.ComponentModel,WebFormReferenceManager,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\WebFormReferenceManager.cs,GetObjectType,The length of the statement  "		return typeof(System.Web.UI.WebControls.WebControl).Assembly.GetType ("System.Web.UI.WebControls." + typeName' true' true); " is 123.
Long Statement,AspNetEdit.Editor.UI,PropertyGrid,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\PropertyGrid.cs,InitialiseServices,The length of the statement  "	typeDescriptorFilterService = parentServices.GetService (typeof(ITypeDescriptorFilterService)) as ITypeDescriptorFilterService; " is 127.
Long Statement,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,JSActivate,The length of the statement  "		System.Diagnostics.Trace.WriteLine ("HELP! XUL reports having been initialised again! Suppressing' but need to be fixed."); " is 123.
Long Statement,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,JSResize,The length of the statement  "	System.Diagnostics.Trace.WriteLine (String.Format ("Javascript requesting size change to w:{0} h:{1} for control {2}."' args [1]' args [2]' args [0])); " is 151.
Long Statement,AspNetEdit.Editor,EditorHost,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor\EditorHost.cs,handleToolboxNode,The length of the statement  "		//TODO: Fix WebControlToolboxItem and (mono classlib's use of it) so we don't have to mess around with type lookups and attributes here " is 135.
Long Statement,AspNetEdit.Editor,EditorHost,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor\EditorHost.cs,handleToolboxNode,The length of the statement  "			System.Web.UI.ToolboxDataAttribute tda = (System.Web.UI.ToolboxDataAttribute)atts [typeof(System.Web.UI.ToolboxDataAttribute)]; " is 127.
Long Statement,AspNetEdit.Editor,EditorHost,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor\EditorHost.cs,handleToolboxNode,The length of the statement  "				System.Web.UI.Design.IWebFormReferenceManager webRef = host.GetService (typeof(System.Web.UI.Design.IWebFormReferenceManager)) as System.Web.UI.Design.IWebFormReferenceManager; " is 176.
Complex Conditional,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,ProcessEvent,The conditional expression  "prop.SerializationVisibility != DesignerSerializationVisibility.Visible || value == null || prop.DesignTimeOnly || prop.IsReadOnly || !prop.ShouldSerializeValue (comp)"  is complex.
Complex Conditional,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,ProcessAttribute,The conditional expression  "prop.SerializationVisibility == DesignerSerializationVisibility.Hidden || prop.DesignTimeOnly || prop.IsReadOnly || !prop.ShouldSerializeValue (o) || prop.Converter == null || !prop.Converter.CanConvertTo (typeof(string))"  is complex.
Complex Conditional,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,AddDirective,The conditional expression  "(0 == String.Compare (name' "Page"' true' CultureInfo.InvariantCulture) && directives ["Page"] != null) || (0 == String.Compare (name' "Control"' true' CultureInfo.InvariantCulture) && directives ["Control"] != null)"  is complex.
Virtual Method Call from Constructor,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,GeckoWebBrowser,The constructor "GeckoWebBrowser" calls a virtual method "OnLocationChanged".
Virtual Method Call from Constructor,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,GeckoWebBrowser,The constructor "GeckoWebBrowser" calls a virtual method "OnLoadingProgressChanged".
Virtual Method Call from Constructor,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,GeckoWebBrowser,The constructor "GeckoWebBrowser" calls a virtual method "OnJSStatusChanged".
Virtual Method Call from Constructor,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,GeckoWebBrowser,The constructor "GeckoWebBrowser" calls a virtual method "OnLinkStatusChanged".
Virtual Method Call from Constructor,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,GeckoWebBrowser,The constructor "GeckoWebBrowser" calls a virtual method "OnTitleChanged".
Empty Catch Block,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,ExtensionInstalled,The method has an empty catch block.
Magic Number,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The following statement contains a magic number: if (extensionError != null) {  	return;  }  else if (!CheckExtension (ref extensionError)) {  	LoggingService.LogError (extensionError);  	Label errorlabel = new Label (extensionError);  	errorlabel.Wrap = true;  	HBox box = new HBox (false' 10);  	Image errorImage = new Image (Gtk.Stock.DialogError' Gtk.IconSize.Dialog);  	box.PackStart (new Label ()' true' true' 0);  	box.PackStart (errorImage' false' false' 10);  	box.PackStart (errorlabel' true' false' 10);  	box.PackStart (new Label ()' true' true' 0);  	designerFrame.Add (box);  	designerFrame.ShowAll ();  	return;  }  else {  	extensionError = null;  }  
Magic Number,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The following statement contains a magic number: if (extensionError != null) {  	return;  }  else if (!CheckExtension (ref extensionError)) {  	LoggingService.LogError (extensionError);  	Label errorlabel = new Label (extensionError);  	errorlabel.Wrap = true;  	HBox box = new HBox (false' 10);  	Image errorImage = new Image (Gtk.Stock.DialogError' Gtk.IconSize.Dialog);  	box.PackStart (new Label ()' true' true' 0);  	box.PackStart (errorImage' false' false' 10);  	box.PackStart (errorlabel' true' false' 10);  	box.PackStart (new Label ()' true' true' 0);  	designerFrame.Add (box);  	designerFrame.ShowAll ();  	return;  }  else {  	extensionError = null;  }  
Magic Number,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The following statement contains a magic number: if (extensionError != null) {  	return;  }  else if (!CheckExtension (ref extensionError)) {  	LoggingService.LogError (extensionError);  	Label errorlabel = new Label (extensionError);  	errorlabel.Wrap = true;  	HBox box = new HBox (false' 10);  	Image errorImage = new Image (Gtk.Stock.DialogError' Gtk.IconSize.Dialog);  	box.PackStart (new Label ()' true' true' 0);  	box.PackStart (errorImage' false' false' 10);  	box.PackStart (errorlabel' true' false' 10);  	box.PackStart (new Label ()' true' true' 0);  	designerFrame.Add (box);  	designerFrame.ShowAll ();  	return;  }  else {  	extensionError = null;  }  
Magic Number,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The following statement contains a magic number: if (!CheckExtension (ref extensionError)) {  	LoggingService.LogError (extensionError);  	Label errorlabel = new Label (extensionError);  	errorlabel.Wrap = true;  	HBox box = new HBox (false' 10);  	Image errorImage = new Image (Gtk.Stock.DialogError' Gtk.IconSize.Dialog);  	box.PackStart (new Label ()' true' true' 0);  	box.PackStart (errorImage' false' false' 10);  	box.PackStart (errorlabel' true' false' 10);  	box.PackStart (new Label ()' true' true' 0);  	designerFrame.Add (box);  	designerFrame.ShowAll ();  	return;  }  else {  	extensionError = null;  }  
Magic Number,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The following statement contains a magic number: if (!CheckExtension (ref extensionError)) {  	LoggingService.LogError (extensionError);  	Label errorlabel = new Label (extensionError);  	errorlabel.Wrap = true;  	HBox box = new HBox (false' 10);  	Image errorImage = new Image (Gtk.Stock.DialogError' Gtk.IconSize.Dialog);  	box.PackStart (new Label ()' true' true' 0);  	box.PackStart (errorImage' false' false' 10);  	box.PackStart (errorlabel' true' false' 10);  	box.PackStart (new Label ()' true' true' 0);  	designerFrame.Add (box);  	designerFrame.ShowAll ();  	return;  }  else {  	extensionError = null;  }  
Magic Number,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The following statement contains a magic number: if (!CheckExtension (ref extensionError)) {  	LoggingService.LogError (extensionError);  	Label errorlabel = new Label (extensionError);  	errorlabel.Wrap = true;  	HBox box = new HBox (false' 10);  	Image errorImage = new Image (Gtk.Stock.DialogError' Gtk.IconSize.Dialog);  	box.PackStart (new Label ()' true' true' 0);  	box.PackStart (errorImage' false' false' 10);  	box.PackStart (errorlabel' true' false' 10);  	box.PackStart (new Label ()' true' true' 0);  	designerFrame.Add (box);  	designerFrame.ShowAll ();  	return;  }  else {  	extensionError = null;  }  
Magic Number,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The following statement contains a magic number: box.PackStart (errorImage' false' false' 10);  
Magic Number,AspNetEdit.Integration,AspNetEditViewContent,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\AspNetEditViewContent.cs,Selected,The following statement contains a magic number: box.PackStart (errorlabel' true' false' 10);  
Magic Number,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,exposeHandler,The following statement contains a magic number: if (!reShown) {  	Hide ();  	Show ();  	//Normally we would expect this event to fire with every redraw event' so put in a limiter   	//in case this is fixed in future.  	reShown = true;  	GLib.Timeout.Add (1000' delegate {  		reShown = false;  		return false;  	});  }  
Magic Number,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,exposeHandler,The following statement contains a magic number: GLib.Timeout.Add (1000' delegate {  	reShown = false;  	return false;  });  
Magic Number,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,realLoadUrl,The following statement contains a magic number: if (url.StartsWith ("tempfile://")) {  	oldTempFile = url.Substring (11);  	base.LoadUrl (oldTempFile);  }  else {  	base.LoadUrl (url);  }  
Magic Number,AspNetEdit.Integration,GeckoWebBrowser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Integration\GeckoWebBrowser.cs,realLoadUrl,The following statement contains a magic number: oldTempFile = url.Substring (11);  
Magic Number,AspNetEdit.Editor.Persistence,ParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ParsingObject.cs,CreateChildParsingObject,The following statement contains a magic number: if (str.Length != 2)  	throw new ParseException (location' "Server tag name is not of form prefix:name");  
Magic Number,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,ServerObjectParsingObject,The following statement contains a magic number: foreach (DictionaryEntry de in attributes) {  	if (0 == string.Compare ((string)de.Key' "runat"))  		continue;  	if (0 == string.Compare ((string)de.Key' "ID"))  		continue;  	//use the dash subproperty syntax  	string[] str = ((string)de.Key).Split ('-');  	PropertyDescriptor pd = pdc.Find (str [0]' true);  	//if property not found' try events  	if (str.Length == 1 && pd == null && CultureInfo.InvariantCulture.CompareInfo.IsPrefix (str [0].ToLower ()' "on")) {  		IEventBindingService iebs = (IEventBindingService)DesignerHost.GetService (typeof(IEventBindingService));  		if (iebs == null)  			throw new Exception ("Could not obtain IEventBindingService from host");  		EventDescriptorCollection edc = TypeDescriptor.GetEvents (obj);  		EventDescriptor e = edc.Find (str [0].Remove (0' 2)' true);  		if (e != null)  			pd = iebs.GetEventProperty (e);  		else  			throw new Exception ("Could not find event " + str [0].Remove (0' 2));  	}  	object loopObj = obj;  	for (int i = 0; i < str.Length; i++) {  		if (pd == null)  			throw new Exception ("Could not find property " + (string)de.Key);  		if (i == str.Length - 1) {  			pd.SetValue (obj' pd.Converter.ConvertFromString ((string)de.Value));  			break;  		}  		loopObj = pd.GetValue (loopObj);  		pd = TypeDescriptor.GetProperties (loopObj).Find (str [0]' true);  	}  }  
Magic Number,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,ServerObjectParsingObject,The following statement contains a magic number: foreach (DictionaryEntry de in attributes) {  	if (0 == string.Compare ((string)de.Key' "runat"))  		continue;  	if (0 == string.Compare ((string)de.Key' "ID"))  		continue;  	//use the dash subproperty syntax  	string[] str = ((string)de.Key).Split ('-');  	PropertyDescriptor pd = pdc.Find (str [0]' true);  	//if property not found' try events  	if (str.Length == 1 && pd == null && CultureInfo.InvariantCulture.CompareInfo.IsPrefix (str [0].ToLower ()' "on")) {  		IEventBindingService iebs = (IEventBindingService)DesignerHost.GetService (typeof(IEventBindingService));  		if (iebs == null)  			throw new Exception ("Could not obtain IEventBindingService from host");  		EventDescriptorCollection edc = TypeDescriptor.GetEvents (obj);  		EventDescriptor e = edc.Find (str [0].Remove (0' 2)' true);  		if (e != null)  			pd = iebs.GetEventProperty (e);  		else  			throw new Exception ("Could not find event " + str [0].Remove (0' 2));  	}  	object loopObj = obj;  	for (int i = 0; i < str.Length; i++) {  		if (pd == null)  			throw new Exception ("Could not find property " + (string)de.Key);  		if (i == str.Length - 1) {  			pd.SetValue (obj' pd.Converter.ConvertFromString ((string)de.Value));  			break;  		}  		loopObj = pd.GetValue (loopObj);  		pd = TypeDescriptor.GetProperties (loopObj).Find (str [0]' true);  	}  }  
Magic Number,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,ServerObjectParsingObject,The following statement contains a magic number: if (str.Length == 1 && pd == null && CultureInfo.InvariantCulture.CompareInfo.IsPrefix (str [0].ToLower ()' "on")) {  	IEventBindingService iebs = (IEventBindingService)DesignerHost.GetService (typeof(IEventBindingService));  	if (iebs == null)  		throw new Exception ("Could not obtain IEventBindingService from host");  	EventDescriptorCollection edc = TypeDescriptor.GetEvents (obj);  	EventDescriptor e = edc.Find (str [0].Remove (0' 2)' true);  	if (e != null)  		pd = iebs.GetEventProperty (e);  	else  		throw new Exception ("Could not find event " + str [0].Remove (0' 2));  }  
Magic Number,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,ServerObjectParsingObject,The following statement contains a magic number: if (str.Length == 1 && pd == null && CultureInfo.InvariantCulture.CompareInfo.IsPrefix (str [0].ToLower ()' "on")) {  	IEventBindingService iebs = (IEventBindingService)DesignerHost.GetService (typeof(IEventBindingService));  	if (iebs == null)  		throw new Exception ("Could not obtain IEventBindingService from host");  	EventDescriptorCollection edc = TypeDescriptor.GetEvents (obj);  	EventDescriptor e = edc.Find (str [0].Remove (0' 2)' true);  	if (e != null)  		pd = iebs.GetEventProperty (e);  	else  		throw new Exception ("Could not find event " + str [0].Remove (0' 2));  }  
Magic Number,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,ServerObjectParsingObject,The following statement contains a magic number: if (e != null)  	pd = iebs.GetEventProperty (e);  else  	throw new Exception ("Could not find event " + str [0].Remove (0' 2));  
Magic Number,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,ServerObjectParsingObject,The following statement contains a magic number: throw new Exception ("Could not find event " + str [0].Remove (0' 2));  
Magic Number,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,CreateChildParsingObject,The following statement contains a magic number: switch (mode) {  case ParseChildrenMode.DefaultProperty:  	//oops' we didn't need to tokenise this.  	innerText += location.PlainText;  	//how do we get end tag?  	throw new NotImplementedException ("Inner default properties that look like tags have not been implemented yet.");  case ParseChildrenMode.DefaultEncodedProperty:  	innerText += System.Web.HttpUtility.HtmlDecode (location.PlainText);  	//how do we get end tag?  	throw new NotImplementedException ("Inner default properties that look like tags have not been implemented yet.");  case ParseChildrenMode.Controls:  	//html tags  	if (tagid.IndexOf (':') == -1)  		return new HtmlParsingObject (location.PlainText' tagid' this);  	goto case ParseChildrenMode.DefaultCollectionProperty;  case ParseChildrenMode.DefaultCollectionProperty:  	string[] str = tagid.Split (':');  	if (str.Length != 2)  		throw new ParseException (location' "Server tag name is not of form prefix:name");  	Type tagType = WebFormReferenceManager.GetObjectType (str [0]' str [1]);  	if (tagType == null)  		throw new ParseException (location' "The tag " + tagid + "has not been registered");  	return new ServerObjectParsingObject (tagType' attributes.GetDictionary (null)' tagid' this);  case ParseChildrenMode.Properties:  	throw new NotImplementedException ("Multiple child properties have not yet been implemented.");  }  
Magic Number,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,CreateChildParsingObject,The following statement contains a magic number: if (str.Length != 2)  	throw new ParseException (location' "Server tag name is not of form prefix:name");  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: while (pos < length) {  	char c = frag [pos];  	switch (mode) {  	//it's freely copying to output' but watching for a directive or control placeholder   	case SMode.Free:  		if (c == '<') {  			if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  				mode = SMode.ControlId;  				pos += 10;  				break;  			}  			else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  				mode = SMode.DirectiveId;  				pos += 20;  				break;  			}  		}  		writer.Write (c);  		break;  	//it's found a directive placeholder and is scanning for the ID  	case SMode.DirectiveId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  			//TODO: more intelligent removal/copying of directives in case of fragments  			//works fine with whole document.  			string directive = RemoveDirective (id);  			writer.Write (directive);  			mode = SMode.DirectiveEnd;  			pos = idEnd;  		}  		break;  	//it's found a control placeholder and is scanning for the ID  	case SMode.ControlId:  		if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  			int idEnd = frag.IndexOf ("\""' pos + 4);  			if (idEnd == -1)  				throw new Exception ("Identifier was unterminated");  			string id = frag.Substring (pos + 4' (idEnd - pos - 4));  			DesignContainer dc = (DesignContainer)host.Container;  			Control control = dc.GetComponent (id) as Control;  			if (control == null)  				throw new Exception ("Could not retrieve control " + id);  			ControlPersister.PersistControl (writer' control);  			mode = SMode.ControlEnd;  			pos = idEnd;  		}  		break;  	//it's found the control's ID and is looking for the end  	case SMode.ControlEnd:  		if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  			pos += 12;  			mode = SMode.Free;  		}  		break;  	//it's found the placeholder's ID and is looking for the end  	case SMode.DirectiveEnd:  		if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  			pos += 1;  			mode = SMode.Free;  		}  		break;  	}  	pos++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<') {  	if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  		mode = SMode.ControlId;  		pos += 10;  		break;  	}  	else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  		mode = SMode.DirectiveId;  		pos += 20;  		break;  	}  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<') {  	if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  		mode = SMode.ControlId;  		pos += 10;  		break;  	}  	else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  		mode = SMode.DirectiveId;  		pos += 20;  		break;  	}  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<') {  	if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  		mode = SMode.ControlId;  		pos += 10;  		break;  	}  	else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  		mode = SMode.DirectiveId;  		pos += 20;  		break;  	}  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<') {  	if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  		mode = SMode.ControlId;  		pos += 10;  		break;  	}  	else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  		mode = SMode.DirectiveId;  		pos += 20;  		break;  	}  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<') {  	if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  		mode = SMode.ControlId;  		pos += 10;  		break;  	}  	else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  		mode = SMode.DirectiveId;  		pos += 20;  		break;  	}  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<') {  	if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  		mode = SMode.ControlId;  		pos += 10;  		break;  	}  	else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  		mode = SMode.DirectiveId;  		pos += 20;  		break;  	}  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  	mode = SMode.ControlId;  	pos += 10;  	break;  }  else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  	mode = SMode.ControlId;  	pos += 10;  	break;  }  else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  	mode = SMode.ControlId;  	pos += 10;  	break;  }  else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  	mode = SMode.ControlId;  	pos += 10;  	break;  }  else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  	mode = SMode.ControlId;  	pos += 10;  	break;  }  else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  	mode = SMode.ControlId;  	pos += 10;  	break;  }  else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: pos += 10;  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  	mode = SMode.DirectiveId;  	pos += 20;  	break;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: pos += 20;  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  	//TODO: more intelligent removal/copying of directives in case of fragments  	//works fine with whole document.  	string directive = RemoveDirective (id);  	writer.Write (directive);  	mode = SMode.DirectiveEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  	//TODO: more intelligent removal/copying of directives in case of fragments  	//works fine with whole document.  	string directive = RemoveDirective (id);  	writer.Write (directive);  	mode = SMode.DirectiveEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  	//TODO: more intelligent removal/copying of directives in case of fragments  	//works fine with whole document.  	string directive = RemoveDirective (id);  	writer.Write (directive);  	mode = SMode.DirectiveEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  	//TODO: more intelligent removal/copying of directives in case of fragments  	//works fine with whole document.  	string directive = RemoveDirective (id);  	writer.Write (directive);  	mode = SMode.DirectiveEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  	//TODO: more intelligent removal/copying of directives in case of fragments  	//works fine with whole document.  	string directive = RemoveDirective (id);  	writer.Write (directive);  	mode = SMode.DirectiveEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ("\""' pos + 4);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	string id = frag.Substring (pos + 4' (idEnd - pos - 4));  	DesignContainer dc = (DesignContainer)host.Container;  	Control control = dc.GetComponent (id) as Control;  	if (control == null)  		throw new Exception ("Could not retrieve control " + id);  	ControlPersister.PersistControl (writer' control);  	mode = SMode.ControlEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ("\""' pos + 4);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	string id = frag.Substring (pos + 4' (idEnd - pos - 4));  	DesignContainer dc = (DesignContainer)host.Container;  	Control control = dc.GetComponent (id) as Control;  	if (control == null)  		throw new Exception ("Could not retrieve control " + id);  	ControlPersister.PersistControl (writer' control);  	mode = SMode.ControlEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ("\""' pos + 4);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	string id = frag.Substring (pos + 4' (idEnd - pos - 4));  	DesignContainer dc = (DesignContainer)host.Container;  	Control control = dc.GetComponent (id) as Control;  	if (control == null)  		throw new Exception ("Could not retrieve control " + id);  	ControlPersister.PersistControl (writer' control);  	mode = SMode.ControlEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ("\""' pos + 4);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	string id = frag.Substring (pos + 4' (idEnd - pos - 4));  	DesignContainer dc = (DesignContainer)host.Container;  	Control control = dc.GetComponent (id) as Control;  	if (control == null)  		throw new Exception ("Could not retrieve control " + id);  	ControlPersister.PersistControl (writer' control);  	mode = SMode.ControlEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  	int idEnd = frag.IndexOf ("\""' pos + 4);  	if (idEnd == -1)  		throw new Exception ("Identifier was unterminated");  	string id = frag.Substring (pos + 4' (idEnd - pos - 4));  	DesignContainer dc = (DesignContainer)host.Container;  	Control control = dc.GetComponent (id) as Control;  	if (control == null)  		throw new Exception ("Could not retrieve control " + id);  	ControlPersister.PersistControl (writer' control);  	mode = SMode.ControlEnd;  	pos = idEnd;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  	pos += 12;  	mode = SMode.Free;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  	pos += 12;  	mode = SMode.Free;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  	pos += 12;  	mode = SMode.Free;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: pos += 12;  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  	pos += 1;  	mode = SMode.Free;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following statement contains a magic number: if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  	pos += 1;  	mode = SMode.Free;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,MenuCommandService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\MenuCommandService.cs,ShowContextMenu,The following statement contains a magic number: contextMenu.Popup (null' null' new MenuPositionFunc (positionFunc)' 2' Gtk.Global.CurrentEventTime);  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: for (int i = index; i < end; i++) {  	int val = buffer [i];  	int high = val >> 4;  	int low = val & 15;  	if (high > 9)  		w.Write ((char)(high + 55));  	else  		w.Write ((char)(high + 0x30));  	if (low > 9)  		w.Write ((char)(low + 55));  	else  		w.Write ((char)(low + 0x30));  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: for (int i = index; i < end; i++) {  	int val = buffer [i];  	int high = val >> 4;  	int low = val & 15;  	if (high > 9)  		w.Write ((char)(high + 55));  	else  		w.Write ((char)(high + 0x30));  	if (low > 9)  		w.Write ((char)(low + 55));  	else  		w.Write ((char)(low + 0x30));  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: for (int i = index; i < end; i++) {  	int val = buffer [i];  	int high = val >> 4;  	int low = val & 15;  	if (high > 9)  		w.Write ((char)(high + 55));  	else  		w.Write ((char)(high + 0x30));  	if (low > 9)  		w.Write ((char)(low + 55));  	else  		w.Write ((char)(low + 0x30));  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: for (int i = index; i < end; i++) {  	int val = buffer [i];  	int high = val >> 4;  	int low = val & 15;  	if (high > 9)  		w.Write ((char)(high + 55));  	else  		w.Write ((char)(high + 0x30));  	if (low > 9)  		w.Write ((char)(low + 55));  	else  		w.Write ((char)(low + 0x30));  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: for (int i = index; i < end; i++) {  	int val = buffer [i];  	int high = val >> 4;  	int low = val & 15;  	if (high > 9)  		w.Write ((char)(high + 55));  	else  		w.Write ((char)(high + 0x30));  	if (low > 9)  		w.Write ((char)(low + 55));  	else  		w.Write ((char)(low + 0x30));  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: for (int i = index; i < end; i++) {  	int val = buffer [i];  	int high = val >> 4;  	int low = val & 15;  	if (high > 9)  		w.Write ((char)(high + 55));  	else  		w.Write ((char)(high + 0x30));  	if (low > 9)  		w.Write ((char)(low + 55));  	else  		w.Write ((char)(low + 0x30));  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: if (high > 9)  	w.Write ((char)(high + 55));  else  	w.Write ((char)(high + 0x30));  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: if (high > 9)  	w.Write ((char)(high + 55));  else  	w.Write ((char)(high + 0x30));  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: w.Write ((char)(high + 55));  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: if (low > 9)  	w.Write ((char)(low + 55));  else  	w.Write ((char)(low + 0x30));  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: if (low > 9)  	w.Write ((char)(low + 55));  else  	w.Write ((char)(low + 0x30));  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,WriteBinHex,The following statement contains a magic number: w.Write ((char)(low + 55));  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: for (int i = 0; i < charLength - 1; i += 2) {  	buffer [bufIndex] = (chars [i] > '9' ? (byte)(chars [i] - 'A' + 10) : (byte)(chars [i] - '0'));  	buffer [bufIndex] <<= 4;  	buffer [bufIndex] += chars [i + 1] > '9' ? (byte)(chars [i + 1] - 'A' + 10) : (byte)(chars [i + 1] - '0');  	bufIndex++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: for (int i = 0; i < charLength - 1; i += 2) {  	buffer [bufIndex] = (chars [i] > '9' ? (byte)(chars [i] - 'A' + 10) : (byte)(chars [i] - '0'));  	buffer [bufIndex] <<= 4;  	buffer [bufIndex] += chars [i + 1] > '9' ? (byte)(chars [i + 1] - 'A' + 10) : (byte)(chars [i + 1] - '0');  	bufIndex++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: for (int i = 0; i < charLength - 1; i += 2) {  	buffer [bufIndex] = (chars [i] > '9' ? (byte)(chars [i] - 'A' + 10) : (byte)(chars [i] - '0'));  	buffer [bufIndex] <<= 4;  	buffer [bufIndex] += chars [i + 1] > '9' ? (byte)(chars [i + 1] - 'A' + 10) : (byte)(chars [i + 1] - '0');  	bufIndex++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: for (int i = 0; i < charLength - 1; i += 2) {  	buffer [bufIndex] = (chars [i] > '9' ? (byte)(chars [i] - 'A' + 10) : (byte)(chars [i] - '0'));  	buffer [bufIndex] <<= 4;  	buffer [bufIndex] += chars [i + 1] > '9' ? (byte)(chars [i + 1] - 'A' + 10) : (byte)(chars [i + 1] - '0');  	bufIndex++;  }  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: i += 2
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: buffer [bufIndex] = (chars [i] > '9' ? (byte)(chars [i] - 'A' + 10) : (byte)(chars [i] - '0'));  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: buffer [bufIndex] <<= 4;  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: buffer [bufIndex] += chars [i + 1] > '9' ? (byte)(chars [i + 1] - 'A' + 10) : (byte)(chars [i + 1] - '0');  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: if (charLength % 2 != 0)  	buffer [bufIndex++] = (byte)((chars [charLength - 1] > '9' ? (byte)(chars [charLength - 1] - 'A' + 10) : (byte)(chars [charLength - 1] - '0')) << 4);  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: if (charLength % 2 != 0)  	buffer [bufIndex++] = (byte)((chars [charLength - 1] > '9' ? (byte)(chars [charLength - 1] - 'A' + 10) : (byte)(chars [charLength - 1] - '0')) << 4);  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: if (charLength % 2 != 0)  	buffer [bufIndex++] = (byte)((chars [charLength - 1] > '9' ? (byte)(chars [charLength - 1] - 'A' + 10) : (byte)(chars [charLength - 1] - '0')) << 4);  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: buffer [bufIndex++] = (byte)((chars [charLength - 1] > '9' ? (byte)(chars [charLength - 1] - 'A' + 10) : (byte)(chars [charLength - 1] - '0')) << 4);  
Magic Number,AspNetEdit.Editor.ComponentModel,ToolboxService,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\ToolboxService.cs,FromBinHexString,The following statement contains a magic number: buffer [bufIndex++] = (byte)((chars [charLength - 1] > '9' ? (byte)(chars [charLength - 1] - 'A' + 10) : (byte)(chars [charLength - 1] - '0')) << 4);  
Magic Number,AspNetEdit.Editor.UI,PropertyGrid,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: this.PackStart (combo' false' false' 3);  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,GetDocument,The following statement contains a magic number: do {  	//only allow JS 20 seconds to return value  	if (counter > 200)  		throw new Exception ("Mozilla did not return value during 20 seconds");  	System.Threading.Thread.Sleep (100);  	counter++;  }  while (outDocument == null);  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,GetDocument,The following statement contains a magic number: do {  	//only allow JS 20 seconds to return value  	if (counter > 200)  		throw new Exception ("Mozilla did not return value during 20 seconds");  	System.Threading.Thread.Sleep (100);  	counter++;  }  while (outDocument == null);  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,GetDocument,The following statement contains a magic number: if (counter > 200)  	throw new Exception ("Mozilla did not return value during 20 seconds");  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,GetDocument,The following statement contains a magic number: System.Threading.Thread.Sleep (100);  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,GetDocument,The following statement contains a magic number: System.Diagnostics.Trace.WriteLine ("Retrieved document from Gecko in ~" + (100 * counter).ToString () + "ms.");  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,JSClick,The following statement contains a magic number: if (args.Length != 2)  	throw new InvalidJSArgumentException ("Click"' -1);  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,JSException,The following statement contains a magic number: if (args.Length != 2)  	throw new InvalidJSArgumentException ("ThrowException"' -1);  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,JSResize,The following statement contains a magic number: if (args.Length != 3)  	throw new InvalidJSArgumentException ("ResizeControl"' -1);  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,JSResize,The following statement contains a magic number: pdc_h.SetValue (wc' pdc_h.Converter.ConvertFromInvariantString (args [2]));  
Magic Number,AspNetEdit.Editor.UI,RootDesignerView,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.UI\RootDesignerView.cs,JSResize,The following statement contains a magic number: System.Diagnostics.Trace.WriteLine (String.Format ("Javascript requesting size change to w:{0} h:{1} for control {2}."' args [1]' args [2]' args [0]));  
Magic Number,AspNetEdit.JSCall,CommandManager,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.JSCall\CommandManager.cs,webControl_ECMAStatus,The following statement contains a magic number: if (call.Length < 2)  	throw new Exception ("Too few parameters in call from JavaScript.");  
Magic Number,AspNetEdit.JSCall,CommandManager,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.JSCall\CommandManager.cs,webControl_ECMAStatus,The following statement contains a magic number: System.Array.Copy (call' 3' args' 0' (call.Length - 3));  
Magic Number,AspNetEdit.JSCall,CommandManager,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.JSCall\CommandManager.cs,webControl_ECMAStatus,The following statement contains a magic number: System.Array.Copy (call' 3' args' 0' (call.Length - 3));  
Missing Default,AspNetEdit.Editor.Persistence,ControlPersister,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ControlPersister.cs,PersistInnerProperties,The following switch statement is missing a default case: switch (modeAttrib.Mode) {  case PersistenceMode.EncodedInnerDefaultProperty:  	if (contentStarted)  		throw new Exception ("The Control has inner properties in addition to a default inner property");  	if (prop.Converter.CanConvertTo (typeof(string))) {  		writer.Write (System.Web.HttpUtility.HtmlEncode (prop.Converter.ConvertToString (prop.GetValue (component))));  		return;  	}  	break;  case PersistenceMode.InnerDefaultProperty:  	if (contentStarted)  		throw new Exception ("The Control has inner properties in addition to a default inner property");  	PersistInnerProperty (prop' prop.GetValue (component)' writer' host' true);  	return;  case PersistenceMode.InnerProperty:  	PersistInnerProperty (prop' prop.GetValue (component)' writer' host' false);  	contentStarted = true;  	break;  }  
Missing Default,AspNetEdit.Editor.Persistence,DesignTimeParser,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\DesignTimeParser.cs,TagParsed,The following switch statement is missing a default case: switch (tagtype) {  case TagType.Close:  	if (openObject == null)  		throw new ParseException (location' "There are more closing tags than opening tags");  	if (0 != string.Compare (openObject.TagID' tagid))  		throw new ParseException (location' "Closing tag " + tagid + " does not match opening tag " + openObject.TagID);  	openObject = openObject.CloseObject (location.PlainText);  	break;  case TagType.CodeRender:  	throw new NotImplementedException ("Code render expressions have not yet been implemented: " + location.PlainText);  //break;  case TagType.CodeRenderExpression:  	throw new NotImplementedException ("Code render expressions have not yet been implemented: " + location.PlainText);  //break;  case TagType.DataBinding:  	throw new NotImplementedException ("Data binding expressions have not yet been implemented: " + location.PlainText);  //break;  case TagType.Directive:  	ProcessDirective (tagid' attributes);  	break;  case TagType.Include:  	throw new NotImplementedException ("Server-side includes have not yet been implemented: " + location.PlainText);  //break;  case TagType.ServerComment:  	throw new NotImplementedException ("Server comments have not yet been implemented: " + location.PlainText);  //break;  case TagType.Tag:  	//TODO: don't do this for XHTML  	if ((string.Compare (tagid' "br"' true) == 0) || (string.Compare (tagid' "hr"' true) == 0))  		goto case TagType.SelfClosing;  	openObject = openObject.CreateChildParsingObject (location' tagid' attributes);  	break;  case TagType.SelfClosing:  	if (openObject == null)  		throw new Exception ("Root tag cannot be self-closing");  	openObject = openObject.CreateChildParsingObject (location' tagid' attributes);  	openObject = openObject.CloseObject (string.Empty);  	break;  case TagType.Text:  	throw new NotImplementedException ("Text tagtypes have not yet been implemented: " + location.PlainText);  //break;  }  
Missing Default,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,ServerObjectParsingObject,The following switch statement is missing a default case: switch (modeAttrib.Mode) {  case PersistenceMode.Attribute:  	continue;  case PersistenceMode.EncodedInnerDefaultProperty:  	parseAtt.DefaultProperty = pd.Name;  	mode = ParseChildrenMode.DefaultEncodedProperty;  	break;  case PersistenceMode.InnerDefaultProperty:  	parseAtt.DefaultProperty = pd.Name;  	if (pd.PropertyType.GetInterface ("System.Collections.IList") == (typeof(IList)))  		mode = ParseChildrenMode.DefaultCollectionProperty;  	else  		mode = ParseChildrenMode.DefaultProperty;  	break;  case PersistenceMode.InnerProperty:  	mode = ParseChildrenMode.Properties;  	break;  }  
Missing Default,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,AddText,The following switch statement is missing a default case: switch (mode) {  case ParseChildrenMode.Controls:  	this.AddControl (new LiteralControl (text));  	return;  case ParseChildrenMode.DefaultCollectionProperty:  case ParseChildrenMode.Properties:  	if (IsWhiteSpace (text))  		return;  	else  		throw new Exception ("Unexpected text found in child properties");  case ParseChildrenMode.DefaultProperty:  	innerText += text;  	return;  case ParseChildrenMode.DefaultEncodedProperty:  	innerText += System.Web.HttpUtility.HtmlDecode (text);  	return;  }  
Missing Default,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,CreateChildParsingObject,The following switch statement is missing a default case: switch (mode) {  case ParseChildrenMode.DefaultProperty:  	//oops' we didn't need to tokenise this.  	innerText += location.PlainText;  	//how do we get end tag?  	throw new NotImplementedException ("Inner default properties that look like tags have not been implemented yet.");  case ParseChildrenMode.DefaultEncodedProperty:  	innerText += System.Web.HttpUtility.HtmlDecode (location.PlainText);  	//how do we get end tag?  	throw new NotImplementedException ("Inner default properties that look like tags have not been implemented yet.");  case ParseChildrenMode.Controls:  	//html tags  	if (tagid.IndexOf (':') == -1)  		return new HtmlParsingObject (location.PlainText' tagid' this);  	goto case ParseChildrenMode.DefaultCollectionProperty;  case ParseChildrenMode.DefaultCollectionProperty:  	string[] str = tagid.Split (':');  	if (str.Length != 2)  		throw new ParseException (location' "Server tag name is not of form prefix:name");  	Type tagType = WebFormReferenceManager.GetObjectType (str [0]' str [1]);  	if (tagType == null)  		throw new ParseException (location' "The tag " + tagid + "has not been registered");  	return new ServerObjectParsingObject (tagType' attributes.GetDictionary (null)' tagid' this);  case ParseChildrenMode.Properties:  	throw new NotImplementedException ("Multiple child properties have not yet been implemented.");  }  
Missing Default,AspNetEdit.Editor.Persistence,ServerObjectParsingObject,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.Persistence\ServerControlParsingObject.cs,AddControl,The following switch statement is missing a default case: switch (mode) {  case ParseChildrenMode.DefaultProperty:  case ParseChildrenMode.Properties:  	throw new Exception ("Cannot add a control to default property");  case ParseChildrenMode.DefaultCollectionProperty:  	PropertyDescriptor pd = pdc [parseAtt.DefaultProperty];  	((IList)pd.GetValue (obj)).Add (control);  	return;  case ParseChildrenMode.Controls:  	throw new NotImplementedException ("Child controls have not yet been implemented.");  }  
Missing Default,AspNetEdit.Editor.ComponentModel,Document,C:\repos\joncloud_monodevelop\extras\AspNetEdit\AspNetEdit.Editor.ComponentModel\Document.cs,Serialize,The following switch statement is missing a default case: switch (mode) {  //it's freely copying to output' but watching for a directive or control placeholder   case SMode.Free:  	if (c == '<') {  		if ((pos + 10 < length) && frag.Substring (pos + 1' 10) == "aspcontrol") {  			mode = SMode.ControlId;  			pos += 10;  			break;  		}  		else if ((pos + 20 < length) && frag.Substring (pos + 1' 20) == "directiveplaceholder") {  			mode = SMode.DirectiveId;  			pos += 20;  			break;  		}  	}  	writer.Write (c);  	break;  //it's found a directive placeholder and is scanning for the ID  case SMode.DirectiveId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ('"'' pos + 4 + 1);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		int id = Int32.Parse (frag.Substring (pos + 4' (idEnd - pos - 4)));  		//TODO: more intelligent removal/copying of directives in case of fragments  		//works fine with whole document.  		string directive = RemoveDirective (id);  		writer.Write (directive);  		mode = SMode.DirectiveEnd;  		pos = idEnd;  	}  	break;  //it's found a control placeholder and is scanning for the ID  case SMode.ControlId:  	if (c == 'i' && (pos + 4 < length) && frag.Substring (pos' 4) == "id=\"") {  		int idEnd = frag.IndexOf ("\""' pos + 4);  		if (idEnd == -1)  			throw new Exception ("Identifier was unterminated");  		string id = frag.Substring (pos + 4' (idEnd - pos - 4));  		DesignContainer dc = (DesignContainer)host.Container;  		Control control = dc.GetComponent (id) as Control;  		if (control == null)  			throw new Exception ("Could not retrieve control " + id);  		ControlPersister.PersistControl (writer' control);  		mode = SMode.ControlEnd;  		pos = idEnd;  	}  	break;  //it's found the control's ID and is looking for the end  case SMode.ControlEnd:  	if (c == '<' && (pos + 13 < length) && frag.Substring (pos' 13) == "</aspcontrol>") {  		pos += 12;  		mode = SMode.Free;  	}  	break;  //it's found the placeholder's ID and is looking for the end  case SMode.DirectiveEnd:  	if (c == '/' && (pos + 2 < length) && frag.Substring (pos' 2) == "/>") {  		pos += 1;  		mode = SMode.Free;  	}  	break;  }  
