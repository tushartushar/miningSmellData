Implementation smell,Namespace,Class,File,Method,Description
Long Method,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The method has 150 lines of code.
Long Method,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The method has 136 lines of code.
Long Method,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The method has 140 lines of code.
Complex Method,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,Cyclomatic complexity of the method is 33
Complex Method,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,Cyclomatic complexity of the method is 26
Complex Method,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Escape,Cyclomatic complexity of the method is 25
Complex Method,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,Cyclomatic complexity of the method is 96
Complex Method,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Deserialize,Cyclomatic complexity of the method is 19
Long Statement,Assets.Plugins,ObjectPool,C:\repos\nightwolfz_Game1\Assets\Plugins\ObjectPool.cs,GetObjectForType,The length of the statement  "	//If we have gotten here either there was no object of the specified type or non were left in the pool with onlyPooled set to true " is 130.
Long Statement,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,SaveToCompressedStream,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,SaveToCompressedFile,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,SaveToCompressedBase64,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,LoadFromCompressedFile,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,LoadFromCompressedStream,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Long Statement,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,LoadFromCompressedBase64,The length of the statement  "	throw new Exception ("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON"); " is 139.
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (emit && emitTime > 0) {  	emitTime -= Time.deltaTime;  	if (emitTime < 0.001)  		emit = false;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (emitTime < 0.001)  	emit = false;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (emit) {  	if (theDistance > minVertexDistance) {  		bool make = false;  		if (points.Count < 3) {  			make = true;  		}  		else {  			Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  			Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  			if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  				make = true;  		}  		if (make) {  			Point p = new Point ();  			p.Position = transform.position;  			p.TimeCreated = Time.time;  			points.Add (p);  			_lastPosition = transform.position;  		}  		else {  			((Point)points [points.Count - 1]).Position = transform.position;  			((Point)points [points.Count - 1]).TimeCreated = Time.time;  		}  	}  	else if (points.Count > 0) {  		((Point)points [points.Count - 1]).Position = transform.position;  		((Point)points [points.Count - 1]).TimeCreated = Time.time;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (emit) {  	if (theDistance > minVertexDistance) {  		bool make = false;  		if (points.Count < 3) {  			make = true;  		}  		else {  			Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  			Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  			if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  				make = true;  		}  		if (make) {  			Point p = new Point ();  			p.Position = transform.position;  			p.TimeCreated = Time.time;  			points.Add (p);  			_lastPosition = transform.position;  		}  		else {  			((Point)points [points.Count - 1]).Position = transform.position;  			((Point)points [points.Count - 1]).TimeCreated = Time.time;  		}  	}  	else if (points.Count > 0) {  		((Point)points [points.Count - 1]).Position = transform.position;  		((Point)points [points.Count - 1]).TimeCreated = Time.time;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (emit) {  	if (theDistance > minVertexDistance) {  		bool make = false;  		if (points.Count < 3) {  			make = true;  		}  		else {  			Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  			Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  			if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  				make = true;  		}  		if (make) {  			Point p = new Point ();  			p.Position = transform.position;  			p.TimeCreated = Time.time;  			points.Add (p);  			_lastPosition = transform.position;  		}  		else {  			((Point)points [points.Count - 1]).Position = transform.position;  			((Point)points [points.Count - 1]).TimeCreated = Time.time;  		}  	}  	else if (points.Count > 0) {  		((Point)points [points.Count - 1]).Position = transform.position;  		((Point)points [points.Count - 1]).TimeCreated = Time.time;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (emit) {  	if (theDistance > minVertexDistance) {  		bool make = false;  		if (points.Count < 3) {  			make = true;  		}  		else {  			Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  			Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  			if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  				make = true;  		}  		if (make) {  			Point p = new Point ();  			p.Position = transform.position;  			p.TimeCreated = Time.time;  			points.Add (p);  			_lastPosition = transform.position;  		}  		else {  			((Point)points [points.Count - 1]).Position = transform.position;  			((Point)points [points.Count - 1]).TimeCreated = Time.time;  		}  	}  	else if (points.Count > 0) {  		((Point)points [points.Count - 1]).Position = transform.position;  		((Point)points [points.Count - 1]).TimeCreated = Time.time;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (theDistance > minVertexDistance) {  	bool make = false;  	if (points.Count < 3) {  		make = true;  	}  	else {  		Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  		Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  		if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  			make = true;  	}  	if (make) {  		Point p = new Point ();  		p.Position = transform.position;  		p.TimeCreated = Time.time;  		points.Add (p);  		_lastPosition = transform.position;  	}  	else {  		((Point)points [points.Count - 1]).Position = transform.position;  		((Point)points [points.Count - 1]).TimeCreated = Time.time;  	}  }  else if (points.Count > 0) {  	((Point)points [points.Count - 1]).Position = transform.position;  	((Point)points [points.Count - 1]).TimeCreated = Time.time;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (theDistance > minVertexDistance) {  	bool make = false;  	if (points.Count < 3) {  		make = true;  	}  	else {  		Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  		Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  		if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  			make = true;  	}  	if (make) {  		Point p = new Point ();  		p.Position = transform.position;  		p.TimeCreated = Time.time;  		points.Add (p);  		_lastPosition = transform.position;  	}  	else {  		((Point)points [points.Count - 1]).Position = transform.position;  		((Point)points [points.Count - 1]).TimeCreated = Time.time;  	}  }  else if (points.Count > 0) {  	((Point)points [points.Count - 1]).Position = transform.position;  	((Point)points [points.Count - 1]).TimeCreated = Time.time;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (theDistance > minVertexDistance) {  	bool make = false;  	if (points.Count < 3) {  		make = true;  	}  	else {  		Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  		Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  		if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  			make = true;  	}  	if (make) {  		Point p = new Point ();  		p.Position = transform.position;  		p.TimeCreated = Time.time;  		points.Add (p);  		_lastPosition = transform.position;  	}  	else {  		((Point)points [points.Count - 1]).Position = transform.position;  		((Point)points [points.Count - 1]).TimeCreated = Time.time;  	}  }  else if (points.Count > 0) {  	((Point)points [points.Count - 1]).Position = transform.position;  	((Point)points [points.Count - 1]).TimeCreated = Time.time;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (theDistance > minVertexDistance) {  	bool make = false;  	if (points.Count < 3) {  		make = true;  	}  	else {  		Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  		Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  		if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  			make = true;  	}  	if (make) {  		Point p = new Point ();  		p.Position = transform.position;  		p.TimeCreated = Time.time;  		points.Add (p);  		_lastPosition = transform.position;  	}  	else {  		((Point)points [points.Count - 1]).Position = transform.position;  		((Point)points [points.Count - 1]).TimeCreated = Time.time;  	}  }  else if (points.Count > 0) {  	((Point)points [points.Count - 1]).Position = transform.position;  	((Point)points [points.Count - 1]).TimeCreated = Time.time;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count < 3) {  	make = true;  }  else {  	Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  	Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  	if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  		make = true;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count < 3) {  	make = true;  }  else {  	Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  	Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  	if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  		make = true;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count < 3) {  	make = true;  }  else {  	Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  	Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  	if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  		make = true;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count < 3) {  	make = true;  }  else {  	Vector3 l1 = ((Point)points [points.Count - 2]).Position - ((Point)points [points.Count - 3]).Position;  	Vector3 l2 = ((Point)points [points.Count - 1]).Position - ((Point)points [points.Count - 2]).Position;  	if (Vector3.Angle (l1' l2) > maxAngle || theDistance > maxVertexDistance)  		make = true;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (re) {  	_lastRebuildTime = Time.time;  	ArrayList remove = new ArrayList ();  	int i = 0;  	foreach (Point p in points) {  		// cull old points first  		if (Time.time - p.TimeCreated > lifeTime)  			remove.Add (p);  		i++;  	}  	foreach (Point p in remove)  		points.Remove (p);  	remove.Clear ();  	if (points.Count > 1) {  		Vector3[] newVertices = new Vector3[points.Count * 2];  		Vector2[] newUV = new Vector2[points.Count * 2];  		int[] newTriangles = new int[(points.Count - 1) * 6];  		Color[] newColors = new Color[points.Count * 2];  		i = 0;  		float curDistance = 0.00f;  		foreach (Point p in points) {  			float time = (Time.time - p.TimeCreated) / lifeTime;  			Color color = Color.Lerp (Color.white' Color.clear' time);  			if (Colors != null && Colors.Length > 0) {  				float colorTime = time * (Colors.Length - 1);  				float min = Mathf.Floor (colorTime);  				float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' colorTime);  				if (min >= Colors.Length)  					min = Colors.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Colors.Length)  					max = Colors.Length - 1;  				if (max < 0)  					max = 0;  				color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  			}  			float size = 1f;  			if (Sizes != null && Sizes.Length > 0) {  				float sizeTime = time * (Sizes.Length - 1);  				float min = Mathf.Floor (sizeTime);  				float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  				float lerp = Mathf.InverseLerp (min' max' sizeTime);  				if (min >= Sizes.Length)  					min = Sizes.Length - 1;  				if (min < 0)  					min = 0;  				if (max >= Sizes.Length)  					max = Sizes.Length - 1;  				if (max < 0)  					max = 0;  				size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  			}  			Vector3 perpendicular = Vector3.up;  			//Vector3.Cross(lineDirection' vectorToCamera).normalized;  			newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  			newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  			newColors [i * 2] = newColors [(i * 2) + 1] = color;  			newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  			newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  			if (i > 0 && !((Point)points [i - 1]).LineBreak) {  				if (HigherQualityUVs)  					curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  				else  					curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  				newTriangles [(i - 1) * 6] = (i * 2) - 2;  				newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  				newTriangles [((i - 1) * 6) + 2] = i * 2;  				newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  				newTriangles [((i - 1) * 6) + 4] = i * 2;  				newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  			}  			i++;  		}  		if (o != null) {  			Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  			mesh.Clear ();  			mesh.vertices = newVertices;  			mesh.colors = newColors;  			mesh.uv = newUV;  			mesh.triangles = newTriangles;  		}  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (points.Count > 1) {  	Vector3[] newVertices = new Vector3[points.Count * 2];  	Vector2[] newUV = new Vector2[points.Count * 2];  	int[] newTriangles = new int[(points.Count - 1) * 6];  	Color[] newColors = new Color[points.Count * 2];  	i = 0;  	float curDistance = 0.00f;  	foreach (Point p in points) {  		float time = (Time.time - p.TimeCreated) / lifeTime;  		Color color = Color.Lerp (Color.white' Color.clear' time);  		if (Colors != null && Colors.Length > 0) {  			float colorTime = time * (Colors.Length - 1);  			float min = Mathf.Floor (colorTime);  			float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' colorTime);  			if (min >= Colors.Length)  				min = Colors.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Colors.Length)  				max = Colors.Length - 1;  			if (max < 0)  				max = 0;  			color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  		}  		float size = 1f;  		if (Sizes != null && Sizes.Length > 0) {  			float sizeTime = time * (Sizes.Length - 1);  			float min = Mathf.Floor (sizeTime);  			float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  			float lerp = Mathf.InverseLerp (min' max' sizeTime);  			if (min >= Sizes.Length)  				min = Sizes.Length - 1;  			if (min < 0)  				min = 0;  			if (max >= Sizes.Length)  				max = Sizes.Length - 1;  			if (max < 0)  				max = 0;  			size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  		}  		Vector3 perpendicular = Vector3.up;  		//Vector3.Cross(lineDirection' vectorToCamera).normalized;  		newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  		newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  		newColors [i * 2] = newColors [(i * 2) + 1] = color;  		newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  		newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  		if (i > 0 && !((Point)points [i - 1]).LineBreak) {  			if (HigherQualityUVs)  				curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  			else  				curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  			newTriangles [(i - 1) * 6] = (i * 2) - 2;  			newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  			newTriangles [((i - 1) * 6) + 2] = i * 2;  			newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  			newTriangles [((i - 1) * 6) + 4] = i * 2;  			newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  		}  		i++;  	}  	if (o != null) {  		Mesh mesh = (o.GetComponent<MeshFilter> () as MeshFilter).mesh;  		mesh.Clear ();  		mesh.vertices = newVertices;  		mesh.colors = newColors;  		mesh.uv = newUV;  		mesh.triangles = newTriangles;  	}  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: foreach (Point p in points) {  	float time = (Time.time - p.TimeCreated) / lifeTime;  	Color color = Color.Lerp (Color.white' Color.clear' time);  	if (Colors != null && Colors.Length > 0) {  		float colorTime = time * (Colors.Length - 1);  		float min = Mathf.Floor (colorTime);  		float max = Mathf.Clamp (Mathf.Ceil (colorTime)' 1' Colors.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' colorTime);  		if (min >= Colors.Length)  			min = Colors.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Colors.Length)  			max = Colors.Length - 1;  		if (max < 0)  			max = 0;  		color = Color.Lerp (Colors [(int)min]' Colors [(int)max]' lerp);  	}  	float size = 1f;  	if (Sizes != null && Sizes.Length > 0) {  		float sizeTime = time * (Sizes.Length - 1);  		float min = Mathf.Floor (sizeTime);  		float max = Mathf.Clamp (Mathf.Ceil (sizeTime)' 1' Sizes.Length - 1);  		float lerp = Mathf.InverseLerp (min' max' sizeTime);  		if (min >= Sizes.Length)  			min = Sizes.Length - 1;  		if (min < 0)  			min = 0;  		if (max >= Sizes.Length)  			max = Sizes.Length - 1;  		if (max < 0)  			max = 0;  		size = Mathf.Lerp (Sizes [(int)min]' Sizes [(int)max]' lerp);  	}  	Vector3 perpendicular = Vector3.up;  	//Vector3.Cross(lineDirection' vectorToCamera).normalized;  	newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  	newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  	newColors [i * 2] = newColors [(i * 2) + 1] = color;  	newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  	newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  	if (i > 0 && !((Point)points [i - 1]).LineBreak) {  		if (HigherQualityUVs)  			curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  		else  			curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  		newTriangles [(i - 1) * 6] = (i * 2) - 2;  		newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  		newTriangles [((i - 1) * 6) + 2] = i * 2;  		newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  		newTriangles [((i - 1) * 6) + 4] = i * 2;  		newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  	}  	i++;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newVertices [i * 2] = p.Position + (perpendicular * (size * 0.5f));  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newVertices [(i * 2) + 1] = p.Position + (-perpendicular * (size * 0.5f));  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newColors [i * 2] = newColors [(i * 2) + 1] = color;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newColors [i * 2] = newColors [(i * 2) + 1] = color;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newUV [i * 2] = new Vector2 (curDistance * UvLengthScale' 0);  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newUV [(i * 2) + 1] = new Vector2 (curDistance * UvLengthScale' 1);  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: if (i > 0 && !((Point)points [i - 1]).LineBreak) {  	if (HigherQualityUVs)  		curDistance += (p.Position - ((Point)points [i - 1]).Position).magnitude;  	else  		curDistance += (p.Position - ((Point)points [i - 1]).Position).sqrMagnitude;  	newTriangles [(i - 1) * 6] = (i * 2) - 2;  	newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  	newTriangles [((i - 1) * 6) + 2] = i * 2;  	newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  	newTriangles [((i - 1) * 6) + 4] = i * 2;  	newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  }  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [(i - 1) * 6] = (i * 2) - 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [(i - 1) * 6] = (i * 2) - 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [(i - 1) * 6] = (i * 2) - 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 1] = (i * 2) - 1;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 2] = i * 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 2] = i * 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 2] = i * 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 3] = (i * 2) + 1;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 4] = i * 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 4] = i * 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 4] = i * 2;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  
Magic Number,Assets.Plugins,TimedTrailRenderer,C:\repos\nightwolfz_Game1\Assets\Plugins\TimedTrailRenderer.cs,Update,The following statement contains a magic number: newTriangles [((i - 1) * 6) + 5] = (i * 2) - 1;  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (emit) {  	if (pointCnt == 0) {  		points [pointCnt++] = new Point (transform);  		points [pointCnt++] = new Point (transform);  	}  	if (pointCnt == 1)  		insertPoint ();  	bool add = false;  	float sqrDistance = (points [1].position - transform.position).sqrMagnitude;  	if (sqrDistance > minVertexDistance * minVertexDistance) {  		if (sqrDistance > maxVertexDistance * maxVertexDistance)  			add = true;  		else if (Quaternion.Angle (transform.rotation' points [1].rotation) > maxAngle)  			add = true;  	}  	if (add) {  		if (pointCnt == points.Length)  			System.Array.Resize (ref points' points.Length + 50);  		insertPoint ();  	}  	if (!add)  		points [0].update (transform);  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (add) {  	if (pointCnt == points.Length)  		System.Array.Resize (ref points' points.Length + 50);  	insertPoint ();  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (pointCnt == points.Length)  	System.Array.Resize (ref points' points.Length + 50);  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: System.Array.Resize (ref points' points.Length + 50);  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (pointCnt < 2) {  	trailObj.renderer.enabled = false;  	return;  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: meshColors = new Color[pointCnt * 2];  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: for (int i = 0; i < pointCnt; i++) {  	Point point = points [i];  	float ratio = point.timeAlive * lifeTimeRatio;  	// Color  	Color color;  	if (Colors.Length == 0)  		color = Color.Lerp (Color.white' Color.clear' ratio);  	else if (Colors.Length == 1)  		color = Color.Lerp (Colors [0]' Color.clear' ratio);  	else if (Colors.Length == 2)  		color = Color.Lerp (Colors [0]' Colors [1]' ratio);  	else {  		float colorRatio = ratio * (Colors.Length - 1);  		int min = (int)Mathf.Floor (colorRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  		color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  	}  	meshColors [i * 2] = color;  	meshColors [(i * 2) + 1] = color;  	// Width  	float width;  	if (Widths.Length == 0)  		width = 1;  	else if (Widths.Length == 1)  		width = Widths [0];  	else if (Widths.Length == 2)  		width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  	else {  		float widthRatio = ratio * (Widths.Length - 1);  		int min = (int)Mathf.Floor (widthRatio);  		float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  		width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  	}  	trailObj.transform.position = point.position;  	trailObj.transform.rotation = point.rotation;  	vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  	vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  	// UVs  	float uvRatio;  	uvRatio = (point.timeAlive - points [0].timeAlive) * uvMultiplier;  	uvs [i * 2] = new Vector2 (uvRatio' 0);  	uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  	if (i > 0) {  		// Triangles  		int triIndex = (i - 1) * 6;  		int vertIndex = i * 2;  		triangles [triIndex + 0] = vertIndex - 2;  		triangles [triIndex + 1] = vertIndex - 1;  		triangles [triIndex + 2] = vertIndex - 0;  		triangles [triIndex + 3] = vertIndex + 1;  		triangles [triIndex + 4] = vertIndex + 0;  		triangles [triIndex + 5] = vertIndex - 1;  	}  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (Colors.Length == 0)  	color = Color.Lerp (Color.white' Color.clear' ratio);  else if (Colors.Length == 1)  	color = Color.Lerp (Colors [0]' Color.clear' ratio);  else if (Colors.Length == 2)  	color = Color.Lerp (Colors [0]' Colors [1]' ratio);  else {  	float colorRatio = ratio * (Colors.Length - 1);  	int min = (int)Mathf.Floor (colorRatio);  	float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  	color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (Colors.Length == 1)  	color = Color.Lerp (Colors [0]' Color.clear' ratio);  else if (Colors.Length == 2)  	color = Color.Lerp (Colors [0]' Colors [1]' ratio);  else {  	float colorRatio = ratio * (Colors.Length - 1);  	int min = (int)Mathf.Floor (colorRatio);  	float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  	color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (Colors.Length == 2)  	color = Color.Lerp (Colors [0]' Colors [1]' ratio);  else {  	float colorRatio = ratio * (Colors.Length - 1);  	int min = (int)Mathf.Floor (colorRatio);  	float lerp = Mathf.InverseLerp (min' min + 1' colorRatio);  	color = Color.Lerp (Colors [min]' Colors [min + 1]' lerp);  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: meshColors [i * 2] = color;  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: meshColors [(i * 2) + 1] = color;  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (Widths.Length == 0)  	width = 1;  else if (Widths.Length == 1)  	width = Widths [0];  else if (Widths.Length == 2)  	width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  else {  	float widthRatio = ratio * (Widths.Length - 1);  	int min = (int)Mathf.Floor (widthRatio);  	float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  	width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (Widths.Length == 1)  	width = Widths [0];  else if (Widths.Length == 2)  	width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  else {  	float widthRatio = ratio * (Widths.Length - 1);  	int min = (int)Mathf.Floor (widthRatio);  	float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  	width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (Widths.Length == 2)  	width = Mathf.Lerp (Widths [0]' Widths [1]' ratio);  else {  	float widthRatio = ratio * (Widths.Length - 1);  	int min = (int)Mathf.Floor (widthRatio);  	float lerp = Mathf.InverseLerp (min' min + 1' widthRatio);  	width = Mathf.Lerp (Widths [min]' Widths [min + 1]' lerp);  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: vertices [i * 2] = trailObj.transform.TransformPoint (0' width * 0.5f' 0);  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: vertices [(i * 2) + 1] = trailObj.transform.TransformPoint (0' -width * 0.5f' 0);  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: uvs [i * 2] = new Vector2 (uvRatio' 0);  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: uvs [(i * 2) + 1] = new Vector2 (uvRatio' 1);  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (i > 0) {  	// Triangles  	int triIndex = (i - 1) * 6;  	int vertIndex = i * 2;  	triangles [triIndex + 0] = vertIndex - 2;  	triangles [triIndex + 1] = vertIndex - 1;  	triangles [triIndex + 2] = vertIndex - 0;  	triangles [triIndex + 3] = vertIndex + 1;  	triangles [triIndex + 4] = vertIndex + 0;  	triangles [triIndex + 5] = vertIndex - 1;  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (i > 0) {  	// Triangles  	int triIndex = (i - 1) * 6;  	int vertIndex = i * 2;  	triangles [triIndex + 0] = vertIndex - 2;  	triangles [triIndex + 1] = vertIndex - 1;  	triangles [triIndex + 2] = vertIndex - 0;  	triangles [triIndex + 3] = vertIndex + 1;  	triangles [triIndex + 4] = vertIndex + 0;  	triangles [triIndex + 5] = vertIndex - 1;  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (i > 0) {  	// Triangles  	int triIndex = (i - 1) * 6;  	int vertIndex = i * 2;  	triangles [triIndex + 0] = vertIndex - 2;  	triangles [triIndex + 1] = vertIndex - 1;  	triangles [triIndex + 2] = vertIndex - 0;  	triangles [triIndex + 3] = vertIndex + 1;  	triangles [triIndex + 4] = vertIndex + 0;  	triangles [triIndex + 5] = vertIndex - 1;  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (i > 0) {  	// Triangles  	int triIndex = (i - 1) * 6;  	int vertIndex = i * 2;  	triangles [triIndex + 0] = vertIndex - 2;  	triangles [triIndex + 1] = vertIndex - 1;  	triangles [triIndex + 2] = vertIndex - 0;  	triangles [triIndex + 3] = vertIndex + 1;  	triangles [triIndex + 4] = vertIndex + 0;  	triangles [triIndex + 5] = vertIndex - 1;  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (i > 0) {  	// Triangles  	int triIndex = (i - 1) * 6;  	int vertIndex = i * 2;  	triangles [triIndex + 0] = vertIndex - 2;  	triangles [triIndex + 1] = vertIndex - 1;  	triangles [triIndex + 2] = vertIndex - 0;  	triangles [triIndex + 3] = vertIndex + 1;  	triangles [triIndex + 4] = vertIndex + 0;  	triangles [triIndex + 5] = vertIndex - 1;  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (i > 0) {  	// Triangles  	int triIndex = (i - 1) * 6;  	int vertIndex = i * 2;  	triangles [triIndex + 0] = vertIndex - 2;  	triangles [triIndex + 1] = vertIndex - 1;  	triangles [triIndex + 2] = vertIndex - 0;  	triangles [triIndex + 3] = vertIndex + 1;  	triangles [triIndex + 4] = vertIndex + 0;  	triangles [triIndex + 5] = vertIndex - 1;  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: if (i > 0) {  	// Triangles  	int triIndex = (i - 1) * 6;  	int vertIndex = i * 2;  	triangles [triIndex + 0] = vertIndex - 2;  	triangles [triIndex + 1] = vertIndex - 1;  	triangles [triIndex + 2] = vertIndex - 0;  	triangles [triIndex + 3] = vertIndex + 1;  	triangles [triIndex + 4] = vertIndex + 0;  	triangles [triIndex + 5] = vertIndex - 1;  }  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: triangles [triIndex + 0] = vertIndex - 2;  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: triangles [triIndex + 2] = vertIndex - 0;  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: triangles [triIndex + 3] = vertIndex + 1;  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: triangles [triIndex + 4] = vertIndex + 0;  
Magic Number,Assets.Plugins,Trail,C:\repos\nightwolfz_Game1\Assets\Plugins\Trail.cs,Update,The following statement contains a magic number: triangles [triIndex + 5] = vertIndex - 1;  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: while (i < aJSON.Length) {  	switch (aJSON [i]) {  	case '{':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		stack.Push (new JSONClass ());  		if (ctx != null) {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (stack.Peek ());  			else if (TokenName != "")  				ctx.Add (TokenName' stack.Peek ());  		}  		TokenName = "";  		Token = "";  		ctx = stack.Peek ();  		break;  	case '[':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		stack.Push (new JSONArray ());  		if (ctx != null) {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (stack.Peek ());  			else if (TokenName != "")  				ctx.Add (TokenName' stack.Peek ());  		}  		TokenName = "";  		Token = "";  		ctx = stack.Peek ();  		break;  	case '}':  	case ']':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		if (stack.Count == 0)  			throw new Exception ("JSON Parse: Too many closing brackets");  		stack.Pop ();  		if (Token != "") {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (Token);  			else if (TokenName != "")  				ctx.Add (TokenName' Token);  		}  		TokenName = "";  		Token = "";  		if (stack.Count > 0)  			ctx = stack.Peek ();  		break;  	case ':':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		TokenName = Token;  		Token = "";  		break;  	case '"':  		QuoteMode ^= true;  		break;  	case ''':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		if (Token != "") {  			if (ctx is JSONArray)  				ctx.Add (Token);  			else if (TokenName != "")  				ctx.Add (TokenName' Token);  		}  		TokenName = "";  		Token = "";  		break;  	case '\r':  	case '\n':  		break;  	case ' ':  	case '\t':  		if (QuoteMode)  			Token += aJSON [i];  		break;  	case '\\':  		++i;  		if (QuoteMode) {  			char C = aJSON [i];  			switch (C) {  			case 't':  				Token += '\t';  				break;  			case 'r':  				Token += '\r';  				break;  			case 'n':  				Token += '\n';  				break;  			case 'b':  				Token += '\b';  				break;  			case 'f':  				Token += '\f';  				break;  			case 'u': {  				string s = aJSON.Substring (i + 1' 4);  				Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  				i += 4;  				break;  			}  			default:  				Token += C;  				break;  			}  		}  		break;  	default:  		Token += aJSON [i];  		break;  	}  	++i;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: while (i < aJSON.Length) {  	switch (aJSON [i]) {  	case '{':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		stack.Push (new JSONClass ());  		if (ctx != null) {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (stack.Peek ());  			else if (TokenName != "")  				ctx.Add (TokenName' stack.Peek ());  		}  		TokenName = "";  		Token = "";  		ctx = stack.Peek ();  		break;  	case '[':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		stack.Push (new JSONArray ());  		if (ctx != null) {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (stack.Peek ());  			else if (TokenName != "")  				ctx.Add (TokenName' stack.Peek ());  		}  		TokenName = "";  		Token = "";  		ctx = stack.Peek ();  		break;  	case '}':  	case ']':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		if (stack.Count == 0)  			throw new Exception ("JSON Parse: Too many closing brackets");  		stack.Pop ();  		if (Token != "") {  			TokenName = TokenName.Trim ();  			if (ctx is JSONArray)  				ctx.Add (Token);  			else if (TokenName != "")  				ctx.Add (TokenName' Token);  		}  		TokenName = "";  		Token = "";  		if (stack.Count > 0)  			ctx = stack.Peek ();  		break;  	case ':':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		TokenName = Token;  		Token = "";  		break;  	case '"':  		QuoteMode ^= true;  		break;  	case ''':  		if (QuoteMode) {  			Token += aJSON [i];  			break;  		}  		if (Token != "") {  			if (ctx is JSONArray)  				ctx.Add (Token);  			else if (TokenName != "")  				ctx.Add (TokenName' Token);  		}  		TokenName = "";  		Token = "";  		break;  	case '\r':  	case '\n':  		break;  	case ' ':  	case '\t':  		if (QuoteMode)  			Token += aJSON [i];  		break;  	case '\\':  		++i;  		if (QuoteMode) {  			char C = aJSON [i];  			switch (C) {  			case 't':  				Token += '\t';  				break;  			case 'r':  				Token += '\r';  				break;  			case 'n':  				Token += '\n';  				break;  			case 'b':  				Token += '\b';  				break;  			case 'f':  				Token += '\f';  				break;  			case 'u': {  				string s = aJSON.Substring (i + 1' 4);  				Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  				i += 4;  				break;  			}  			default:  				Token += C;  				break;  			}  		}  		break;  	default:  		Token += aJSON [i];  		break;  	}  	++i;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: switch (aJSON [i]) {  case '{':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	stack.Push (new JSONClass ());  	if (ctx != null) {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (stack.Peek ());  		else if (TokenName != "")  			ctx.Add (TokenName' stack.Peek ());  	}  	TokenName = "";  	Token = "";  	ctx = stack.Peek ();  	break;  case '[':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	stack.Push (new JSONArray ());  	if (ctx != null) {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (stack.Peek ());  		else if (TokenName != "")  			ctx.Add (TokenName' stack.Peek ());  	}  	TokenName = "";  	Token = "";  	ctx = stack.Peek ();  	break;  case '}':  case ']':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	if (stack.Count == 0)  		throw new Exception ("JSON Parse: Too many closing brackets");  	stack.Pop ();  	if (Token != "") {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (Token);  		else if (TokenName != "")  			ctx.Add (TokenName' Token);  	}  	TokenName = "";  	Token = "";  	if (stack.Count > 0)  		ctx = stack.Peek ();  	break;  case ':':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	TokenName = Token;  	Token = "";  	break;  case '"':  	QuoteMode ^= true;  	break;  case ''':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	if (Token != "") {  		if (ctx is JSONArray)  			ctx.Add (Token);  		else if (TokenName != "")  			ctx.Add (TokenName' Token);  	}  	TokenName = "";  	Token = "";  	break;  case '\r':  case '\n':  	break;  case ' ':  case '\t':  	if (QuoteMode)  		Token += aJSON [i];  	break;  case '\\':  	++i;  	if (QuoteMode) {  		char C = aJSON [i];  		switch (C) {  		case 't':  			Token += '\t';  			break;  		case 'r':  			Token += '\r';  			break;  		case 'n':  			Token += '\n';  			break;  		case 'b':  			Token += '\b';  			break;  		case 'f':  			Token += '\f';  			break;  		case 'u': {  			string s = aJSON.Substring (i + 1' 4);  			Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  			i += 4;  			break;  		}  		default:  			Token += C;  			break;  		}  	}  	break;  default:  	Token += aJSON [i];  	break;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: switch (aJSON [i]) {  case '{':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	stack.Push (new JSONClass ());  	if (ctx != null) {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (stack.Peek ());  		else if (TokenName != "")  			ctx.Add (TokenName' stack.Peek ());  	}  	TokenName = "";  	Token = "";  	ctx = stack.Peek ();  	break;  case '[':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	stack.Push (new JSONArray ());  	if (ctx != null) {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (stack.Peek ());  		else if (TokenName != "")  			ctx.Add (TokenName' stack.Peek ());  	}  	TokenName = "";  	Token = "";  	ctx = stack.Peek ();  	break;  case '}':  case ']':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	if (stack.Count == 0)  		throw new Exception ("JSON Parse: Too many closing brackets");  	stack.Pop ();  	if (Token != "") {  		TokenName = TokenName.Trim ();  		if (ctx is JSONArray)  			ctx.Add (Token);  		else if (TokenName != "")  			ctx.Add (TokenName' Token);  	}  	TokenName = "";  	Token = "";  	if (stack.Count > 0)  		ctx = stack.Peek ();  	break;  case ':':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	TokenName = Token;  	Token = "";  	break;  case '"':  	QuoteMode ^= true;  	break;  case ''':  	if (QuoteMode) {  		Token += aJSON [i];  		break;  	}  	if (Token != "") {  		if (ctx is JSONArray)  			ctx.Add (Token);  		else if (TokenName != "")  			ctx.Add (TokenName' Token);  	}  	TokenName = "";  	Token = "";  	break;  case '\r':  case '\n':  	break;  case ' ':  case '\t':  	if (QuoteMode)  		Token += aJSON [i];  	break;  case '\\':  	++i;  	if (QuoteMode) {  		char C = aJSON [i];  		switch (C) {  		case 't':  			Token += '\t';  			break;  		case 'r':  			Token += '\r';  			break;  		case 'n':  			Token += '\n';  			break;  		case 'b':  			Token += '\b';  			break;  		case 'f':  			Token += '\f';  			break;  		case 'u': {  			string s = aJSON.Substring (i + 1' 4);  			Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  			i += 4;  			break;  		}  		default:  			Token += C;  			break;  		}  	}  	break;  default:  	Token += aJSON [i];  	break;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: if (QuoteMode) {  	char C = aJSON [i];  	switch (C) {  	case 't':  		Token += '\t';  		break;  	case 'r':  		Token += '\r';  		break;  	case 'n':  		Token += '\n';  		break;  	case 'b':  		Token += '\b';  		break;  	case 'f':  		Token += '\f';  		break;  	case 'u': {  		string s = aJSON.Substring (i + 1' 4);  		Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  		i += 4;  		break;  	}  	default:  		Token += C;  		break;  	}  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: if (QuoteMode) {  	char C = aJSON [i];  	switch (C) {  	case 't':  		Token += '\t';  		break;  	case 'r':  		Token += '\r';  		break;  	case 'n':  		Token += '\n';  		break;  	case 'b':  		Token += '\b';  		break;  	case 'f':  		Token += '\f';  		break;  	case 'u': {  		string s = aJSON.Substring (i + 1' 4);  		Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  		i += 4;  		break;  	}  	default:  		Token += C;  		break;  	}  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: switch (C) {  case 't':  	Token += '\t';  	break;  case 'r':  	Token += '\r';  	break;  case 'n':  	Token += '\n';  	break;  case 'b':  	Token += '\b';  	break;  case 'f':  	Token += '\f';  	break;  case 'u': {  	string s = aJSON.Substring (i + 1' 4);  	Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  	i += 4;  	break;  }  default:  	Token += C;  	break;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: switch (C) {  case 't':  	Token += '\t';  	break;  case 'r':  	Token += '\r';  	break;  case 'n':  	Token += '\n';  	break;  case 'b':  	Token += '\b';  	break;  case 'f':  	Token += '\f';  	break;  case 'u': {  	string s = aJSON.Substring (i + 1' 4);  	Token += (char)int.Parse (s' System.Globalization.NumberStyles.AllowHexSpecifier);  	i += 4;  	break;  }  default:  	Token += C;  	break;  }  
Magic Number,SimpleJSON,JSONNode,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,Parse,The following statement contains a magic number: i += 4;  
Magic Number,SimpleJSON,JSONArray,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,ToString,The following statement contains a magic number: foreach (JSONNode N in m_List) {  	if (result.Length > 2)  		result += "' ";  	result += N.ToString ();  }  
Magic Number,SimpleJSON,JSONArray,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,ToString,The following statement contains a magic number: if (result.Length > 2)  	result += "' ";  
Magic Number,SimpleJSON,JSONArray,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,ToString,The following statement contains a magic number: foreach (JSONNode N in m_List) {  	if (result.Length > 3)  		result += "' ";  	result += "\n" + aPrefix + "   ";  	result += N.ToString (aPrefix + "   ");  }  
Magic Number,SimpleJSON,JSONArray,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,ToString,The following statement contains a magic number: if (result.Length > 3)  	result += "' ";  
Magic Number,SimpleJSON,JSONClass,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,ToString,The following statement contains a magic number: foreach (KeyValuePair<string' JSONNode> N in m_Dict) {  	if (result.Length > 2)  		result += "' ";  	result += "\"" + Escape (N.Key) + "\":" + N.Value.ToString ();  }  
Magic Number,SimpleJSON,JSONClass,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,ToString,The following statement contains a magic number: if (result.Length > 2)  	result += "' ";  
Magic Number,SimpleJSON,JSONClass,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,ToString,The following statement contains a magic number: foreach (KeyValuePair<string' JSONNode> N in m_Dict) {  	if (result.Length > 3)  		result += "' ";  	result += "\n" + aPrefix + "   ";  	result += "\"" + Escape (N.Key) + "\" : " + N.Value.ToString (aPrefix + "   ");  }  
Magic Number,SimpleJSON,JSONClass,C:\repos\nightwolfz_Game1\Assets\Plugins\SimpleJSON.cs,ToString,The following statement contains a magic number: if (result.Length > 3)  	result += "' ";  
