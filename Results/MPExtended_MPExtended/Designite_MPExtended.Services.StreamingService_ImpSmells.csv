Implementation smell,Namespace,Class,File,Method,Description
Long Method,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The method has 190 lines of code.
Long Method,MPExtended.Services.StreamingService.MediaInfo,MediaInfoWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfoWrapper.cs,LoadMediaInfo,The method has 121 lines of code.
Complex Method,MPExtended.Services.StreamingService.Code,ImageMediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\ImageMediaSource.cs,GetFileInfo,Cyclomatic complexity of the method is 8
Complex Method,MPExtended.Services.StreamingService.Code,Pipeline,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Pipeline.cs,Assemble,Cyclomatic complexity of the method is 14
Complex Method,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,Cyclomatic complexity of the method is 9
Complex Method,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,Cyclomatic complexity of the method is 8
Long Parameter List,MPExtended.Services.StreamingService.Code,ImageMediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\ImageMediaSource.cs,ImageMediaSource,The method has 5 parameters. Parameters: type' provider' id' filetype' offset
Long Parameter List,MPExtended.Services.StreamingService.Code,Downloads,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Downloads.cs,Download,The method has 5 parameters. Parameters: clientDescription' type' provider' itemId' position
Long Parameter List,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ExtractImage,The method has 6 parameters. Parameters: source' position' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,GetResizedImage,The method has 5 parameters. Parameters: src' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,CacheImage,The method has 5 parameters. Parameters: src' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,StreamPostprocessedImage,The method has 5 parameters. Parameters: src' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ProcessAndCacheImage,The method has 5 parameters. Parameters: src' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService.Code,MediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaSource.cs,MediaSource,The method has 5 parameters. Parameters: type' provider' id' filetype' offset
Long Parameter List,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,StartStream,The method has 5 parameters. Parameters: identifier' profile' position' audioId' subtitleId
Long Parameter List,MPExtended.Services.StreamingService.Code,Resolution,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Resolution.cs,Calculate,The method has 5 parameters. Parameters: sourceWidth' sourceHeight' maxWidth' maxHeight' framesizeMultipleOff
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetStreamSize,The method has 5 parameters. Parameters: type' provider' itemId' offset' profile
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetItemHash,The method has 5 parameters. Parameters: type' provider' itemId' offset' smartHash
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,InitStream,The method has 7 parameters. Parameters: type' provider' itemId' offset' clientDescription' identifier' idleTimeout
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,StartStreamWithStreamSelection,The method has 5 parameters. Parameters: identifier' profileName' startPosition' audioId' subtitleId
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetMediaItem,The method has 5 parameters. Parameters: clientDescription' type' provider' itemId' startPosition
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,DoStream,The method has 7 parameters. Parameters: type' provider' itemId' clientDescription' profileName' startPosition' idleTimeout
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,ExtractImage,The method has 5 parameters. Parameters: type' provider' itemId' position' format
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,ExtractImageResized,The method has 8 parameters. Parameters: type' provider' itemId' position' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetImageResized,The method has 7 parameters. Parameters: type' provider' id' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetArtwork,The method has 6 parameters. Parameters: mediatype' provider' id' artworktype' offset' format
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetArtworkResized,The method has 9 parameters. Parameters: mediatype' provider' id' artworktype' offset' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,RequestImageResize,The method has 9 parameters. Parameters: mediatype' provider' id' imagetype' offset' maxWidth' maxHeight' borders' format
Long Parameter List,MPExtended.Services.StreamingService.MediaInfo,MediaInfo,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfo.cs,MediaInfo_GetI,The method has 5 parameters. Parameters: Handle' StreamKind' StreamNumber' Parameter' KindOfInfo
Long Parameter List,MPExtended.Services.StreamingService.MediaInfo,MediaInfo,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfo.cs,MediaInfo_Get,The method has 6 parameters. Parameters: Handle' StreamKind' StreamNumber' Parameter' KindOfInfo' KindOfSearch
Long Parameter List,MPExtended.Services.StreamingService.MediaInfo,MediaInfo,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfo.cs,Get,The method has 5 parameters. Parameters: StreamKind' StreamNumber' Parameter' KindOfInfo' KindOfSearch
Long Parameter List,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The method has 5 parameters. Parameters: options' tsOptions' disableSeeking' encoderOptions' muxerOptions
Long Parameter List,MPExtended.Services.StreamingService.Transcoders,VLCWrapperHTTPLiveStreaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCWrapperHTTPLiveStreaming.cs,GenerateVLCParameters,The method has 5 parameters. Parameters: options' tsOptions' disableSeeking' encoderOptions' muxerOptions
Long Parameter List,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,EncoderUnit,The method has 6 parameters. Parameters: transcoder' arguments' inputMethod' outputMethod' logStream' context
Long Parameter List,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The method has 6 parameters. Parameters: outputStream' saveData' startPosition' logMessages' logProgress' identifier
Long Parameter List,MPExtended.Services.StreamingService.Units,VLCManagedEncoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCManagedEncoder.cs,VLCManagedEncoder,The method has 5 parameters. Parameters: sout' arguments' context' inputMethod' input
Long Statement,MPExtended.Services.StreamingService.Code,ImageMediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\ImageMediaSource.cs,IsCustomized,The length of the statement  "            return path != null || ((MediaType == WebMediaType.TV || MediaType == WebMediaType.Recording) && FileType == WebFileType.Logo); " is 127.
Long Statement,MPExtended.Services.StreamingService.Code,ImageMediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\ImageMediaSource.cs,GetFileInfo,The length of the statement  "            if ((MediaType == WebMediaType.TV || MediaType == WebMediaType.Recording || MediaType == WebMediaType.Radio) && FileType == WebFileType.Logo) " is 141.
Long Statement,MPExtended.Services.StreamingService.Code,Downloads,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Downloads.cs,Download,The length of the statement  "            context.ClientIP = realIp == null ? WCFUtil.GetClientIPAddress() : String.Format("{0} (via {1})"' realIp' WCFUtil.GetClientIPAddress()); " is 136.
Long Statement,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ExtractImage,The length of the statement  "                        return StreamPostprocessedImage(new ImageMediaSource(thumbnailFileInfo.FullName)' maxWidth' maxHeight' borders' format); " is 120.
Long Statement,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ExecuteFFMpegExtraction,The length of the statement  "            info.Arguments = String.Format("-ss {0} -i \"{1}\" -vframes 1 -vf \"yadif'scale=ih*dar:ih\" -f image2 \"{2}\""' position' path' tempFile); " is 138.
Long Statement,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ExecuteFFMpegExtraction,The length of the statement  "                proc.StartAsUser(Configuration.Services.NetworkImpersonation.Domain' Configuration.Services.NetworkImpersonation.Username' Configuration.Services.NetworkImpersonation.GetPassword()); " is 182.
Long Statement,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ProcessAndCacheImage,The length of the statement  "            string filename = String.Format("stream_{0}_{1}_{2}_{3}.{4}"' src.GetUniqueIdentifier()' maxWidth' maxHeight' borders' format); " is 127.
Long Statement,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ResizeImage,The length of the statement  "                bool addBorders = !String.IsNullOrEmpty(borders) && borders != "stretch" && newImageSize.AspectRatio != (double)maxWidth / maxHeight; " is 133.
Long Statement,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ResizeImage,The length of the statement  "                        graphic.FillRectangle(new SolidBrush(ColorTranslator.FromHtml("#" + borders))' 0' 0' bitmapSize.Width' bitmapSize.Height); " is 122.
Long Statement,MPExtended.Services.StreamingService.Code,MediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaSource.cs,GetPath,The length of the statement  "            return MediaType == WebMediaType.TV && FileType == WebFileType.Content ? PathUtil.StripFileProtocolPrefix(Id) : GetFileInfo().Path; " is 131.
Long Statement,MPExtended.Services.StreamingService.Code,MediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaSource.cs,GetDebugName,The length of the statement  "            return String.Format("mediatype={0} provider={1} id={2} filetype={3} offset={4} path={5}"' MediaType' Provider' Id' FileType' Offset' path); " is 140.
Long Statement,MPExtended.Services.StreamingService.Code,Pipeline,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Pipeline.cs,Assemble,The length of the statement  "            // connect the output of the last one as that's usually captured by the calling app (because else the whole pipeline is just useless) " is 133.
Long Statement,MPExtended.Services.StreamingService.Code,Pipeline,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Pipeline.cs,Assemble,The length of the statement  "                StreamLog.Info(identifier' "   data {0}: {1} (input {2}' data {3}' log {4})"' i' dataUnits[i].ToString()' dataUnits[i].IsInputStreamConnected' dataUnits[i].IsDataStreamConnected' dataUnits[i].IsLogStreamConnected); " is 214.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,TimeoutStreamsTick,The length of the statement  "                            StreamLog.Info(key' "Stream had last read {0} milliseconds ago (read {1} bytes in total) and last service activity at {2}' so cancel it"'  " is 137.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,InitStream,The length of the statement  "            // Some clients such as WebMP proxy the streams before relying it to the client. We should give these clients the option to " is 123.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,InitStream,The length of the statement  "            // forward the real IP address' so that we can show that one in the configurator too. However' to avoid abuse' we should show " is 125.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,InitStream,The length of the statement  "            stream.ClientIP = realIp == null ? WCFUtil.GetClientIPAddress() : String.Format("{0} (via {1})"' realIp' WCFUtil.GetClientIPAddress()); " is 135.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,StartStream,The length of the statement  "            // there's a theoretical race condition here between the insert in InitStream() and this' but the client should really' really " is 126.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,StartStream,The length of the statement  "                    Reference<WebTranscodingInfo> infoRef = new Reference<WebTranscodingInfo>(() => stream.Context.TranscodingInfo' x => { stream.Context.TranscodingInfo = x; }); " is 158.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,StartStream,The length of the statement  "                            stream.Context.SubtitleTrackId = stream.Context.MediaInfo.SubtitleStreams.First(x => x.Language == preferredLanguage).ID; " is 121.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,StartStream,The length of the statement  "                    StreamLog.Debug(identifier' "Final stream selection: audioId={0}' subtitleId={1}"' stream.Context.AudioTrackId' stream.Context.SubtitleTrackId); " is 144.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,EndStream,The length of the statement  "            if (!Streams.ContainsKey(identifier) || Streams[identifier] == null || Streams[identifier].Context.Pipeline == null || !Streams[identifier].Context.Pipeline.IsStarted) " is 167.
Long Statement,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,CalculateSize,The length of the statement  "                    var res = Resolution.Calculate(info.VideoStreams.First().DisplayAspectRatio' profile.MaxOutputWidth' profile.MaxOutputHeight' 2); " is 129.
Long Statement,MPExtended.Services.StreamingService.Code,StreamLog,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\StreamLog.cs,WriteLogHeader,The length of the statement  "            streamLogs[streamIdentifier].FullLog.AppendFormat("{0:HH:mm:ss.fffff} {1'5}: "' DateTime.Now' Enum.GetName(typeof(LogLevel)' level).ToUpperInvariant()); " is 152.
Long Statement,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,StartStream,The length of the statement  "                    state.Runtime = Connections.MAS.GetTVShowDetailedById(context.Source.Provider' ((WebTVEpisodeDetailed)state.MediaDescriptor).ShowId).Runtime * 60000; " is 149.
Long Statement,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,EndStream,The length of the statement  "                        // Stop the timers. Do this before sending the FinishEpisode() events as we could get a race condition with the service otherwise. " is 130.
Long Statement,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,TimerElapsed,The length of the statement  "                    wst.CanceledWaitIterations = wst.CanceledWaitIterations == -1 ? KEEP_ONLINE_ALIVE_CYCLES : wst.CanceledWaitIterations - 1; " is 122.
Long Statement,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,TimerElapsed,The length of the statement  "                            CallForEpisode(wst.Identifier' (show' season' episode) => wst.Service.WatchingEpisode(show' season' episode' CalculateWatchPosition(wst.Identifier))); " is 150.
Long Statement,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,TimerElapsed,The length of the statement  "                            wst.Service.WatchingMovie((WebMovieDetailed)streams[wst.Identifier].MediaDescriptor' CalculateWatchPosition(wst.Identifier)); " is 125.
Long Statement,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,CalculateWatchPosition,The length of the statement  "            Log.Debug("WatchSharing: watch position {0}ms' runtime {1}ms' progress {2}%"' watchPosition' streams[id].Runtime' progress); " is 124.
Long Statement,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,GetStreamURL,The length of the statement  "            return WCFUtil.GetCurrentRoot() + "StreamingService/stream/CustomTranscoderData?identifier=" + Identifier + "&action=playlist&parameters=index.m3u8"; " is 149.
Long Statement,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,ProvideCustomActionFile,The length of the statement  "                    // Having CRLF instead of LF in the playlist is allowed by the spec' but causes problems for VLC during playback' so strip them. " is 128.
Long Statement,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,RemoveOldSegments,The length of the statement  "            if (!Int32.TryParse(currentRequest.Replace(".ts"' "")' out currentSegmentNumber) || currentSegmentNumber - keepSegments <= 0) " is 125.
Long Statement,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,RemoveOldSegments,The length of the statement  "                StreamLog.Trace(Identifier' "HTTPLiveStreamer: Remove old segment {0} during request for {1}"' filename' currentRequest); " is 121.
Long Statement,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,Write,The length of the statement  "                // Sometimes we are still writing to the input named pipe while we already have killed the transcoder' or the transcoder has already " is 132.
Long Statement,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,Write,The length of the statement  "                // finished and we didn't detect that yet. This is no problem as the stream should stop in both cases' and writing is stopped a few lines " is 137.
Long Statement,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,Start,The length of the statement  "                NamedPipeClientStream client = new NamedPipeClientStream("."' _pipeName' PipeDirection.InOut' PipeOptions.Asynchronous); " is 120.
Long Statement,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,Start,The length of the statement  "                pipeSecurity.SetAccessRule(new PipeAccessRule(new SecurityIdentifier(WellKnownSidType.WorldSid' null)' PipeAccessRights.ReadWrite' AccessControlType.Allow));  " is 157.
Long Statement,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,Start,The length of the statement  "                NamedPipeServerStream server = new NamedPipeServerStream(_pipeName' PipeDirection.InOut' 1' PipeTransmissionMode.Byte' PipeOptions.Asynchronous' 4096' 4096' pipeSecurity); " is 171.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,Seek,The length of the statement  "            long minPosition = tsWriterPosition + Convert.ToInt64(tsWriterPosition * .01);                      // tsWriterPosition + a extra 1% of the file so the writer doesn't get ahead of us. " is 183.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,Seek,The length of the statement  "            long maxPosition = tsFiles.Where(o => o != tsFiles.Last()).Sum(o => o.Length) + tsWriterPosition;   // Full length of all the previous TS files + the tsWriters current position. " is 177.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,Seek,The length of the statement  "                    long positionInFile = tsReaderPosition - (lengthTotal - tsFiles[i].Length); // Current Pos - (total length - last file length) " is 126.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The length of the statement  "            //Int64 currentPosition = 0; // Using tsWriterPosition instead since this is a waste' left here to help explain the .tsBuffer file. " is 131.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The length of the statement  "                        Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long))); " is 197.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The length of the statement  "                    System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long))); " is 179.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The length of the statement  "                    Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32); " is 134.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The length of the statement  "                        Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved); " is 131.
Long Statement,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The length of the statement  "                String[] files = new String(Encoding.Default.GetChars(correctedFileList)).Split(new char[] { '\0' }' StringSplitOptions.RemoveEmptyEntries); " is 140.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetStreamSize,The length of the statement  "                    // WebMP requests the default stream size with an empty name. This shouldn't flood the logs with warnings as people misinterpret them' " is 134.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetStreamSize,The length of the statement  "                    return _stream.CalculateSize(Configuration.StreamingProfiles.GetTranscoderProfileByName(profile)' MediaInfoHelper.DEFAULT_ASPECT_RATIO).ToWebResolution(); " is 154.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetStreamSize,The length of the statement  "            return _stream.CalculateSize(Configuration.StreamingProfiles.GetTranscoderProfileByName(profile)' new MediaSource(type' provider' itemId' offset)).ToWebResolution(); " is 165.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetItemHash,The length of the statement  "            return new WebMediaHash() { Generated = true' Hash = smartHash ? source.ComputeSmartHash() : source.ComputeFullHash() }; " is 120.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,InitStream,The length of the statement  "            StreamLog.Info(identifier' "Called InitStream with type={0}; provider={1}; itemId={2}; offset={3}; clientDescription={4}; idleTimeout={5}"'  " is 139.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,InitStream,The length of the statement  "            return _stream.InitStream(identifier' clientDescription' new MediaSource(type' provider' itemId' offset)' idleTimeout.HasValue ? idleTimeout.Value : 5 * 60); " is 157.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,StartStream,The length of the statement  "            return _stream.StartStream(identifier' Configuration.StreamingProfiles.GetTranscoderProfileByName(profileName)' startPosition * 1000); " is 134.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,StartStreamWithStreamSelection,The length of the statement  "            StreamLog.Debug(identifier' "Called StartStreamWithStreamSelection with profile={0}; start={1}; audioId={2}; subtitleId={3}"' " is 125.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,StartStreamWithStreamSelection,The length of the statement  "            return _stream.StartStream(identifier' Configuration.StreamingProfiles.GetTranscoderProfileByName(profileName)' startPosition * 1000' audioId' subtitleId); " is 155.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,DoStream,The length of the statement  "            // This only works with profiles that actually return something in the RetrieveStream method (i.e. no RTSP or CustomTranscoderData) " is 131.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,ExtractImageResized,The length of the statement  "            return Images.ExtractImage(new MediaSource(type' provider' itemId)' position' calcMaxWidth' calcMaxHeight' borders' format); " is 124.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetImageResized,The length of the statement  "            return Images.GetResizedImage(new ImageMediaSource(type' provider' id' WebFileType.Content' 0)' calcMaxWidth' calcMaxHeight' borders' format); " is 142.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetArtworkResized,The length of the statement  "            return Images.GetResizedImage(new ImageMediaSource(mediatype' provider' id' artworktype' offset)' calcMaxWidth' calcMaxHeight' borders' format); " is 144.
Long Statement,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,RequestImageResize,The length of the statement  "            return Images.CacheImage(new ImageMediaSource(mediatype' provider' id' imagetype' offset)' calcMaxWidth' calcMaxHeight' borders' format); " is 137.
Long Statement,MPExtended.Services.StreamingService.MediaInfo,XmlCache,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\XmlCache.cs,SaveToDisk,The length of the statement  "            // This happens during uninstallation: the Cache directory is already removed' but the service isn't stopped yet. To avoid " is 122.
Long Statement,MPExtended.Services.StreamingService.MediaInfo,MediaInfoWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfoWrapper.cs,GetMediaInfo,The length of the statement  "                Log.Debug("Using path {0} from TS buffer {1} as source for {2}"' tsBuffer.GetCurrentFilePath()' source.Id' source.GetDebugName()); " is 130.
Long Statement,MPExtended.Services.StreamingService.MediaInfo,MediaInfoWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfoWrapper.cs,LoadMediaInfo,The length of the statement  "                 * Using the whole wrapper from MediaPortal is quite much porting work as it's cluttered with calls to other MP code. Referencing " is 128.
Long Statement,MPExtended.Services.StreamingService.MediaInfo,MediaInfoWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfoWrapper.cs,LoadMediaInfo,The length of the statement  "                    retinfo.Duration = retinfo.Duration == 0 ? (long)StringToInt(info.Get(StreamKind.Video' i' "Duration")) : retinfo.Duration; " is 123.
Long Statement,MPExtended.Services.StreamingService.MediaInfo,MediaInfoWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfoWrapper.cs,LoadMediaInfo,The length of the statement  "                    retinfo.Duration = retinfo.Duration == 0 ? (long)StringToInt(info.Get(StreamKind.Audio' i' "Duration")) : retinfo.Duration; " is 123.
Long Statement,MPExtended.Services.StreamingService.MediaInfo,MediaInfoWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfoWrapper.cs,LoadMediaInfo,The length of the statement  "                    foreach (string file in Directory.EnumerateFiles(Path.GetDirectoryName(source)' Path.GetFileNameWithoutExtension(source) + ".*.srt")) " is 133.
Long Statement,MPExtended.Services.StreamingService.Transcoders,FFMpegHTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpegHTTPLiveStreamer.cs,ProvideCustomActionFile,The length of the statement  "                    StreamLog.Warn(Identifier' "HTTPLiveStreamer: Client requested index.m3u8 that doesn't exist for identifier '{0}'"' Identifier); " is 128.
Long Statement,MPExtended.Services.StreamingService.Transcoders,FFMpegHTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpegHTTPLiveStreamer.cs,ReplacePathsWithURLs,The length of the statement  "                        // Ensure that segment path has been completely written so it is correctly replaced and we don't expose system paths to web " is 123.
Long Statement,MPExtended.Services.StreamingService.Transcoders,Generic,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\Generic.cs,BuildPipeline,The length of the statement  "            EncoderUnit.TransportMethod input = Context.NeedsInputReaderUnit ? EncoderUnit.TransportMethod.NamedPipe : EncoderUnit.TransportMethod.Other; " is 141.
Long Statement,MPExtended.Services.StreamingService.Transcoders,Generic,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\Generic.cs,BuildPipeline,The length of the statement  "            EncoderUnit unit = new EncoderUnit(program' arguments' input' EncoderUnit.TransportMethod.NamedPipe' EncoderUnit.LogStream.None' Context); " is 138.
Long Statement,MPExtended.Services.StreamingService.Transcoders,Direct,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\Direct.cs,RetrieveStreamCalled,The length of the statement  "            object mime = RegistryReader.ReadKey(Microsoft.Win32.RegistryHive.ClassesRoot' Path.GetExtension(Context.Source.GetFileInfo().Name)' "Content Type"); " is 149.
Long Statement,MPExtended.Services.StreamingService.Transcoders,FFMpeg,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpeg.cs,BuildPipeline,The length of the statement  "            EncoderUnit.TransportMethod input = doInputReader ? EncoderUnit.TransportMethod.NamedPipe : EncoderUnit.TransportMethod.Other; " is 126.
Long Statement,MPExtended.Services.StreamingService.Transcoders,FFMpeg,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpeg.cs,BuildPipeline,The length of the statement  "            EncoderUnit unit = new EncoderUnit(Configuration.StreamingProfiles.FFMpegPath' arguments' input' ReadOutputStream ? EncoderUnit.TransportMethod.NamedPipe : EncoderUnit.TransportMethod.Other' EncoderUnit.LogStream.StandardError' Context); " is 237.
Long Statement,MPExtended.Services.StreamingService.Transcoders,FFMpeg,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpeg.cs,GenerateArguments,The length of the statement  "                mappings = String.Format("-map v:0 -map a:{0}"' Context.MediaInfo.AudioStreams.First(x => x.ID == Context.AudioTrackId).Index); " is 127.
Long Statement,MPExtended.Services.StreamingService.Transcoders,FFMpeg,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpeg.cs,GenerateArguments,The length of the statement  "            bool doResize = !Context.Profile.TranscoderParameters.ContainsKey("noResize") || Context.Profile.TranscoderParameters["noResize"] != "yes"; " is 139.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLC,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLC.cs,AddEncoderToPipeline,The length of the statement  "            EncoderUnit.TransportMethod input = hasInputReader ? EncoderUnit.TransportMethod.NamedPipe : EncoderUnit.TransportMethod.Other; " is 127.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLC,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLC.cs,AddEncoderToPipeline,The length of the statement  "            EncoderUnit.TransportMethod outputMethod = ReadOutputStream ? EncoderUnit.TransportMethod.NamedPipe : EncoderUnit.TransportMethod.Other; " is 136.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLC,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLC.cs,AddEncoderToPipeline,The length of the statement  "            // waiting for output pipe is meaningless for VLC as it opens it way earlier then that it actually writes to it. Instead' log parsing " is 133.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLC,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLC.cs,AddEncoderToPipeline,The length of the statement  "            EncoderUnit unit = new EncoderUnit(Context.Profile.TranscoderParameters["path"]' arguments' input' outputMethod' log' Context); " is 127.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GetStreamURL,The length of the statement  "            if (Context.Profile.TranscoderParameters.ContainsKey("rtspOutput") && Context.Profile.TranscoderParameters["rtspOutput"] == "yes") " is 130.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,BuildPipeline,The length of the statement  "            if (Context.Profile.TranscoderParameters.ContainsKey("flvMetadataInjection") && Context.Profile.TranscoderParameters["flvMetadataInjection"] == "yes") " is 150.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The length of the statement  "            if (Context.Profile.TranscoderParameters.ContainsKey("rtspOutput") && Context.Profile.TranscoderParameters["rtspOutput"] == "yes") " is 130.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The length of the statement  "                Context.Profile.TranscoderParameters.ContainsKey("options") ? Context.Profile.TranscoderParameters["options"] : String.Empty' " is 125.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The length of the statement  "                Context.Profile.TranscoderParameters.ContainsKey("tsOptions") ? Context.Profile.TranscoderParameters["tsOptions"] : String.Empty' " is 129.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The length of the statement  "                Context.Profile.TranscoderParameters.ContainsKey("disableSeeking") && Context.Profile.TranscoderParameters["disableSeeking"] == "yes"' " is 134.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The length of the statement  "                Context.Profile.TranscoderParameters.ContainsKey("encoder") ? Context.Profile.TranscoderParameters["encoder"] : String.Empty' " is 125.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The length of the statement  "            // position (disabling this is probably a bad idea as some things (watch sharing' transcoding info) fail then' which results in faulty clients.) " is 144.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The length of the statement  "                arguments.Add("--audio-track=" + Context.MediaInfo.AudioStreams.Where(x => x.ID == Context.AudioTrackId).First().Index); " is 120.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The length of the statement  "				if (!Context.Profile.TranscoderParameters.ContainsKey("noResize") || Context.Profile.TranscoderParameters["noResize"] != "yes") " is 127.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCHTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCHTTPLiveStreamer.cs,GetFullMuxerString,The length of the statement  "             * :standard{access=livehttp{seglen=10'delsegs=false'numsegs=0'index=C:\dir\index.m3u8'index-url=http://ip/###.ts}'mux=ts{use-key-frames}'dst=C:\dir\###.ts} " is 155.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCHTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCHTTPLiveStreamer.cs,GetFullMuxerString,The length of the statement  "            string indexUrl = WCFUtil.GetCurrentRoot() + "StreamingService/stream/CustomTranscoderData?identifier=" + Identifier + "&action=segment&parameters=######.ts"; " is 158.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCHTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCHTTPLiveStreamer.cs,GetFullMuxerString,The length of the statement  "            string liveHttpOptions = Context.Profile.TranscoderParameters["httpLiveOptions"] + "'index=" + Path.Combine(TemporaryDirectory' "index.m3u8") + "'index-url=" + indexUrl; " is 169.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCHTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCHTTPLiveStreamer.cs,GetFullMuxerString,The length of the statement  "            return ":standard{access=livehttp{" + liveHttpOptions + "}'mux=" + Context.Profile.TranscoderParameters["muxer"] + "'dst=" + destination + "}"; " is 143.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCManaged,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCManaged.cs,AddEncoderToPipeline,The length of the statement  "                unit = new VLCManagedEncoder(vlcparam.Sout' vlcparam.Arguments' Context' VLCManagedEncoder.InputMethod.File' Context.Source.GetPath()); " is 135.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCManaged,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCManaged.cs,SetupAssemblyLoader,The length of the statement  "            // MPExtended.Libraries.VLCManaged.dll is in the vlc-1.1.xx directory. We should load it from there so that it can properly find libvlc " is 135.
Long Statement,MPExtended.Services.StreamingService.Transcoders,VLCWrapperHTTPLiveStreaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCWrapperHTTPLiveStreaming.cs,GenerateVLCParameters,The length of the statement  "            return base.GenerateVLCParameters(options' tsOptions' disableSeeking' encoderOptions' httpLiveStreamer.GetFullMuxerString()); " is 125.
Long Statement,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Stop,The length of the statement  "            // do not abort the injection here - it automatically stops as it's input stream ends' and it only makes things more complicated in the implementation " is 150.
Long Statement,MPExtended.Services.StreamingService.Units,HTTPLiveStreamUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\HTTPLiveStreamUnit.cs,Stop,The length of the statement  "                    Log.Warn("Failed to delete HTTP Live Streaming directory. Either your PC is horribly slow or a 0.001% chance of collision happened."' ex); " is 138.
Long Statement,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,Setup,The length of the statement  "            if (!DebugOutput && logStream == LogStream.StandardOut && IsLogStreamConnected && outputMethod != TransportMethod.StandardOut) " is 126.
Long Statement,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,SpawnTranscoder,The length of the statement  "            start.RedirectStandardOutput = needsStdout || (!DebugOutput && logStream == LogStream.StandardOut && IsLogStreamConnected); " is 123.
Long Statement,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,SpawnTranscoder,The length of the statement  "            StreamLog.Info(context.Identifier' "Encoder:   hasStdin {0}' hasStdout {1}' hasStderr {2}"' start.RedirectStandardInput' start.RedirectStandardOutput' start.RedirectStandardError); " is 180.
Long Statement,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,SpawnTranscoder,The length of the statement  "                    transcoderApplication.StartAsUser(Configuration.Services.NetworkImpersonation.Domain' Configuration.Services.NetworkImpersonation.Username' Configuration.Services.NetworkImpersonation.GetPassword()); " is 199.
Long Statement,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,Start,The length of the statement  "                StreamLog.Info(context.Identifier' "Encoding: Copy stream of type {0} into transcoder input stream of type {1}"' InputStream.ToString()' transcoderInputStream.ToString()); " is 171.
Long Statement,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,Start,The length of the statement  "            if (DataOutputStream is NamedPipe && (outputMethod == TransportMethod.NamedPipe || outputMethod == TransportMethod.StandardOut)) " is 128.
Long Statement,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,Start,The length of the statement  "                    StreamLog.Warn(context.Identifier' "Encoding: Aborting wait because transcoder application failed and will never setup output named pipe."); " is 140.
Long Statement,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The length of the statement  "                        Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase); " is 192.
Long Statement,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The length of the statement  "                                saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000; " is 162.
Long Statement,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The length of the statement  "                                saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture)); " is 136.
Long Statement,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The length of the statement  "                        Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase); " is 149.
Long Statement,MPExtended.Services.StreamingService.Units,VLCManagedEncoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCManagedEncoder.cs,Start,The length of the statement  "                StreamLog.Info(context.Identifier' "VLCManagedEncoder: Copy stream of type {0} into transcoder input pipe"' InputStream.ToString()); " is 132.
Long Statement,MPExtended.Services.StreamingService.Units,VLCManagedEncoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCManagedEncoder.cs,Start,The length of the statement  "            infoReference = new Reference<WebTranscodingInfo>(() => context.TranscodingInfo' x => { context.TranscodingInfo = x; }); " is 120.
Long Statement,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The length of the statement  "            TranscodingInfoCalculator calculator = new TranscodingInfoCalculator(position' 25' 500' info.Duration); //VLCWrapper prints twice a second " is 138.
Long Statement,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The length of the statement  "                            // Starting with VLCWrapper 0.2' the output format has changed. It is 'P [time in milliseconds]' now' which is quite easy for " is 125.
Long Statement,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The length of the statement  "                            // us to handle. With VLC 2 it also returns the time as a 64-bit integer' so we don't have overflow anymore either' but that risk " is 129.
Long Statement,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The length of the statement  "                // The double try-catch is to make sure that the parsing doesn't stop when it can't process a single line' but that we don't " is 124.
Long Statement,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The length of the statement  "                // log too much noise when a ThreadAbortException occurs while in the ReadLine() method. Funnily enough' this exception is " is 122.
Complex Conditional,MPExtended.Services.StreamingService.Code,ImageMediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\ImageMediaSource.cs,GetFileInfo,The conditional expression  "(MediaType == WebMediaType.TV || MediaType == WebMediaType.Recording || MediaType == WebMediaType.Radio) && FileType == WebFileType.Logo"  is complex.
Complex Conditional,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,EndStream,The conditional expression  "!Streams.ContainsKey(identifier) || Streams[identifier] == null || Streams[identifier].Context.Pipeline == null || !Streams[identifier].Context.Pipeline.IsStarted"  is complex.
Complex Conditional,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,Setup,The conditional expression  "!DebugOutput && logStream == LogStream.StandardOut && IsLogStreamConnected && outputMethod != TransportMethod.StandardOut"  is complex.
Complex Conditional,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The conditional expression  "line.StartsWith("A") || line.StartsWith("I") || line == "S started" || line == "S null""  is complex.
Virtual Method Call from Constructor,MPExtended.Services.StreamingService.Code,MediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaSource.cs,MediaSource,The constructor "MediaSource" calls a virtual method "CheckArguments".
Empty Catch Block,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,Setup,The method has an empty catch block.
Empty Catch Block,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,Setup,The method has an empty catch block.
Magic Number,MPExtended.Services.StreamingService.Code,Downloads,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Downloads.cs,GetActiveSessions,The following statement contains a magic number: return runningDownloads                  .Where(context => context.Stream.TimeSinceLastRead < IDLE_TIMEOUT)                  .Select(context => {                      double percentage = context.Source.MediaType == WebMediaType.TV ? 0.0 :                                                   1.0 * context.Stream.ReadBytes / context.Source.GetFileInfo().Size;                      return new WebStreamingSession()                      {                          ClientDescription = String.IsNullOrEmpty(context.ClientDescription) ? "Download" : context.ClientDescription'                          ClientIPAddress = context.ClientIP'                          DisplayName = context.Source.GetMediaDisplayName()'                          Identifier = String.Empty'                          PercentageProgress = (int)Math.Round(percentage * 100.0)'                          PlayerPosition = (int)Math.Round(percentage * context.MediaInfo.Duration)'                          Profile = "Download"'                          SourceId = context.Source.Id'                          SourceType = context.Source.MediaType'                          StartPosition = 0'                          StartTime = context.StartTime'                          TranscodingInfo = null                      };                  });
Magic Number,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ResizeImage,The following statement contains a magic number: using (var origImage = Image.FromStream(stream))              {                  // newImageSize is the size of the actual graphic' which might not be the size of the canvas (bitmap). Unless                  // we're instructed to stretch the image' it's a proportional resize of the source graphic. Borders will be                  // added when we're instructed to and the aspect ratio of the image isn't equal to the aspect ratio of the                   // bitmap.                  Resolution newImageSize = borders != "stretch" ?                       Resolution.Calculate(origImage.Width' origImage.Height' maxWidth' maxHeight' 1) :                      Resolution.Create(maxWidth.Value' maxHeight.Value);                  bool addBorders = !String.IsNullOrEmpty(borders) && borders != "stretch" && newImageSize.AspectRatio != (double)maxWidth / maxHeight;                    Resolution bitmapSize = addBorders ? Resolution.Create(maxWidth.Value' maxHeight.Value) : newImageSize;                  Bitmap newImage = new Bitmap(bitmapSize.Width' bitmapSize.Height' PixelFormat.Format32bppArgb);                  using (Graphics graphic = Graphics.FromImage(newImage))                  {                      graphic.InterpolationMode = InterpolationMode.HighQualityBicubic;                      graphic.SmoothingMode = SmoothingMode.HighQuality;                      graphic.CompositingQuality = CompositingQuality.HighQuality;                      graphic.CompositingMode = CompositingMode.SourceCopy;                      graphic.PixelOffsetMode = PixelOffsetMode.HighQuality;                        if (addBorders && borders != "transparent")                          graphic.FillRectangle(new SolidBrush(ColorTranslator.FromHtml("#" + borders))' 0' 0' bitmapSize.Width' bitmapSize.Height);                        // We center the graphic in the canvas. If we should stretch the image' newImageSize is equal to the canvas' so                       // the graphic is pasted at the top-left corner' which is fine.                      int leftOffset = (bitmapSize.Width - newImageSize.Width) / 2;                      int heightOffset = (bitmapSize.Height - newImageSize.Height) / 2;                      graphic.DrawImage(origImage' leftOffset' heightOffset' newImageSize.Width' newImageSize.Height);                  }                    return newImage;              }
Magic Number,MPExtended.Services.StreamingService.Code,Images,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Images.cs,ResizeImage,The following statement contains a magic number: using (var origImage = Image.FromStream(stream))              {                  // newImageSize is the size of the actual graphic' which might not be the size of the canvas (bitmap). Unless                  // we're instructed to stretch the image' it's a proportional resize of the source graphic. Borders will be                  // added when we're instructed to and the aspect ratio of the image isn't equal to the aspect ratio of the                   // bitmap.                  Resolution newImageSize = borders != "stretch" ?                       Resolution.Calculate(origImage.Width' origImage.Height' maxWidth' maxHeight' 1) :                      Resolution.Create(maxWidth.Value' maxHeight.Value);                  bool addBorders = !String.IsNullOrEmpty(borders) && borders != "stretch" && newImageSize.AspectRatio != (double)maxWidth / maxHeight;                    Resolution bitmapSize = addBorders ? Resolution.Create(maxWidth.Value' maxHeight.Value) : newImageSize;                  Bitmap newImage = new Bitmap(bitmapSize.Width' bitmapSize.Height' PixelFormat.Format32bppArgb);                  using (Graphics graphic = Graphics.FromImage(newImage))                  {                      graphic.InterpolationMode = InterpolationMode.HighQualityBicubic;                      graphic.SmoothingMode = SmoothingMode.HighQuality;                      graphic.CompositingQuality = CompositingQuality.HighQuality;                      graphic.CompositingMode = CompositingMode.SourceCopy;                      graphic.PixelOffsetMode = PixelOffsetMode.HighQuality;                        if (addBorders && borders != "transparent")                          graphic.FillRectangle(new SolidBrush(ColorTranslator.FromHtml("#" + borders))' 0' 0' bitmapSize.Width' bitmapSize.Height);                        // We center the graphic in the canvas. If we should stretch the image' newImageSize is equal to the canvas' so                       // the graphic is pasted at the top-left corner' which is fine.                      int leftOffset = (bitmapSize.Width - newImageSize.Width) / 2;                      int heightOffset = (bitmapSize.Height - newImageSize.Height) / 2;                      graphic.DrawImage(origImage' leftOffset' heightOffset' newImageSize.Width' newImageSize.Height);                  }                    return newImage;              }
Magic Number,MPExtended.Services.StreamingService.Code,MediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaSource.cs,ComputeSmartHash,The following statement contains a magic number: try              {                  using (Stream input = Retrieve())                  {                      long streamsize = input.Length;                      ulong lhash = (ulong)streamsize;                        long i = 0;                      byte[] buffer = new byte[sizeof(long)];                      input.Position = 0;                      while (i < 65536 / sizeof(long) && (input.Read(buffer' 0' sizeof(long)) > 0))                      {                          i++;                          unchecked { lhash += BitConverter.ToUInt64(buffer' 0); }                      }                        input.Position = Math.Max(0' streamsize - 65536);                      i = 0;                      while (i < 65536 / sizeof(long) && (input.Read(buffer' 0' sizeof(long)) > 0))                      {                          i++;                          unchecked { lhash += BitConverter.ToUInt64(buffer' 0); }                      }                        return BitConverter.GetBytes(lhash).ToHexString();                  }              }              catch (Exception e)              {                  Log.Warn("Error computing smart hash"' e);                  return null;              }
Magic Number,MPExtended.Services.StreamingService.Code,MediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaSource.cs,ComputeSmartHash,The following statement contains a magic number: try              {                  using (Stream input = Retrieve())                  {                      long streamsize = input.Length;                      ulong lhash = (ulong)streamsize;                        long i = 0;                      byte[] buffer = new byte[sizeof(long)];                      input.Position = 0;                      while (i < 65536 / sizeof(long) && (input.Read(buffer' 0' sizeof(long)) > 0))                      {                          i++;                          unchecked { lhash += BitConverter.ToUInt64(buffer' 0); }                      }                        input.Position = Math.Max(0' streamsize - 65536);                      i = 0;                      while (i < 65536 / sizeof(long) && (input.Read(buffer' 0' sizeof(long)) > 0))                      {                          i++;                          unchecked { lhash += BitConverter.ToUInt64(buffer' 0); }                      }                        return BitConverter.GetBytes(lhash).ToHexString();                  }              }              catch (Exception e)              {                  Log.Warn("Error computing smart hash"' e);                  return null;              }
Magic Number,MPExtended.Services.StreamingService.Code,MediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaSource.cs,ComputeSmartHash,The following statement contains a magic number: try              {                  using (Stream input = Retrieve())                  {                      long streamsize = input.Length;                      ulong lhash = (ulong)streamsize;                        long i = 0;                      byte[] buffer = new byte[sizeof(long)];                      input.Position = 0;                      while (i < 65536 / sizeof(long) && (input.Read(buffer' 0' sizeof(long)) > 0))                      {                          i++;                          unchecked { lhash += BitConverter.ToUInt64(buffer' 0); }                      }                        input.Position = Math.Max(0' streamsize - 65536);                      i = 0;                      while (i < 65536 / sizeof(long) && (input.Read(buffer' 0' sizeof(long)) > 0))                      {                          i++;                          unchecked { lhash += BitConverter.ToUInt64(buffer' 0); }                      }                        return BitConverter.GetBytes(lhash).ToHexString();                  }              }              catch (Exception e)              {                  Log.Warn("Error computing smart hash"' e);                  return null;              }
Magic Number,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,Streaming,The following statement contains a magic number: timeoutTimer = new Timer()              {                  AutoReset = true'                  Interval = 1000'              };
Magic Number,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,TimeoutStreamsTick,The following statement contains a magic number: try              {                  var toDelete = Streams                      .Where(x =>                          (x.Value.UseActivityForTimeout ||                                  (x.Value.OutputStream != null && x.Value.OutputStream.TimeSinceLastRead > (x.Value.Timeout * 1000))) &&                          (x.Value.LastActivity.Add(TimeSpan.FromSeconds(x.Value.Timeout)) < DateTime.Now)                      )                      .Select(x => x.Value.Identifier)                      .ToList();                    if (toDelete.Count > 0)                  {                      foreach (string key in toDelete)                      {                          // The stream could've been terminated between the moment we decide it should be terminated and we get here.                           if (!Streams.ContainsKey(key))                              continue;                            if (Streams[key].UseActivityForTimeout)                          {                              StreamLog.Info(key' "Stream had last service activity at {0}' so cancel it"' Streams[key].LastActivity);                          }                          else                          {                              StreamLog.Info(key' "Stream had last read {0} milliseconds ago (read {1} bytes in total) and last service activity at {2}' so cancel it"'                                   Streams[key].OutputStream.TimeSinceLastRead' Streams[key].OutputStream.ReadBytes' Streams[key].LastActivity);                          }                          service.FinishStream(key);                      }                  }              }              catch (Exception ex)              {                  Log.Warn("Error in TimeoutStreamsTick"' ex);              }
Magic Number,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,GetStreamingSessions,The following statement contains a magic number: return Streams.Select(s => s.Value).Select(s => new WebStreamingSession()              {                  ClientDescription = s.ClientDescription'                  ClientIPAddress = s.ClientIP'                  Identifier = s.Identifier'                  SourceType = s.Context.Source.MediaType'                  SourceId = s.Context.Source.Id'                  Profile = s.Context.Profile != null ? s.Context.Profile.Name : null'                  StartTime = s.StartTime'                  DisplayName = s.Context.Source.GetMediaDisplayName()'                    StartPosition = s.Context.StartPosition'                  PlayerPosition = s.Context.GetPlayerPosition()'                  PercentageProgress = s.Context.MediaInfo == null ? 0 :                                          (int)Math.Round(100.0 * s.Context.GetPlayerPosition() / s.Context.MediaInfo.Duration)'                  TranscodingInfo = s.Context.TranscodingInfo != null ? s.Context.TranscodingInfo : null'              }).ToList();
Magic Number,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,CalculateSize,The following statement contains a magic number: return Resolution.Calculate(displayAspectRatio' profile.MaxOutputWidth' profile.MaxOutputHeight' 2);
Magic Number,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,CalculateSize,The following statement contains a magic number: try              {                  if (!profile.HasVideoStream)                      return new Resolution(0' 0);                    if (info == null)                  {                      info = MediaInfoHelper.LoadMediaInfoOrSurrogate(source);                  }                    if (info.VideoStreams.Count > 0)                  {                      var res = Resolution.Calculate(info.VideoStreams.First().DisplayAspectRatio' profile.MaxOutputWidth' profile.MaxOutputHeight' 2);                      if (res.Width == 0 && res.Height == 0)                          return new Resolution(info.VideoStreams.First().Width' info.VideoStreams.First().Height);                      return res;                  }              }              catch (Exception ex)              {                  Log.Warn("Failed to calculate size of output stream"' ex);              }
Magic Number,MPExtended.Services.StreamingService.Code,Streaming,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\Streaming.cs,CalculateSize,The following statement contains a magic number: return Resolution.Calculate(MediaInfoHelper.DEFAULT_ASPECT_RATIO' profile.MaxOutputWidth' profile.MaxOutputHeight' 2);
Magic Number,MPExtended.Services.StreamingService.Code,TranscodingInfoCalculator,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TranscodingInfoCalculator.cs,NewTime,The following statement contains a magic number: if (fpsCalculatorCounter++ % fpsCount == 0)              {                  calculatedFPS = ((newTime - lastCountPosition) / (1000 / FPS)) / (FPS_SAMPLING_RATE / 1000);                  lastCountPosition = newTime;              }
Magic Number,MPExtended.Services.StreamingService.Code,TranscodingInfoCalculator,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TranscodingInfoCalculator.cs,NewTime,The following statement contains a magic number: if (fpsCalculatorCounter++ % fpsCount == 0)              {                  calculatedFPS = ((newTime - lastCountPosition) / (1000 / FPS)) / (FPS_SAMPLING_RATE / 1000);                  lastCountPosition = newTime;              }
Magic Number,MPExtended.Services.StreamingService.Code,TranscodingInfoCalculator,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TranscodingInfoCalculator.cs,SaveStats,The following statement contains a magic number: lock (output.Value)              {                  output.Value.Supported = hasValidData;                  output.Value.TranscodedTime = (transcodingPositionInFile - StartPosition);                  output.Value.TranscodedFrames = (transcodingPositionInFile - StartPosition) / (1000 / FPS);                  output.Value.TranscodingPosition = transcodingPositionInFile;                  output.Value.TranscodingFPS = calculatedFPS;              }
Magic Number,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,StartStream,The following statement contains a magic number: if (!streams.ContainsKey(identifier))              {                  StreamState state = new StreamState()                  {                      Id = identifier'                      Context = context'                      TranscodingInfo = infoRef'                      Canceled = false'                      Stale = false                  };                    // get mediadescriptor and rough runtime                  Log.Debug("WatchSharing: synchronizing start watching event to service");                  if (context.Source.MediaType == WebMediaType.TVEpisode)                  {                      state.MediaDescriptor = Connections.MAS.GetTVEpisodeDetailedById(context.Source.Provider' context.Source.Id);                      state.Runtime = Connections.MAS.GetTVShowDetailedById(context.Source.Provider' ((WebTVEpisodeDetailed)state.MediaDescriptor).ShowId).Runtime * 60000;                  }                  else if (context.Source.MediaType == WebMediaType.Movie)                  {                      state.MediaDescriptor = Connections.MAS.GetMovieDetailedById(context.Source.Provider' context.Source.Id);                      state.Runtime = ((WebMovieDetailed)state.MediaDescriptor).Runtime * 60000;                  }                    // get exact runtime if available                  if (context.MediaInfo.Duration > 60)                  {                      state.Runtime = (int)context.MediaInfo.Duration;                  }                    // send start watching event                  Task.Factory.StartNew(delegate()                  {                      if (state.Context.Source.MediaType == WebMediaType.TVEpisode)                      {                          services.ExecuteForAll(s => CallForEpisode(identifier' s.StartWatchingEpisode));                      }                      else if (state.Context.Source.MediaType == WebMediaType.Movie)                      {                          services.ExecuteForAll(s => s.StartWatchingMovie((WebMovieDetailed)state.MediaDescriptor));                      }                  }).LogOnException();                    // and start the background timer                  streams[identifier] = state;                  state.BackgroundTimers = new List<WatchSharingTimer>();                  foreach (IWatchSharingService service in services)                  {                      var thisTimer = new WatchSharingTimer(identifier' service);                      thisTimer.Elapsed += TimerElapsed;                      thisTimer.Start();                      state.BackgroundTimers.Add(thisTimer);                  }              }              else              {                  // just update the progress which will be send next time                  Log.Info("WatchSharing: Picking up old stream");                  streams[identifier].Canceled = false;                  streams[identifier].Context = context;              }
Magic Number,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,StartStream,The following statement contains a magic number: if (!streams.ContainsKey(identifier))              {                  StreamState state = new StreamState()                  {                      Id = identifier'                      Context = context'                      TranscodingInfo = infoRef'                      Canceled = false'                      Stale = false                  };                    // get mediadescriptor and rough runtime                  Log.Debug("WatchSharing: synchronizing start watching event to service");                  if (context.Source.MediaType == WebMediaType.TVEpisode)                  {                      state.MediaDescriptor = Connections.MAS.GetTVEpisodeDetailedById(context.Source.Provider' context.Source.Id);                      state.Runtime = Connections.MAS.GetTVShowDetailedById(context.Source.Provider' ((WebTVEpisodeDetailed)state.MediaDescriptor).ShowId).Runtime * 60000;                  }                  else if (context.Source.MediaType == WebMediaType.Movie)                  {                      state.MediaDescriptor = Connections.MAS.GetMovieDetailedById(context.Source.Provider' context.Source.Id);                      state.Runtime = ((WebMovieDetailed)state.MediaDescriptor).Runtime * 60000;                  }                    // get exact runtime if available                  if (context.MediaInfo.Duration > 60)                  {                      state.Runtime = (int)context.MediaInfo.Duration;                  }                    // send start watching event                  Task.Factory.StartNew(delegate()                  {                      if (state.Context.Source.MediaType == WebMediaType.TVEpisode)                      {                          services.ExecuteForAll(s => CallForEpisode(identifier' s.StartWatchingEpisode));                      }                      else if (state.Context.Source.MediaType == WebMediaType.Movie)                      {                          services.ExecuteForAll(s => s.StartWatchingMovie((WebMovieDetailed)state.MediaDescriptor));                      }                  }).LogOnException();                    // and start the background timer                  streams[identifier] = state;                  state.BackgroundTimers = new List<WatchSharingTimer>();                  foreach (IWatchSharingService service in services)                  {                      var thisTimer = new WatchSharingTimer(identifier' service);                      thisTimer.Elapsed += TimerElapsed;                      thisTimer.Start();                      state.BackgroundTimers.Add(thisTimer);                  }              }              else              {                  // just update the progress which will be send next time                  Log.Info("WatchSharing: Picking up old stream");                  streams[identifier].Canceled = false;                  streams[identifier].Context = context;              }
Magic Number,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,StartStream,The following statement contains a magic number: if (!streams.ContainsKey(identifier))              {                  StreamState state = new StreamState()                  {                      Id = identifier'                      Context = context'                      TranscodingInfo = infoRef'                      Canceled = false'                      Stale = false                  };                    // get mediadescriptor and rough runtime                  Log.Debug("WatchSharing: synchronizing start watching event to service");                  if (context.Source.MediaType == WebMediaType.TVEpisode)                  {                      state.MediaDescriptor = Connections.MAS.GetTVEpisodeDetailedById(context.Source.Provider' context.Source.Id);                      state.Runtime = Connections.MAS.GetTVShowDetailedById(context.Source.Provider' ((WebTVEpisodeDetailed)state.MediaDescriptor).ShowId).Runtime * 60000;                  }                  else if (context.Source.MediaType == WebMediaType.Movie)                  {                      state.MediaDescriptor = Connections.MAS.GetMovieDetailedById(context.Source.Provider' context.Source.Id);                      state.Runtime = ((WebMovieDetailed)state.MediaDescriptor).Runtime * 60000;                  }                    // get exact runtime if available                  if (context.MediaInfo.Duration > 60)                  {                      state.Runtime = (int)context.MediaInfo.Duration;                  }                    // send start watching event                  Task.Factory.StartNew(delegate()                  {                      if (state.Context.Source.MediaType == WebMediaType.TVEpisode)                      {                          services.ExecuteForAll(s => CallForEpisode(identifier' s.StartWatchingEpisode));                      }                      else if (state.Context.Source.MediaType == WebMediaType.Movie)                      {                          services.ExecuteForAll(s => s.StartWatchingMovie((WebMovieDetailed)state.MediaDescriptor));                      }                  }).LogOnException();                    // and start the background timer                  streams[identifier] = state;                  state.BackgroundTimers = new List<WatchSharingTimer>();                  foreach (IWatchSharingService service in services)                  {                      var thisTimer = new WatchSharingTimer(identifier' service);                      thisTimer.Elapsed += TimerElapsed;                      thisTimer.Start();                      state.BackgroundTimers.Add(thisTimer);                  }              }              else              {                  // just update the progress which will be send next time                  Log.Info("WatchSharing: Picking up old stream");                  streams[identifier].Canceled = false;                  streams[identifier].Context = context;              }
Magic Number,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,EndStream,The following statement contains a magic number: if (streams[identifier].TranscodingInfo != null && streams[identifier].TranscodingInfo.Value != null)              {                  int progress = CalculateWatchPosition(identifier);                  if (progress >= 95)                  {                      Log.Debug("WatchSharing: seeing {0}% as finished for {1}"' progress' identifier);                        // send the finished event in the background thread                      Task.Factory.StartNew(delegate()                      {                          // Stop the timers. Do this before sending the FinishEpisode() events as we could get a race condition with the service otherwise.                          foreach (var timer in streams[identifier].BackgroundTimers)                          {                              timer.Enabled = false;                          }                            // Send the FinishEpisode event                          if (streams[identifier].Context.Source.MediaType == WebMediaType.TVEpisode)                          {                              services.ExecuteForAll(s => CallForEpisode(identifier' s.FinishEpisode));                          }                          else if (streams[identifier].Context.Source.MediaType == WebMediaType.Movie)                          {                              services.ExecuteForAll(s => s.FinishMovie((WebMovieDetailed)streams[identifier].MediaDescriptor));                          }                            // And definitely stop the stream                          streams.Remove(identifier);                          Log.Debug("WatchSharing: finished handling {0}"' identifier);                      }).LogOnException();                      return;                  }              }
Magic Number,MPExtended.Services.StreamingService.Code,WatchSharing,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\WatchSharing.cs,CalculateWatchPosition,The following statement contains a magic number: int progress = (int)Math.Round((watchPosition * 1.0 / streams[id].Runtime) * 100);
Magic Number,MPExtended.Services.StreamingService.Code,MediaInfoHelper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaInfoHelper.cs,LoadMediaInfoOrSurrogate,The following statement contains a magic number: surr.AudioStreams = new List<WebAudioStream>()              {                  new WebAudioStream()                   {                      Channels = 2'                      Codec = "Unknown"'                      ID = 1'                      Index = 0'                      Language = "und"' // yes' that's valid ISO 639 (I think)                      LanguageFull = "Unknown"'                  }              };
Magic Number,MPExtended.Services.StreamingService.Code,MediaInfoHelper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaInfoHelper.cs,LoadMediaInfoOrSurrogate,The following statement contains a magic number: surr.VideoStreams = new List<WebVideoStream>()              {                  new WebVideoStream()                  {                      Codec = "Unknown"'                      DisplayAspectRatio = DEFAULT_ASPECT_RATIO'                       DisplayAspectRatioString = "16:9"'                      ID = 2'                      Index = 0'                      Height = 720'                      Width = 1280                  }              };
Magic Number,MPExtended.Services.StreamingService.Code,MediaInfoHelper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaInfoHelper.cs,LoadMediaInfoOrSurrogate,The following statement contains a magic number: surr.VideoStreams = new List<WebVideoStream>()              {                  new WebVideoStream()                  {                      Codec = "Unknown"'                      DisplayAspectRatio = DEFAULT_ASPECT_RATIO'                       DisplayAspectRatioString = "16:9"'                      ID = 2'                      Index = 0'                      Height = 720'                      Width = 1280                  }              };
Magic Number,MPExtended.Services.StreamingService.Code,MediaInfoHelper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaInfoHelper.cs,LoadMediaInfoOrSurrogate,The following statement contains a magic number: surr.VideoStreams = new List<WebVideoStream>()              {                  new WebVideoStream()                  {                      Codec = "Unknown"'                      DisplayAspectRatio = DEFAULT_ASPECT_RATIO'                       DisplayAspectRatioString = "16:9"'                      ID = 2'                      Index = 0'                      Height = 720'                      Width = 1280                  }              };
Magic Number,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,HTTPLiveStreamer,The following statement contains a magic number: TemporaryDirectory = Path.Combine(Path.GetTempPath()' "MPExtended"' "httplivestreaming-" + identifier + "-" + new Random().Next(100000' 999999));
Magic Number,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,HTTPLiveStreamer,The following statement contains a magic number: TemporaryDirectory = Path.Combine(Path.GetTempPath()' "MPExtended"' "httplivestreaming-" + identifier + "-" + new Random().Next(100000' 999999));
Magic Number,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,AppendPipeline,The following statement contains a magic number: Context.Pipeline.AddDataUnit(new HTTPLiveStreamUnit(indexFile)' 10);
Magic Number,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,StripCarriageReturn,The following statement contains a magic number: try              {                  fileStream = new FileStream(path' FileMode.Open' FileAccess.Read' FileShare.ReadWrite | FileShare.Delete);              }              catch (IOException)              {                  System.Threading.Thread.Sleep(20);                  fileStream = new FileStream(path' FileMode.Open' FileAccess.Read' FileShare.ReadWrite | FileShare.Delete);              }
Magic Number,MPExtended.Services.StreamingService.Code,HTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\HTTPLiveStreamer.cs,RemoveOldSegments,The following statement contains a magic number: string filename = (currentSegmentNumber - keepSegments).ToString().PadLeft(currentRequest.Length - 3' '0') + ".ts";
Magic Number,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,Start,The following statement contains a magic number: if (isClient) {                  NamedPipeClientStream client = new NamedPipeClientStream("."' _pipeName' PipeDirection.InOut' PipeOptions.Asynchronous);                  client.Connect(10000); // 10 second timeout.                    pipe = client;                  isReady = true;              } else {                  // Grant read/write access to everyone' so the pipe can be written to from impersonated processes                  PipeSecurity pipeSecurity = new PipeSecurity();                  pipeSecurity.SetAccessRule(new PipeAccessRule(new SecurityIdentifier(WellKnownSidType.WorldSid' null)' PipeAccessRights.ReadWrite' AccessControlType.Allow));                   NamedPipeServerStream server = new NamedPipeServerStream(_pipeName' PipeDirection.InOut' 1' PipeTransmissionMode.Byte' PipeOptions.Asynchronous' 4096' 4096' pipeSecurity);                  server.BeginWaitForConnection(new AsyncCallback(WaitForConnection)' server);              }
Magic Number,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,Start,The following statement contains a magic number: if (isClient) {                  NamedPipeClientStream client = new NamedPipeClientStream("."' _pipeName' PipeDirection.InOut' PipeOptions.Asynchronous);                  client.Connect(10000); // 10 second timeout.                    pipe = client;                  isReady = true;              } else {                  // Grant read/write access to everyone' so the pipe can be written to from impersonated processes                  PipeSecurity pipeSecurity = new PipeSecurity();                  pipeSecurity.SetAccessRule(new PipeAccessRule(new SecurityIdentifier(WellKnownSidType.WorldSid' null)' PipeAccessRights.ReadWrite' AccessControlType.Allow));                   NamedPipeServerStream server = new NamedPipeServerStream(_pipeName' PipeDirection.InOut' 1' PipeTransmissionMode.Byte' PipeOptions.Asynchronous' 4096' 4096' pipeSecurity);                  server.BeginWaitForConnection(new AsyncCallback(WaitForConnection)' server);              }
Magic Number,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,Start,The following statement contains a magic number: if (isClient) {                  NamedPipeClientStream client = new NamedPipeClientStream("."' _pipeName' PipeDirection.InOut' PipeOptions.Asynchronous);                  client.Connect(10000); // 10 second timeout.                    pipe = client;                  isReady = true;              } else {                  // Grant read/write access to everyone' so the pipe can be written to from impersonated processes                  PipeSecurity pipeSecurity = new PipeSecurity();                  pipeSecurity.SetAccessRule(new PipeAccessRule(new SecurityIdentifier(WellKnownSidType.WorldSid' null)' PipeAccessRights.ReadWrite' AccessControlType.Allow));                   NamedPipeServerStream server = new NamedPipeServerStream(_pipeName' PipeDirection.InOut' 1' PipeTransmissionMode.Byte' PipeOptions.Asynchronous' 4096' 4096' pipeSecurity);                  server.BeginWaitForConnection(new AsyncCallback(WaitForConnection)' server);              }
Magic Number,MPExtended.Services.StreamingService.Code,NamedPipe,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\NamedPipe.cs,WaitTillReady,The following statement contains a magic number: while (!this.IsReady)                  System.Threading.Thread.Sleep(100);
Magic Number,MPExtended.Services.StreamingService.Code,StreamCopy,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\StreamCopy.cs,StartCopy,The following statement contains a magic number: try              {                  source.BeginRead(buffer' 0' buffer.Length' MediaReadAsyncCallback' new object());              }              catch (NotSupportedException e)              {                  // we only diagnose problems with TsBuffer' other streams are supposed to work correctly                  if (!(source is TsBuffer))                      throw;                    // TODO: is this still needed or are the TsBuffer problems solved?                  TsBuffer stream = (TsBuffer)source;                  Log.Error(string.Format("StreamCopy {0}: NotSupportedException when trying to read from TsBuffer"' log)' e);                  Log.Debug("StreamCopy {0}: TsBuffer dump: CanRead {1}' CanWrite {2}"' log' stream.CanRead' stream.CanWrite);                  Log.Debug("StreamCopy {0}:\r\n{1}"' log' stream.DumpStatus());                  if (retry)                  {                      Thread.Sleep(500);                      Log.Info("StreamCopy {0}: Trying to recover"' log);                      StartCopy(false);                  }              }
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,Read,The following statement contains a magic number: try              {                  int tries = 10000;                  do                  {                      try                      {                          // Refresh the .tsBuffer file to update the pointers.                          RefreshTsBuffer();                            // Check if the tsWriter has moved to another file.                          if (tsWriterPosition < tsReaderPosition)                          {                              // Check if there is enough data to fill the buffer.                              if (((tsReader.Length - tsReaderPosition) + tsWriterPosition) > count)                              {                                  // Read the remainder of the file.                                  int bytesToRead = Convert.ToInt32(tsReader.Length - tsReaderPosition);                                  if (bytesToRead > count)                                  {                                      bytesToRead = count;                                  }                                    int byteCount = tsReader.Read(buffer' offset' bytesToRead);                                    // Check if the end of the file has been reached.                                  if (tsReader.Length == tsReaderPosition)                                  {                                      // Change to the next file.                                      ChangeTsFile(tsFiles.FindIndex(o => o == tsReaderFile) + 1);                                        // Check if it changed successfully.                                      if (state == State.Playing)                                      {                                          // Fill the rest of the buffer.                                          byteCount += tsReader.Read(buffer' offset + byteCount' count - byteCount);                                      }                                  }                                  // Increment the current position.                                  tsReaderPosition += byteCount;                                    // Return what we have.                                  return byteCount;                              }                          }                          else                          {                              // Check if there is enough data to fill the buffer.                              if ((tsWriterPosition - tsReaderPosition - count) > count)                              { // Make sure there is a extra packets buffer.                                  // Should be enough data.                                  int byteCount = tsReader.Read(buffer' offset' count);                                    // Increment the current position.                                  tsReaderPosition += byteCount;                                    return byteCount;                              }                          }  #if DEBUG                      }                      catch (Exception e)                      {                          Log.Warn("TsBuffer: Read inner exception: {0}"' e);                      }  #else                      } catch (Exception) { }  #endif                        // This is added because the CPU scans so bloody fast that the loop would be pointless without it.                      // Need to find a better way.                      System.Threading.Thread.Sleep(1);                  } while (--tries != 0);                    return 0;              }              catch (Exception e)              {                  Log.Warn("TsBuffer: Read outer exception: {0}"' e);                  return 0;              }
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,Seek,The following statement contains a magic number: long minPosition = tsWriterPosition + Convert.ToInt64(tsWriterPosition * .01);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: int tries = 10;
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,RefreshTsBuffer,The following statement contains a magic number: do              {                  try                  {                      error = false;                        // Read the latest details about the writer thread.                      // Check if the file size is acceptable.                      if (tsBuffer.Length <= (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)))                      {                          // File size too small to be a valid.                          Log.Error("TsBuffer: Failed to refresh tsBuffer file' length {0} should not be <= {1}"' tsBuffer.Length' (sizeof(Int64) + sizeof(long) + sizeof(long) + sizeof(char) + sizeof(long) + sizeof(long)));                          throw new InvalidDataException("File size is too small.");                      }                        tsBuffer.Position = 0;                        #region Extra DEBUG Output                      // You won't get far with this on but it does help to understand the .tsBuffer file.  #if EXTRA_DEBUG                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine(String.Format(".TsBuffer File: pass {0}"' tries));                      System.Diagnostics.Debug.WriteLine("------------------------");                        System.Diagnostics.Debug.WriteLine(String.Format("Current Pos     : {0}"' tsBuffer.ReadInt64()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Added     : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Remaining Length: {0}"' tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(long) - sizeof(long) - sizeof(long) - sizeof(long)));                        Int64 newRemainingLength = tsBuffer.BaseStream.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                      byte[] filesListed = new byte[newRemainingLength + 1];                      tsBuffer.Read(filesListed' 0' filesListed.Length - 1);                        byte[] fixedList = new byte[filesListed.Length / 2];                      for (int i = 0; i < filesListed.Length / 2; i++)                      {                          fixedList[i] = filesListed[i * 2];                      }                        System.Diagnostics.Debug.Write("Files           : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' Convert.ToString(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.Write("Files Text      : ");                      foreach (Byte item in fixedList)                      {                          System.Diagnostics.Debug.Write(String.Format("{0}"' Convert.ToChar(item)));                      }                      System.Diagnostics.Debug.WriteLine("");                        System.Diagnostics.Debug.WriteLine(String.Format("Files Added 2   : {0}"' tsBuffer.ReadInt32()));                      System.Diagnostics.Debug.WriteLine(String.Format("Files Removed 2 : {0}"' tsBuffer.ReadInt32()));                        System.Diagnostics.Debug.WriteLine("");                      System.Diagnostics.Debug.WriteLine("------------------------");                      System.Diagnostics.Debug.WriteLine("byte by byte.");                      System.Diagnostics.Debug.WriteLine("------------------------");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);                      while (tsBuffer.BaseStream.Position < tsBuffer.BaseStream.Length)                      {                          System.Diagnostics.Debug.Write(String.Format("{0} "' tsBuffer.BaseStream.ReadByte()));                      }                        System.Diagnostics.Debug.WriteLine("");                        tsBuffer.BaseStream.Seek(0' SeekOrigin.Begin);  #endif                      #endregion                        byte[] tsDetails = new byte[16];                      tsBuffer.Read(tsDetails' 0' 16);                        tsWriterPosition = BitConverter.ToInt64(tsDetails' 0);                      filesAdded = BitConverter.ToInt32(tsDetails' 8);                      filesRemoved = BitConverter.ToInt32(tsDetails' 12);                        // If no files added or removed' break the loop !                      if ((tsBufferAdded == filesAdded) && (tsBufferRemoved == filesRemoved))                      {                          break;                      }                        remainingLength = tsBuffer.Length - sizeof(Int64) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32) - sizeof(Int32);                        // Above 100kb or below 0 seems stupid and figure out a problem !!!                      if (remainingLength < 0)                      {                          Log.Error("TsBuffer: We have a remaining length of {0}' which is below zero?"' remainingLength);                          throw new InvalidDataException("File size is too small.");                      }                      else if (remainingLength > 100000)                      {                          Log.Error("TsBuffer: Remaining length is too big: {0}"' remainingLength);                          throw new InvalidDataException("File size is too big.");                      }                        // Load the file list.                      fileList = new byte[remainingLength + 1];                      tsBuffer.Read(fileList' 0' fileList.Length - 1);                        correctedFileList = new byte[(fileList.Length / 2)];                        for (int i = 0; i < fileList.Length / 2; i++)                      {                          correctedFileList[i] = fileList[i * 2];                      }                        // Load the duplicate added / removed values.                      tsDetails = new byte[8];                      tsBuffer.Read(tsDetails' 0' 8);                        filesAdded2 = BitConverter.ToInt32(tsDetails' 0);                      filesRemoved2 = BitConverter.ToInt32(tsDetails' 4);                        // Check if they match.                      if ((filesAdded2 != filesAdded) || (filesRemoved2 != filesRemoved))                      {                          Log.Error("TsBuffer: Read invalid data from file: {0} != {1} || {2} != {3}"' filesAdded2' filesAdded' filesRemoved2' filesRemoved);                          throw new InvalidDataException("Invalid data read from file.");                      }                        tsDetails = null;                        break;                  }                  catch (Exception e)                  {                      Log.Error("TsBuffer: Some exception happened during refreshing the stream buffer"' e);                      error = true;                        // wait 100ms before trying again                      System.Threading.Thread.Sleep(100);                  }              } while (--tries != 0);
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,ChangeTsFile,The following statement contains a magic number: if (fileId >= 0 && fileId < tsFiles.Count)              {                  int tries = 5; // Try to change the file 5 times before giving up.                  do                  {                      try                      {                          tsReader = new FileStream(tsFiles[fileId].Location' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                          tsReaderFile = tsFiles[fileId];                            state = State.Playing;                // Set the state so the file is ready to play.                          tsReaderPosition = 0;                 // Reset the reader position to the start.                          return;                      }                      catch (IOException)                      {                          // Give it a moment.                          System.Threading.Thread.Sleep(10);                      }                  } while (--tries != 0);              }
Magic Number,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,ChangeTsFile,The following statement contains a magic number: if (fileId >= 0 && fileId < tsFiles.Count)              {                  int tries = 5; // Try to change the file 5 times before giving up.                  do                  {                      try                      {                          tsReader = new FileStream(tsFiles[fileId].Location' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                          tsReaderFile = tsFiles[fileId];                            state = State.Playing;                // Set the state so the file is ready to play.                          tsReaderPosition = 0;                 // Reset the reader position to the start.                          return;                      }                      catch (IOException)                      {                          // Give it a moment.                          System.Threading.Thread.Sleep(10);                      }                  } while (--tries != 0);              }
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,GetTranscodingInfo,The following statement contains a magic number: if (playerPosition.HasValue)              {                  _stream.SetPlayerPosition(identifier' playerPosition.Value * 1000);              }
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,InitStream,The following statement contains a magic number: return _stream.InitStream(identifier' clientDescription' new MediaSource(type' provider' itemId' offset)' idleTimeout.HasValue ? idleTimeout.Value : 5 * 60);
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,InitStream,The following statement contains a magic number: return _stream.InitStream(identifier' clientDescription' new MediaSource(type' provider' itemId' offset)' idleTimeout.HasValue ? idleTimeout.Value : 5 * 60);
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,StartStream,The following statement contains a magic number: return _stream.StartStream(identifier' Configuration.StreamingProfiles.GetTranscoderProfileByName(profileName)' startPosition * 1000);
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,StartStreamWithStreamSelection,The following statement contains a magic number: return _stream.StartStream(identifier' Configuration.StreamingProfiles.GetTranscoderProfileByName(profileName)' startPosition * 1000' audioId' subtitleId);
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,DoStream,The following statement contains a magic number: int timeout = profile.Transcoder == typeof(Transcoders.Direct).FullName ? 5 * 60 : 5;
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,DoStream,The following statement contains a magic number: int timeout = profile.Transcoder == typeof(Transcoders.Direct).FullName ? 5 * 60 : 5;
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,DoStream,The following statement contains a magic number: int timeout = profile.Transcoder == typeof(Transcoders.Direct).FullName ? 5 * 60 : 5;
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,DoStream,The following statement contains a magic number: string identifier = String.Format("dostream-{0}"' new Random().Next(10000' 99999));
Magic Number,MPExtended.Services.StreamingService,StreamingService,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\StreamingService.cs,DoStream,The following statement contains a magic number: string identifier = String.Format("dostream-{0}"' new Random().Next(10000' 99999));
Magic Number,MPExtended.Services.StreamingService.MediaInfo,XmlCache,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\XmlCache.cs,XmlCache,The following statement contains a magic number: flushTimer = new Timer(60 * 1000);
Magic Number,MPExtended.Services.StreamingService.MediaInfo,XmlCache,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\XmlCache.cs,XmlCache,The following statement contains a magic number: flushTimer = new Timer(60 * 1000);
Magic Number,MPExtended.Services.StreamingService.MediaInfo,MediaInfoWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfoWrapper.cs,GetMediaInfo,The following statement contains a magic number: if (source.MediaType == WebMediaType.TV)              {                  if (tvCache.ContainsKey(source.Id) && DateTime.Now - tvCache[source.Id].Item1 > TimeSpan.FromSeconds(60))                      return tvCache[source.Id].Item2;                    TsBuffer tsBuffer = new TsBuffer(source.Id);                  Log.Debug("Using path {0} from TS buffer {1} as source for {2}"' tsBuffer.GetCurrentFilePath()' source.Id' source.GetDebugName());                  WebMediaInfo info = LoadMediaInfo(tsBuffer.GetCurrentFilePath());                  tvCache[source.Id] = new Tuple<DateTime' WebMediaInfo>(DateTime.Now' info);                  return info;              }
Magic Number,MPExtended.Services.StreamingService.MediaInfo,MediaInfoWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\MediaInfo\MediaInfoWrapper.cs,LoadMediaInfo,The following statement contains a magic number: try              {                  if (source == null || !File.Exists(source))                  {                      Log.Warn("GetMediaInfo: File {0} doesn't exist or is not accessible"' source);                      return null;                  }                    /* Loosely based upon MediaInfoWrapper.cs (mediaportal/Core/Player) from MediaPortal trunk r27491 as of 15 June 2011                   *                    * Using the whole wrapper from MediaPortal is quite much porting work as it's cluttered with calls to other MP code. Referencing                   * MediaPortal.Core.dll also isn't an option as that pulls in a big tree of dependencies.                    *                    * TODO: Needs error handling                   * TODO: No support for DVDs yet                   * TODO: Aspect ratio doesn't work properly yet                   */                  MediaInfo info = new MediaInfo();                  info.Option("ParseSpeed"' "0.3");                  info.Open(source);                  WebMediaInfo retinfo = new WebMediaInfo();                  retinfo.Container = info.Get(StreamKind.General' 0' "Format");                    // video                  retinfo.VideoStreams = new List<WebVideoStream>();                  int videoStreams = info.Count_Get(StreamKind.Video);                  for (int i = 0; i < videoStreams; i++)                  {                      retinfo.Duration = retinfo.Duration == 0 ? (long)StringToInt(info.Get(StreamKind.Video' i' "Duration")) : retinfo.Duration;                        string val = info.Get(StreamKind.Video' i' "DisplayAspectRatio");                      retinfo.VideoStreams.Add(new WebVideoStream()                      {                          Codec = info.Get(StreamKind.Video' i' "Codec/String")'                          DisplayAspectRatio = StringToDecimal(info.Get(StreamKind.Video' i' "DisplayAspectRatio"))'                          DisplayAspectRatioString = info.Get(StreamKind.Video' i' "DisplayAspectRatio/String")'                          Interlaced = info.Get(StreamKind.Video' i' "ScanType") == "Interlaced"'                          Width = StringToInt(info.Get(StreamKind.Video' i' "Width"))'                          Height = StringToInt(info.Get(StreamKind.Video' i' "Height"))'                          ID = StringToInt(info.Get(StreamKind.Video' i' "ID"))'                          Index = i                      });                  }                    // audio codecs                  retinfo.AudioStreams = new List<WebAudioStream>();                  int audioStreams = info.Count_Get(StreamKind.Audio);                  for (int i = 0; i < audioStreams; i++)                  {                      retinfo.Duration = retinfo.Duration == 0 ? (long)StringToInt(info.Get(StreamKind.Audio' i' "Duration")) : retinfo.Duration;                      retinfo.AudioStreams.Add(new WebAudioStream()                      {                          Channels = StringToInt(info.Get(StreamKind.Audio' i' "Channels"))'                          Codec = info.Get(StreamKind.Audio' i' "Codec/String")'                          ID = StringToInt(info.Get(StreamKind.Audio' i' "ID"))'                          Language = info.Get(StreamKind.Audio' i' "Language")'                          LanguageFull = info.Get(StreamKind.Audio' i' "Language/String")'                          Title = info.Get(StreamKind.Audio' i' "Title")'                          Index = i                      });                  }                    // subtitle codecs                  retinfo.SubtitleStreams = new List<WebSubtitleStream>();                  int subtitleStreams = info.Count_Get(StreamKind.Text);                  int scodecnr = 0;                  for (scodecnr = 0; scodecnr < subtitleStreams; scodecnr++)                  {                      retinfo.SubtitleStreams.Add(new WebSubtitleStream()                      {                          Language = info.Get(StreamKind.Text' scodecnr' "Language")'                          LanguageFull = info.Get(StreamKind.Text' scodecnr' "Language/String")'                          ID = StringToInt(info.Get(StreamKind.Text' scodecnr' "ID"))'                          Index = scodecnr'                          Filename = null                      });                  }                    // get max subtitle id                  var list = retinfo.SubtitleStreams.Select(x => x.ID);                  int lastId = list.Count() == 0 ? 0 : list.Max();                    // standard name of external subtitle files                  string subfile = Path.Combine(Path.GetDirectoryName(source)' Path.GetFileNameWithoutExtension(source) + ".srt");                  if (File.Exists(subfile))                  {                      retinfo.SubtitleStreams.Add(new WebSubtitleStream()                      {                          Language = "ext"'                          LanguageFull = "External subtitle file"'                          ID = ++lastId' // a file with so many streams seems quite unlikely to me                          Index = ++scodecnr'                          Filename = subfile                      });                  }                    try                  {                      // language in subtitle filename                      foreach (string file in Directory.EnumerateFiles(Path.GetDirectoryName(source)' Path.GetFileNameWithoutExtension(source) + ".*.srt"))                      {                          string basename = Path.GetFileName(file).Substring(Path.GetFileNameWithoutExtension(source).Length);                          string tag = basename.Substring(1' basename.Length - 5);                          retinfo.SubtitleStreams.Add(new WebSubtitleStream()                          {                              Language = LookupCountryCode(tag)'                              LanguageFull = tag'                              ID = ++lastId'                              Index = ++scodecnr'                              Filename = file                          });                      }                  }                  catch (UnauthorizedAccessException ex)                  {                      // enumerating network shares could fail' not sure why though                      Log.Debug(String.Format("Failed to enumerate files in {0}"' Path.GetDirectoryName(source))' ex);                  }                    // return                  info.Close();                  return retinfo;              }              catch (Exception ex)              {                  Log.Error("Error parsing MediaInfo for " + source' ex);                  return null;              }
Magic Number,MPExtended.Services.StreamingService.Transcoders,FFMpegHTTPLiveStreamer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpegHTTPLiveStreamer.cs,ProvideCustomActionFile,The following statement contains a magic number: if (action == "playlist")              {                  WCFUtil.SetContentType("application/vnd.apple.mpegurl");                  string playlistPath = Path.Combine(TemporaryDirectory' "index.m3u8");                  if (!File.Exists(playlistPath))                  {                      StreamLog.Warn(Identifier' "HTTPLiveStreamer: Client requested index.m3u8 that doesn't exist for identifier '{0}'"' Identifier);                      return Stream.Null;                  }                    // FFMpeg outputs the local segment paths in the playlist' replace with url                  string playlist = ReplacePathsWithURLs(playlistPath);                  if (playlist == string.Empty)                  {                      // The playlist file is empty until the first segment has finished being encoded'                      // wait for next segment to begin and retry.                       string segmentPath = Path.Combine(TemporaryDirectory' "000001.ts");                      while (!File.Exists(segmentPath))                          System.Threading.Thread.Sleep(100);                      playlist = ReplacePathsWithURLs(playlistPath);                  }                  return new MemoryStream(Encoding.UTF8.GetBytes(playlist));              }
Magic Number,MPExtended.Services.StreamingService.Transcoders,Generic,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\Generic.cs,BuildPipeline,The following statement contains a magic number: string arguments = Context.Profile.TranscoderParameters["arguments"]                  .Replace("#WIDTH#"' Context.OutputSize.Width.ToString())                  .Replace("#HEIGHT#"' Context.OutputSize.Height.ToString())                  .Replace("#AUDIOSTREAMID#"' Context.AudioTrackId.ToString())                  .Replace("#STARTPOSITION#"' Math.Round((decimal)Context.StartPosition / 1000).ToString());
Magic Number,MPExtended.Services.StreamingService.Transcoders,Generic,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\Generic.cs,BuildPipeline,The following statement contains a magic number: Context.Pipeline.AddDataUnit(unit' 5);
Magic Number,MPExtended.Services.StreamingService.Transcoders,FFMpeg,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpeg.cs,BuildPipeline,The following statement contains a magic number: Context.Pipeline.AddDataUnit(unit' 5);
Magic Number,MPExtended.Services.StreamingService.Transcoders,FFMpeg,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpeg.cs,BuildPipeline,The following statement contains a magic number: Context.Pipeline.AddLogUnit(logunit' 6);
Magic Number,MPExtended.Services.StreamingService.Transcoders,FFMpeg,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpeg.cs,GenerateArguments,The following statement contains a magic number: if (Context.Profile.HasVideoStream && doResize)              {                  arguments = String.Format(                      "-y {0} -i \"#IN#\" -s {1} -aspect {2}:{3} {4} {5}{6}"'                      Context.StartPosition != 0 ? "-ss " + (Context.StartPosition / 1000) : ""'                      Context.OutputSize' Context.OutputSize.Width' Context.OutputSize.Height'                      mappings' Context.Profile.TranscoderParameters["codecParameters"]'                      ReadOutputStream ? " \"#OUT#\"" : ""                                      );              }              else              {                  arguments = String.Format(                      "-y {0} -i \"#IN#\" {1} {2}{3}"'                      Context.StartPosition != 0 ? "-ss " + (Context.StartPosition / 1000) : ""'                      mappings' Context.Profile.TranscoderParameters["codecParameters"]'                      ReadOutputStream ? " \"#OUT#\"" : ""                  );              }
Magic Number,MPExtended.Services.StreamingService.Transcoders,FFMpeg,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\FFMpeg.cs,GenerateArguments,The following statement contains a magic number: if (Context.Profile.HasVideoStream && doResize)              {                  arguments = String.Format(                      "-y {0} -i \"#IN#\" -s {1} -aspect {2}:{3} {4} {5}{6}"'                      Context.StartPosition != 0 ? "-ss " + (Context.StartPosition / 1000) : ""'                      Context.OutputSize' Context.OutputSize.Width' Context.OutputSize.Height'                      mappings' Context.Profile.TranscoderParameters["codecParameters"]'                      ReadOutputStream ? " \"#OUT#\"" : ""                                      );              }              else              {                  arguments = String.Format(                      "-y {0} -i \"#IN#\" {1} {2}{3}"'                      Context.StartPosition != 0 ? "-ss " + (Context.StartPosition / 1000) : ""'                      mappings' Context.Profile.TranscoderParameters["codecParameters"]'                      ReadOutputStream ? " \"#OUT#\"" : ""                  );              }
Magic Number,MPExtended.Services.StreamingService.Transcoders,VLC,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLC.cs,AddEncoderToPipeline,The following statement contains a magic number: Context.Pipeline.AddDataUnit(unit' 5);
Magic Number,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GetStreamURL,The following statement contains a magic number: if (Context.Profile.TranscoderParameters.ContainsKey("rtspOutput") && Context.Profile.TranscoderParameters["rtspOutput"] == "yes")              {                  Thread.Sleep(2500); // FIXME                  return "rtsp://" + WCFUtil.GetCurrentHostname() + ":5544/" + Identifier + ".sdp";              }              else              {                  return WCFUtil.GetCurrentRoot() + "StreamingService/stream/RetrieveStream?identifier=" + Identifier;              }
Magic Number,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,BuildPipeline,The following statement contains a magic number: if (Context.Profile.TranscoderParameters.ContainsKey("flvMetadataInjection") && Context.Profile.TranscoderParameters["flvMetadataInjection"] == "yes")              {                  Context.Pipeline.AddDataUnit(new FLVMetadataInjector(Context)' 15);              }
Magic Number,MPExtended.Services.StreamingService.Transcoders,VLCBaseTranscoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCBaseTranscoder.cs,GenerateVLCParameters,The following statement contains a magic number: if (Context.StartPosition > 0 && !disableSeeking)              {                  arguments.Add("--start-time=" + (Context.StartPosition / 1000));              }
Magic Number,MPExtended.Services.StreamingService.Transcoders,VLCManaged,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCManaged.cs,AddEncoderToPipeline,The following statement contains a magic number: int duration = (int)Math.Round((decimal)Context.MediaInfo.Duration / 1000);
Magic Number,MPExtended.Services.StreamingService.Transcoders,VLCManaged,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCManaged.cs,AddEncoderToPipeline,The following statement contains a magic number: Context.Pipeline.AddDataUnit(unit' 5);
Magic Number,MPExtended.Services.StreamingService.Transcoders,VLCWrapper,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Transcoders\VLCWrapper.cs,AddEncoderToPipeline,The following statement contains a magic number: Context.Pipeline.AddLogUnit(logunit' 6);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,Start,The following statement contains a magic number: injectionTask = Task.Factory.StartNew(delegate()              {                  byte[] bytes = new byte[1000];                  int result = InputStream.Read(bytes' 0' 1000);                  string bytesToFile = ByteArrayToString(bytes);                  string onMetaData = bytesToFile.Substring(27' 10);                  // if "onMetaData" exists then proceed to read the attributes                  if (onMetaData == "onMetaData")                  {                      int indexDuration = bytesToFile.IndexOf("duration");                      double durationOld = GetNextDouble(bytes' indexDuration + 9' 8);                      double durationNew = ((double)this.context.MediaInfo.Duration) / 1000;                      byte[] newDur = DoubleToByteArray(durationNew' true);                        for (int i = 0; i < 8; i++)                      {                          bytes[indexDuration + 9 + i] = newDur[i];                      }                  }                  String bytesToFileNew = ByteArrayToString(bytes);                  pipeServer.Write(bytes' 0' result);                    StreamCopy.AsyncStreamCopy(InputStream' pipeServer);              }' TaskCreationOptions.LongRunning);
Magic Number,MPExtended.Services.StreamingService.Units,FLVMetadataInjector,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FLVMetadataInjector.cs,ByteArrayToDouble,The following statement contains a magic number: if (bytes.Length != 8)                  throw new Exception("bytes must be exactly 8 in Length");
Magic Number,MPExtended.Services.StreamingService.Units,HTTPLiveStreamUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\HTTPLiveStreamUnit.cs,Start,The following statement contains a magic number: while (!File.Exists(indexFile))                  System.Threading.Thread.Sleep(100);
Magic Number,MPExtended.Services.StreamingService.Units,HTTPLiveStreamUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\HTTPLiveStreamUnit.cs,Stop,The following statement contains a magic number: Task.Factory.StartNew(delegate()              {                  try                  {                      Thread.Sleep(5000);                      var dir = Path.GetDirectoryName(indexFile);                      if (Directory.Exists(dir))                          Directory.Delete(dir' true);                  }                  catch (Exception ex)                  {                      Log.Warn("Failed to delete HTTP Live Streaming directory. Either your PC is horribly slow or a 0.001% chance of collision happened."' ex);                  }              });
Magic Number,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,Setup,The following statement contains a magic number: if (!DebugOutput && logStream == LogStream.StandardOut && IsLogStreamConnected && outputMethod != TransportMethod.StandardOut)              {                  LogOutputStream = transcoderApplication.StandardOutput.BaseStream;              }              else if (!DebugOutput && logStream == LogStream.StandardError && IsLogStreamConnected)              {                  LogOutputStream = transcoderApplication.StandardError.BaseStream;              }              else              {                  LogOutputStream = new MemoryStream(4096);              }
Magic Number,MPExtended.Services.StreamingService.Units,EncoderUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\EncoderUnit.cs,Start,The following statement contains a magic number: if (DataOutputStream is NamedPipe && (outputMethod == TransportMethod.NamedPipe || outputMethod == TransportMethod.StandardOut))              {                  StreamLog.Trace(context.Identifier' "Transcoder running: {0}"' !transcoderApplication.HasExited);                  StreamLog.Info(context.Identifier' "Encoding: Waiting till output named pipe is ready");                    var pipe = (NamedPipe)DataOutputStream;                  var checkFailed = context != null && context.TranscodingInfo != null;                  while (!pipe.IsReady && !(checkFailed && context.TranscodingInfo.Failed))                      System.Threading.Thread.Sleep(100);                    if (checkFailed && context.TranscodingInfo.Failed)                  {                      StreamLog.Warn(context.Identifier' "Encoding: Aborting wait because transcoder application failed and will never setup output named pipe.");                      return false;                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  try                  {                      bool canBeErrorLine = true;                        if (line.StartsWith("frame="))                      {                          // format of an output line (yes' we're doomed as soon as ffmpeg changes it output):                          // frame=  923 fps=256 q=31.0 size=    2712kB time=00:05:22.56 bitrate= 601.8kbits/s                          Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase);                          if (match.Success)                          {                              canBeErrorLine = false;                              lock (saveData)                              {                                  saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000;                                  saveData.Value.TranscodedFrames = Int32.Parse(match.Groups[1].Value);                                  saveData.Value.TranscodingPosition = startPosition + saveData.Value.TranscodedTime;                                  saveData.Value.TranscodingFPS = Int32.Parse(match.Groups[2].Value);                                  saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture));                              }                                if (!logProgress) // we don't log output                                  continue;                          }                      }                        if (line.StartsWith("video:"))                      {                          // process the result line to see if it completed successfully (example):                          // video:5608kB audio:781kB global headers:0kB muxing overhead 13.235302%                          Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase);                          saveData.Value.Finished = true;                          canBeErrorLine = false;                      }                        // show error messages                      if (logMessages && canBeErrorLine)                          StreamLog.Trace(identifier' "ffmpeg: " + line);                  }                  catch (ThreadAbortException)                  {                      saveData.Value.Failed = true;                      saveData.Value.Finished = true;                      reader.Close();                      return;                  }                  catch (Exception e)                  {                      StreamLog.Error(identifier' "Failure during parsing of ffmpeg output"' e);                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  try                  {                      bool canBeErrorLine = true;                        if (line.StartsWith("frame="))                      {                          // format of an output line (yes' we're doomed as soon as ffmpeg changes it output):                          // frame=  923 fps=256 q=31.0 size=    2712kB time=00:05:22.56 bitrate= 601.8kbits/s                          Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase);                          if (match.Success)                          {                              canBeErrorLine = false;                              lock (saveData)                              {                                  saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000;                                  saveData.Value.TranscodedFrames = Int32.Parse(match.Groups[1].Value);                                  saveData.Value.TranscodingPosition = startPosition + saveData.Value.TranscodedTime;                                  saveData.Value.TranscodingFPS = Int32.Parse(match.Groups[2].Value);                                  saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture));                              }                                if (!logProgress) // we don't log output                                  continue;                          }                      }                        if (line.StartsWith("video:"))                      {                          // process the result line to see if it completed successfully (example):                          // video:5608kB audio:781kB global headers:0kB muxing overhead 13.235302%                          Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase);                          saveData.Value.Finished = true;                          canBeErrorLine = false;                      }                        // show error messages                      if (logMessages && canBeErrorLine)                          StreamLog.Trace(identifier' "ffmpeg: " + line);                  }                  catch (ThreadAbortException)                  {                      saveData.Value.Failed = true;                      saveData.Value.Finished = true;                      reader.Close();                      return;                  }                  catch (Exception e)                  {                      StreamLog.Error(identifier' "Failure during parsing of ffmpeg output"' e);                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  try                  {                      bool canBeErrorLine = true;                        if (line.StartsWith("frame="))                      {                          // format of an output line (yes' we're doomed as soon as ffmpeg changes it output):                          // frame=  923 fps=256 q=31.0 size=    2712kB time=00:05:22.56 bitrate= 601.8kbits/s                          Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase);                          if (match.Success)                          {                              canBeErrorLine = false;                              lock (saveData)                              {                                  saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000;                                  saveData.Value.TranscodedFrames = Int32.Parse(match.Groups[1].Value);                                  saveData.Value.TranscodingPosition = startPosition + saveData.Value.TranscodedTime;                                  saveData.Value.TranscodingFPS = Int32.Parse(match.Groups[2].Value);                                  saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture));                              }                                if (!logProgress) // we don't log output                                  continue;                          }                      }                        if (line.StartsWith("video:"))                      {                          // process the result line to see if it completed successfully (example):                          // video:5608kB audio:781kB global headers:0kB muxing overhead 13.235302%                          Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase);                          saveData.Value.Finished = true;                          canBeErrorLine = false;                      }                        // show error messages                      if (logMessages && canBeErrorLine)                          StreamLog.Trace(identifier' "ffmpeg: " + line);                  }                  catch (ThreadAbortException)                  {                      saveData.Value.Failed = true;                      saveData.Value.Finished = true;                      reader.Close();                      return;                  }                  catch (Exception e)                  {                      StreamLog.Error(identifier' "Failure during parsing of ffmpeg output"' e);                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  try                  {                      bool canBeErrorLine = true;                        if (line.StartsWith("frame="))                      {                          // format of an output line (yes' we're doomed as soon as ffmpeg changes it output):                          // frame=  923 fps=256 q=31.0 size=    2712kB time=00:05:22.56 bitrate= 601.8kbits/s                          Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase);                          if (match.Success)                          {                              canBeErrorLine = false;                              lock (saveData)                              {                                  saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000;                                  saveData.Value.TranscodedFrames = Int32.Parse(match.Groups[1].Value);                                  saveData.Value.TranscodingPosition = startPosition + saveData.Value.TranscodedTime;                                  saveData.Value.TranscodingFPS = Int32.Parse(match.Groups[2].Value);                                  saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture));                              }                                if (!logProgress) // we don't log output                                  continue;                          }                      }                        if (line.StartsWith("video:"))                      {                          // process the result line to see if it completed successfully (example):                          // video:5608kB audio:781kB global headers:0kB muxing overhead 13.235302%                          Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase);                          saveData.Value.Finished = true;                          canBeErrorLine = false;                      }                        // show error messages                      if (logMessages && canBeErrorLine)                          StreamLog.Trace(identifier' "ffmpeg: " + line);                  }                  catch (ThreadAbortException)                  {                      saveData.Value.Failed = true;                      saveData.Value.Finished = true;                      reader.Close();                      return;                  }                  catch (Exception e)                  {                      StreamLog.Error(identifier' "Failure during parsing of ffmpeg output"' e);                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  try                  {                      bool canBeErrorLine = true;                        if (line.StartsWith("frame="))                      {                          // format of an output line (yes' we're doomed as soon as ffmpeg changes it output):                          // frame=  923 fps=256 q=31.0 size=    2712kB time=00:05:22.56 bitrate= 601.8kbits/s                          Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase);                          if (match.Success)                          {                              canBeErrorLine = false;                              lock (saveData)                              {                                  saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000;                                  saveData.Value.TranscodedFrames = Int32.Parse(match.Groups[1].Value);                                  saveData.Value.TranscodingPosition = startPosition + saveData.Value.TranscodedTime;                                  saveData.Value.TranscodingFPS = Int32.Parse(match.Groups[2].Value);                                  saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture));                              }                                if (!logProgress) // we don't log output                                  continue;                          }                      }                        if (line.StartsWith("video:"))                      {                          // process the result line to see if it completed successfully (example):                          // video:5608kB audio:781kB global headers:0kB muxing overhead 13.235302%                          Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase);                          saveData.Value.Finished = true;                          canBeErrorLine = false;                      }                        // show error messages                      if (logMessages && canBeErrorLine)                          StreamLog.Trace(identifier' "ffmpeg: " + line);                  }                  catch (ThreadAbortException)                  {                      saveData.Value.Failed = true;                      saveData.Value.Finished = true;                      reader.Close();                      return;                  }                  catch (Exception e)                  {                      StreamLog.Error(identifier' "Failure during parsing of ffmpeg output"' e);                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  try                  {                      bool canBeErrorLine = true;                        if (line.StartsWith("frame="))                      {                          // format of an output line (yes' we're doomed as soon as ffmpeg changes it output):                          // frame=  923 fps=256 q=31.0 size=    2712kB time=00:05:22.56 bitrate= 601.8kbits/s                          Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase);                          if (match.Success)                          {                              canBeErrorLine = false;                              lock (saveData)                              {                                  saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000;                                  saveData.Value.TranscodedFrames = Int32.Parse(match.Groups[1].Value);                                  saveData.Value.TranscodingPosition = startPosition + saveData.Value.TranscodedTime;                                  saveData.Value.TranscodingFPS = Int32.Parse(match.Groups[2].Value);                                  saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture));                              }                                if (!logProgress) // we don't log output                                  continue;                          }                      }                        if (line.StartsWith("video:"))                      {                          // process the result line to see if it completed successfully (example):                          // video:5608kB audio:781kB global headers:0kB muxing overhead 13.235302%                          Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase);                          saveData.Value.Finished = true;                          canBeErrorLine = false;                      }                        // show error messages                      if (logMessages && canBeErrorLine)                          StreamLog.Trace(identifier' "ffmpeg: " + line);                  }                  catch (ThreadAbortException)                  {                      saveData.Value.Failed = true;                      saveData.Value.Finished = true;                      reader.Close();                      return;                  }                  catch (Exception e)                  {                      StreamLog.Error(identifier' "Failure during parsing of ffmpeg output"' e);                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  try                  {                      bool canBeErrorLine = true;                        if (line.StartsWith("frame="))                      {                          // format of an output line (yes' we're doomed as soon as ffmpeg changes it output):                          // frame=  923 fps=256 q=31.0 size=    2712kB time=00:05:22.56 bitrate= 601.8kbits/s                          Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase);                          if (match.Success)                          {                              canBeErrorLine = false;                              lock (saveData)                              {                                  saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000;                                  saveData.Value.TranscodedFrames = Int32.Parse(match.Groups[1].Value);                                  saveData.Value.TranscodingPosition = startPosition + saveData.Value.TranscodedTime;                                  saveData.Value.TranscodingFPS = Int32.Parse(match.Groups[2].Value);                                  saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture));                              }                                if (!logProgress) // we don't log output                                  continue;                          }                      }                        if (line.StartsWith("video:"))                      {                          // process the result line to see if it completed successfully (example):                          // video:5608kB audio:781kB global headers:0kB muxing overhead 13.235302%                          Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase);                          saveData.Value.Finished = true;                          canBeErrorLine = false;                      }                        // show error messages                      if (logMessages && canBeErrorLine)                          StreamLog.Trace(identifier' "ffmpeg: " + line);                  }                  catch (ThreadAbortException)                  {                      saveData.Value.Failed = true;                      saveData.Value.Finished = true;                      reader.Close();                      return;                  }                  catch (Exception e)                  {                      StreamLog.Error(identifier' "Failure during parsing of ffmpeg output"' e);                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,FFMpegLogParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\FFMpegLogParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  try                  {                      bool canBeErrorLine = true;                        if (line.StartsWith("frame="))                      {                          // format of an output line (yes' we're doomed as soon as ffmpeg changes it output):                          // frame=  923 fps=256 q=31.0 size=    2712kB time=00:05:22.56 bitrate= 601.8kbits/s                          Match match = Regex.Match(line' @"frame=([ 0-9]*) fps=([ 0-9]*) q=[^ ]* L?size=([ 0-9]*)kB time=([0-9]{2}):([0-9]{2}):([0-9]{2})\.[0-9]{2} bitrate=([ .0-9]*)kbits/s"' RegexOptions.IgnoreCase);                          if (match.Success)                          {                              canBeErrorLine = false;                              lock (saveData)                              {                                  saveData.Value.TranscodedTime = (Int32.Parse(match.Groups[4].Value) * 3600 + Int32.Parse(match.Groups[5].Value) * 60 + Int32.Parse(match.Groups[6].Value)) * 1000;                                  saveData.Value.TranscodedFrames = Int32.Parse(match.Groups[1].Value);                                  saveData.Value.TranscodingPosition = startPosition + saveData.Value.TranscodedTime;                                  saveData.Value.TranscodingFPS = Int32.Parse(match.Groups[2].Value);                                  saveData.Value.OutputBitrate = (int)Math.Round(Decimal.Parse(match.Groups[7].Value' System.Globalization.CultureInfo.InvariantCulture));                              }                                if (!logProgress) // we don't log output                                  continue;                          }                      }                        if (line.StartsWith("video:"))                      {                          // process the result line to see if it completed successfully (example):                          // video:5608kB audio:781kB global headers:0kB muxing overhead 13.235302%                          Match resultMatch = Regex.Match(line' @"video:([0-9]*)kB audio:([0-9]*)kB global headers:([0-9]*)kB muxing overhead[^%]*%"' RegexOptions.IgnoreCase);                          saveData.Value.Finished = true;                          canBeErrorLine = false;                      }                        // show error messages                      if (logMessages && canBeErrorLine)                          StreamLog.Trace(identifier' "ffmpeg: " + line);                  }                  catch (ThreadAbortException)                  {                      saveData.Value.Failed = true;                      saveData.Value.Finished = true;                      reader.Close();                      return;                  }                  catch (Exception e)                  {                      StreamLog.Error(identifier' "Failure during parsing of ffmpeg output"' e);                  }              }
Magic Number,MPExtended.Services.StreamingService.Units,VLCManagedEncoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCManagedEncoder.cs,Start,The following statement contains a magic number: if (context.MediaInfo.Duration > 0)              {                  StreamLog.Trace(context.Identifier' "VLCManagedInfo: duration known; is {0}"' context.MediaInfo.Duration);                  calculator = new TranscodingInfoCalculator(context.StartPosition' 25' POLL_DATA_TIME' context.MediaInfo.Duration);              }              else              {                  StreamLog.Trace(context.Identifier' "VLCManagedInfo: duration unknown");                  calculator = new TranscodingInfoCalculator(context.StartPosition' 25' POLL_DATA_TIME);              }
Magic Number,MPExtended.Services.StreamingService.Units,VLCManagedEncoder,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCManagedEncoder.cs,Start,The following statement contains a magic number: if (context.MediaInfo.Duration > 0)              {                  StreamLog.Trace(context.Identifier' "VLCManagedInfo: duration known; is {0}"' context.MediaInfo.Duration);                  calculator = new TranscodingInfoCalculator(context.StartPosition' 25' POLL_DATA_TIME' context.MediaInfo.Duration);              }              else              {                  StreamLog.Trace(context.Identifier' "VLCManagedInfo: duration unknown");                  calculator = new TranscodingInfoCalculator(context.StartPosition' 25' POLL_DATA_TIME);              }
Magic Number,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,Start,The following statement contains a magic number: while (!vlcIsStarted)                  Thread.Sleep(100);
Magic Number,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: TranscodingInfoCalculator calculator = new TranscodingInfoCalculator(position' 25' 500' info.Duration);
Magic Number,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: TranscodingInfoCalculator calculator = new TranscodingInfoCalculator(position' 25' 500' info.Duration);
Magic Number,MPExtended.Services.StreamingService.Units,VLCWrapperParsingUnit,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Units\VLCWrapperParsingUnit.cs,ParseOutputStream,The following statement contains a magic number: try              {                  while ((line = reader.ReadLine()) != null)                  {                      try                      {                          StreamLog.Trace(identifier' "VLCWrapperParsing: read line {0}"' line);                            // just for debugging of the wrapper tool                          if (line.StartsWith("A") || line.StartsWith("I") || line == "S started" || line == "S null")                              continue;                            // propagate start event to Start() method                          if (line == "S playing")                          {                              vlcIsStarted = true;                              continue;                          }                            // events                          if (line == "S error")                          {                              vlcIsStarted = true;                              data.Value.Finished = true;                              data.Value.Failed = true;                              break;                          }                            if (line == "S finished")                          {                              data.Value.Finished = true;                              continue;                          }                            // the actual progress parsing                          if (line.StartsWith("P"))                          {                              // Starting with VLCWrapper 0.2' the output format has changed. It is 'P [time in milliseconds]' now' which is quite easy for                              // us to handle. With VLC 2 it also returns the time as a 64-bit integer' so we don't have overflow anymore either' but that risk                              // is with milliseconds quite small anyhow: it requires 596 hours of video.                              long milliseconds = Int64.Parse(line.Substring(2));                              calculator.NewTime((int)milliseconds);                              calculator.SaveStats(data);                              continue;                          }                            StreamLog.Warn(identifier' "VLCWrapperParsing: encountered unknown line {0}"' line);                      }                      catch (ThreadAbortException)                      {                          data.Value.Finished = true;                          reader.Close();                          return;                      }                      catch (Exception e)                      {                          StreamLog.Error(identifier' "Failure during parsing of VLC output"' e);                      }                  }              }              catch (ThreadAbortException)              {                  // The double try-catch is to make sure that the parsing doesn't stop when it can't process a single line' but that we don't                  // log too much noise when a ThreadAbortException occurs while in the ReadLine() method. Funnily enough' this exception is                  // rethrown when we leave the catch block' so duplicate some code from below...                   data.Value.Finished = true;                  reader.Close();                  return;              }
Missing Default,MPExtended.Services.StreamingService.Code,MediaSource,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\MediaSource.cs,GetMediaDisplayName,The following switch statement is missing a default case: switch (MediaType)                  {                      case WebMediaType.File:                          return Connections.MAS.GetFileSystemFileBasicById(Provider' Id).Title;                      case WebMediaType.Movie:                          return Connections.MAS.GetMovieBasicById(Provider' Id).Title;                      case WebMediaType.MusicAlbum:                          return Connections.MAS.GetMusicAlbumBasicById(Provider' Id).Title;                      case WebMediaType.MusicTrack:                          return Connections.MAS.GetMusicTrackBasicById(Provider' Id).Title;                      case WebMediaType.Picture:                          return Connections.MAS.GetPictureBasicById(Provider' Id).Title;                      case WebMediaType.Recording:                          return Connections.TAS.GetRecordingById(Int32.Parse(Id)).Title;                      case WebMediaType.TV:                          int channelId;                          if (!Int32.TryParse(Id' out channelId))                          {                              var cards = Connections.TAS.GetActiveCards().ToList();                              if (!cards.Any(x => x.TimeShiftFileName == Id))                              {                                  Log.Info("Cannot find card for timeshift buffer {0} (but did find {1})' what's happening?!"'                                      Id' String.Join("' "' cards.Select(x => x.TimeShiftFileName)));                                  return String.Empty;                              }                              channelId = cards.First(x => x.TimeShiftFileName == Id).ChannelId;                          }                          return Connections.TAS.GetChannelBasicById(channelId).Title;                      case WebMediaType.TVEpisode:                          var ep = Connections.MAS.GetTVEpisodeBasicById(Provider' Id);                          var season = Connections.MAS.GetTVSeasonBasicById(Provider' ep.SeasonId);                          var show = Connections.MAS.GetTVShowBasicById(Provider' ep.ShowId);                          return String.Format("{0} ({1} {2}x{3})"' ep.Title' show.Title' season.SeasonNumber' ep.EpisodeNumber);                      case WebMediaType.TVSeason:                          var season2 = Connections.MAS.GetTVSeasonDetailedById(Provider' Id);                          var show2 = Connections.MAS.GetTVShowBasicById(Provider' season2.ShowId);                          return String.Format("{0} season {1}"' show2.Title' season2.SeasonNumber);                      case WebMediaType.TVShow:                          return Connections.MAS.GetTVShowBasicById(Provider' Id).Title;                  }
Missing Default,MPExtended.Services.StreamingService.Code,TsBuffer,C:\repos\MPExtended_MPExtended\Services\MPExtended.Services.StreamingService\Code\TsBuffer.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      // Check if the offset is out of bounds.                      if (offset < 0 || (offset + minPosition) > maxPosition)                      {                          state = State.UnknownError;                          return -1;                      }                        tsReaderPosition = minPosition + offset;                      break;                  case SeekOrigin.Current:                      if ((tsReaderPosition + offset) < minPosition || (tsReaderPosition + offset) > maxPosition)                      {                          state = State.UnknownError;                          return -1;                      }                        tsReaderPosition += offset;                      break;                  case SeekOrigin.End:                      if (offset > 0 || (maxPosition + 1) < minPosition)                      {                          state = State.UnknownError;                          return -1;                      }                        tsReaderPosition = maxPosition + offset;                      break;              }
